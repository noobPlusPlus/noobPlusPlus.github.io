<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>connect省略receiver会怎样</title>
    <link href="/noob/2022/01/23/connect%E7%9C%81%E7%95%A5receiver%E4%BC%9A%E6%80%8E%E6%A0%B7/"/>
    <url>/noob/2022/01/23/connect%E7%9C%81%E7%95%A5receiver%E4%BC%9A%E6%80%8E%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>QObject::disconnect()</code>函数使用,以及个人发现的小问题</p></blockquote><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="image1.png" alt="image1"></p><p>有两个对话框<code>MainWindow</code>和<code>测试</code>，当点击<code>MainWindow</code>中的<code>测试</code>按钮时，<code>测试</code>窗口长宽变为400px，并弹出提示窗，如下所示：</p><p><img src="image2.png" alt="image2"></p><p>当点击<code>销毁窗口</code>时，销毁<code>测试</code>窗口。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++">MainWindow::MainWindow(QWidget *parent)<br>    : QMainWindow(parent)<br>    , ui(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br>    dialog_ = <span class="hljs-keyword">new</span> Dialog(<span class="hljs-keyword">this</span>);<br>    dialog_-&gt;setWindowTitle(<span class="hljs-string">u8&quot;测试窗口&quot;</span>);<br>    dialog_-&gt;setFixedSize(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<br>    dialog_-&gt;show();<br><br>    connect(ui-&gt;pushButton_2, &amp;QPushButton::clicked, [=]() &#123;<br>        dialog_-&gt;deleteLater();<br>        &#125;);<br><br>    connect(ui-&gt;pushButton, &amp;QPushButton::clicked,<br>        <span class="hljs-keyword">this</span>, &amp;MainWindow::senderButtonClicked);<br>   <br>&#125;<br><br>MainWindow::~MainWindow()<br>&#123;<br>    <span class="hljs-keyword">delete</span> ui;<br>&#125;<br><br>Dialog::Dialog(QWidget* parent)<br>    : QDialog(parent)<br>&#123;<br>    connect(<span class="hljs-keyword">static_cast</span>&lt;MainWindow*&gt;(parentWidget()), &amp;MainWindow::senderButtonClicked, [=]() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;setFixedSize(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>        QMessageBox::information(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">u8&quot;通知&quot;</span>, <span class="hljs-string">u8&quot;信号已相应&quot;</span>);<br>        &#125;);<br>        <br>    <span class="hljs-comment">//connect(static_cast&lt;MainWindow*&gt;(parentWidget()), &amp;MainWindow::senderButtonClicked, this, [=]() &#123;</span><br>    <span class="hljs-comment">//    //只多了第三个参数，this</span><br>    <span class="hljs-comment">//    this-&gt;setFixedSize(400, 400);</span><br>    <span class="hljs-comment">//    QMessageBox::information(nullptr, u8&quot;通知&quot;, u8&quot;信号已相应&quot;);</span><br>    <span class="hljs-comment">//    &#125;);</span><br>&#125;<br><br>Dialog::~Dialog()<br>&#123;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>如果先点销毁，再点击测试，程序崩溃在<code>this-&gt;setFixedSize(400, 400);</code>行。</p><p>将代码改为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">Dialog::Dialog(QWidget* parent)<br>    : QDialog(parent)<br>&#123;<br>    connect(<span class="hljs-keyword">static_cast</span>&lt;MainWindow*&gt;(parentWidget()), &amp;MainWindow::senderButtonClicked, <span class="hljs-keyword">this</span>, [=]() &#123;<br>        <span class="hljs-comment">//只多了第三个参数，this</span><br>        <span class="hljs-keyword">this</span>-&gt;setFixedSize(<span class="hljs-number">400</span>, <span class="hljs-number">400</span>);<br>        QMessageBox::information(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">u8&quot;通知&quot;</span>, <span class="hljs-string">u8&quot;信号已相应&quot;</span>);<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>先点销毁，再点击测试，不会崩溃。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>查看Qt助手，<code>disconnect</code>中有如下说明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[<span class="hljs-keyword">static</span>] <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PointerToMemberFunction&gt; <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">QObject::disconnect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QObject *sender, PointerToMemberFunction signal, <span class="hljs-keyword">const</span> QObject *receiver, PointerToMemberFunction method)</span></span><br></code></pre></td></tr></table></figure><blockquote><p>A signal-slot connection is removed when either of the objects involved are destroyed.</p></blockquote><p>如下所示新式<code>connect</code>重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[<span class="hljs-keyword">static</span>] <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PointerToMemberFunction, <span class="hljs-keyword">typename</span> Functor&gt; [QMetaObject::Connection](qmetaobject-connection.html) QObject::connect(<span class="hljs-keyword">const</span> [QObject](qobject.html#QObject) **sender*, PointerToMemberFunction *signal*, Functor *functor*)<br></code></pre></td></tr></table></figure><p>有如下说明：</p><blockquote><p>The connection will automatically disconnect if the sender is destroyed. However, you should take care that any objects used within the functor are still alive when the signal is emitted.</p></blockquote><p>对于如下所示旧式<code>connect</code>重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QMetaObject::Connection <span class="hljs-title">QObject::connect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QObject *sender, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *signal, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span> <span class="hljs-keyword">const</span></span><br></code></pre></td></tr></table></figure><p>有如下说明:</p><blockquote><p>This function overloads connect().</p><p>Equivalent to connect(<em>sender</em>, <em>signal</em>, this, <em>method</em>, <em>type</em>).</p></blockquote><p>所以虽然都省略了<code>receiver</code>, 但是意义却不同。</p><p>对于形如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[<span class="hljs-keyword">static</span>] <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PointerToMemberFunction, <span class="hljs-keyword">typename</span> Functor&gt; [QMetaObject::Connection](qmetaobject-connection.html) QObject::connect(<span class="hljs-keyword">const</span> [QObject](qobject.html#QObject) **sender*, PointerToMemberFunction *signal*, Functor *functor*)<br></code></pre></td></tr></table></figure><p>的新式<code>connect</code>函数，并不等同于省略了<code>receiver</code>, 只有当<code>sender</code>被<code>destroyed</code>时才会自动disconnect。所以需要保证<code>lambda</code>被调用时，其所捕获的对象还存在，否则就会崩溃。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>采用新式不省略<code>receiver</code>的<code>connect</code>函数。</li><li><code>disconnect(connection)</code>其中<code>QMetaObject::Connection connection = connect(........)</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>信号槽</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刘典武Qt开发经验摘录</title>
    <link href="/noob/2022/01/16/%E5%88%98%E5%85%B8%E6%AD%A6Qt%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%91%98%E5%BD%95/"/>
    <url>/noob/2022/01/16/%E5%88%98%E5%85%B8%E6%AD%A6Qt%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%91%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>刘典武经验中个人感觉后期可能会用到的，或之前用过容易遗忘的，分类摘录，方便后期查阅，侵删。<br>项目地址<br><a href="https://gitee.com/feiyangqingyun/qtkaifajingyan">飞扬青云/Qt开发经验</a></p><span id="more"></span></blockquote><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><h3 id="6-可以在pro文件中写上标记版本号-ico图标（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件"><a href="#6-可以在pro文件中写上标记版本号-ico图标（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件" class="headerlink" title="6.可以在pro文件中写上标记版本号+ico图标（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件"></a>6.可以在pro文件中写上标记版本号+ico图标（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VERSION  = <span class="hljs-number">2025.10</span><span class="hljs-number">.01</span><br>RC_ICONS = main.ico<br><br></code></pre></td></tr></table></figure><h3 id="9-绘制平铺背景QPainter-drawTiledPixmap-绘制圆角矩形QPainter-drawRoundedRect-而不是QPainter-drawRoundRect"><a href="#9-绘制平铺背景QPainter-drawTiledPixmap-绘制圆角矩形QPainter-drawRoundedRect-而不是QPainter-drawRoundRect" class="headerlink" title="9. 绘制平铺背景QPainter::drawTiledPixmap,绘制圆角矩形QPainter::drawRoundedRect(),而不是QPainter::drawRoundRect()"></a>9. 绘制平铺背景QPainter::drawTiledPixmap,绘制圆角矩形QPainter::drawRoundedRect(),而不是QPainter::drawRoundRect()</h3><h3 id="10-移除旧的样式"><a href="#10-移除旧的样式" class="headerlink" title="10. 移除旧的样式"></a>10. 移除旧的样式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//移除原有样式</span><br>style()-&gt;unpolish(ui-&gt;btn);<br><span class="hljs-comment">//必须要有下面这行不然还是不会卸载</span><br>ui-&gt;btn-&gt;setStyleSheet(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//重新设置新的该控件的样式。</span><br>style()-&gt;polish(ui-&gt;btn);<br><br></code></pre></td></tr></table></figure><h3 id="15-可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可"><a href="#15-可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可" class="headerlink" title="15. 可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可"></a>15. 可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>QPushButton *btn = <span class="hljs-keyword">new</span> QPushButton;<br><br>btn-&gt;resize(<span class="hljs-number">30</span>, ui-&gt;lineEdit-&gt;height());<br><br>QHBoxLayout *layout = <span class="hljs-keyword">new</span> QHBoxLayout(ui-&gt;lineEdit);<br><br>layout-&gt;setMargin(<span class="hljs-number">0</span>);<br><br>layout-&gt;addStretch();<br><br>layout-&gt;addWidget(btn);<br><br></code></pre></td></tr></table></figure><h3 id="16-对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果"><a href="#16-对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果" class="headerlink" title="16. 对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果"></a>16. 对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果</h3><h3 id="21-如果出现Z-order-assignment-is-not-a-valid-widget-错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可"><a href="#21-如果出现Z-order-assignment-is-not-a-valid-widget-错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可" class="headerlink" title="21. 如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可"></a>21. 如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到<zorder></zorder>为空的地方，删除即可</h3><h3 id="26-可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置"><a href="#26-可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置" class="headerlink" title="26. 可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置"></a>26. 可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*::down-arrow&#123;&#125;<br>*::menu-indicator&#123;&#125;<br>*::up-arrow:disabled&#123;&#125;<br>*::up-arrow:off&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="27-可以指定位置设置背景图片（本人注：可以调整button中图标的位置）"><a href="#27-可以指定位置设置背景图片（本人注：可以调整button中图标的位置）" class="headerlink" title="27. 可以指定位置设置背景图片（本人注：可以调整button中图标的位置）"></a>27. 可以指定位置设置背景图片（本人注：可以调整button中图标的位置）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QMainWindow &gt; .QWidget &#123;<br>    background-color: gainsboro;<br>    background-image: url(:/images/pagefold.png);<br>    background-position: top right;<br>    background-repeat: no-repeat<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="33-Qt最小化后恢复界面假死冻结，加上代码"><a href="#33-Qt最小化后恢复界面假死冻结，加上代码" class="headerlink" title="33. Qt最小化后恢复界面假死冻结，加上代码"></a>33. Qt最小化后恢复界面假死冻结，加上代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showEvent</span><span class="hljs-params">(QShowEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    setAttribute(Qt::WA_Mapped);<br>    QWidget::showEvent(e);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="34-获取标题栏高度：style-gt-pixelMetric-QStyle-PM-TitleBarHeight-PM-TitleBarHeight点进去你会发现新大陆"><a href="#34-获取标题栏高度：style-gt-pixelMetric-QStyle-PM-TitleBarHeight-PM-TitleBarHeight点进去你会发现新大陆" class="headerlink" title="34. 获取标题栏高度：style()-&gt;pixelMetric(QStyle::PM_TitleBarHeight); PM_TitleBarHeight点进去你会发现新大陆"></a>34. 获取标题栏高度：style()-&gt;pixelMetric(QStyle::PM_TitleBarHeight); PM_TitleBarHeight点进去你会发现新大陆</h3><h3 id="35-设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication-a-argc-argv-的前面"><a href="#35-设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication-a-argc-argv-的前面" class="headerlink" title="35. 设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication a(argc, argv);的前面"></a>35. 设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication a(argc, argv);的前面</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))</span><br>    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="38-qml播放视频在linux需要安装-sudo-apt-get-install-libpulse-dev"><a href="#38-qml播放视频在linux需要安装-sudo-apt-get-install-libpulse-dev" class="headerlink" title="38. qml播放视频在linux需要安装 sudo apt-get install libpulse-dev"></a>38. qml播放视频在linux需要安装 sudo apt-get install libpulse-dev</h3><h3 id="40-Qt5以后提供了类QScroller直接将控件滚动"><a href="#40-Qt5以后提供了类QScroller直接将控件滚动" class="headerlink" title="40. Qt5以后提供了类QScroller直接将控件滚动"></a>40. Qt5以后提供了类QScroller直接将控件滚动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//禁用横向滚动条</span><br>ui-&gt;listWidget-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);<br><span class="hljs-comment">//禁用纵向滚动条</span><br>ui-&gt;listWidget-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);<br><span class="hljs-comment">//设置横向按照像素值为单位滚动</span><br>ui-&gt;listWidget-&gt;setHorizontalScrollMode(QListWidget::ScrollPerPixel);<br><span class="hljs-comment">//设置纵向按照像素值为单位滚动</span><br>ui-&gt;listWidget-&gt;setVerticalScrollMode(QListWidget::ScrollPerPixel);<br><span class="hljs-comment">//设置滚动对象以及滚动方式为鼠标左键拉动滚动</span><br>QScroller::grabGesture(ui-&gt;listWidget, QScroller::LeftMouseButtonGesture);<br><span class="hljs-comment">//还有个QScrollerProperties可以设置滚动的一些参数</span><br></code></pre></td></tr></table></figure><h3 id="50-如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用-setWindowFlags-Qt-CustomizeWindowHint"><a href="#50-如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用-setWindowFlags-Qt-CustomizeWindowHint" class="headerlink" title="50. 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)"></a>50. 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)</h3><h3 id="53-Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一"><a href="#53-Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一" class="headerlink" title="53. Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一"></a>53. Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一</h3><ul><li>方法一：设置属性 this-&gt;setAttribute(Qt::WA_StyledBackground, true);</li><li>方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。</li><li>方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    QStyleOption option;<br>    option.initFrom(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;option, &amp;painter, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="54-有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的"><a href="#54-有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的" class="headerlink" title="54. 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的"></a>54. 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的</h3><h3 id="58-非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理"><a href="#58-非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理" class="headerlink" title="58. 非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理"></a>58. 非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理</h3><h3 id="68-很多控件都带有viewport，比如QTextEdit-QTableWidget-QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport-设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-gt-viewport-gt-setStyleSheet-“background-color-transparent-”-而不是scrollArea-gt-setStyleSheet-“QScrollArea-background-color-transparent-”"><a href="#68-很多控件都带有viewport，比如QTextEdit-QTableWidget-QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport-设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-gt-viewport-gt-setStyleSheet-“background-color-transparent-”-而不是scrollArea-gt-setStyleSheet-“QScrollArea-background-color-transparent-”" class="headerlink" title="68. 很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-&gt;viewport()-&gt;setStyleSheet(“background-color:transparent;”);而不是scrollArea-&gt;setStyleSheet(“QScrollArea{background-color:transparent;}”)"></a>68. 很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-&gt;viewport()-&gt;setStyleSheet(“background-color:transparent;”);而不是scrollArea-&gt;setStyleSheet(“QScrollArea{background-color:transparent;}”)</h3><h3 id="69-有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置-setAttribute-Qt-WA-Hover-true"><a href="#69-有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置-setAttribute-Qt-WA-Hover-true" class="headerlink" title="69. 有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true)"></a>69. 有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true)</h3><h3 id="72-如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息"><a href="#72-如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息" class="headerlink" title="72. 如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息"></a>72. 如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QDialog dialog;<br>dialog.setWindowModality(Qt::WindowModal);<br>dialog.exec();<br></code></pre></td></tr></table></figure><h3 id="74-在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制"><a href="#74-在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制" class="headerlink" title="74. 在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制"></a>74. 在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制</h3><h3 id="75-将-QApplication-style-对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication-style-gt-drawControl-的第4个参数如果不设置，则绘制出来的控件不会应用样式表"><a href="#75-将-QApplication-style-对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication-style-gt-drawControl-的第4个参数如果不设置，则绘制出来的控件不会应用样式表" class="headerlink" title="75. 将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-&gt;drawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表"></a>75. 将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-&gt;drawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表</h3><h3 id="79-对QTableView或者QTableWidget禁用列拖动"><a href="#79-对QTableView或者QTableWidget禁用列拖动" class="headerlink" title="79. 对QTableView或者QTableWidget禁用列拖动"></a>79. 对QTableView或者QTableWidget禁用列拖动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &lt;= QT_VERSION_CHECK(5,0,0))</span><br>    ui-&gt;tableView-&gt;horizontalHeader()-&gt;setResizeMode(<span class="hljs-number">0</span>, QHeaderView::Fixed);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    ui-&gt;tableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(<span class="hljs-number">0</span>, QHeaderView::Fixed);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="90-在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取"><a href="#90-在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取" class="headerlink" title="90. 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取"></a>90. 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取</h3><h3 id="103-Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget"><a href="#103-Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget" class="headerlink" title="103. Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget"></a>103. Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QUIHelper::initTableView</span><span class="hljs-params">(QTableView *tableView, <span class="hljs-keyword">int</span> rowHeight, <span class="hljs-keyword">bool</span> headVisible, <span class="hljs-keyword">bool</span> edit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//奇数偶数行颜色交替</span><br>    tableView-&gt;setAlternatingRowColors(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//垂直表头是否可见</span><br>    tableView-&gt;verticalHeader()-&gt;setVisible(headVisible);<br>    <span class="hljs-comment">//选中一行表头是否加粗</span><br>    tableView-&gt;horizontalHeader()-&gt;setHighlightSections(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//最后一行拉伸填充</span><br>    tableView-&gt;horizontalHeader()-&gt;setStretchLastSection(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//行标题最小宽度尺寸</span><br>    tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//行标题最大高度</span><br>    tableView-&gt;horizontalHeader()-&gt;setMaximumHeight(rowHeight);<br>    <span class="hljs-comment">//默认行高</span><br>    tableView-&gt;verticalHeader()-&gt;setDefaultSectionSize(rowHeight);<br>    <span class="hljs-comment">//选中时一行整体选中</span><br>    tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);<br>    <span class="hljs-comment">//只允许选择单个</span><br>    tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection);<br><br>    <span class="hljs-comment">//表头不可单击</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span><br>    tableView-&gt;horizontalHeader()-&gt;setSectionsClickable(<span class="hljs-literal">false</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    tableView-&gt;horizontalHeader()-&gt;setClickable(<span class="hljs-literal">false</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">//鼠标按下即进入编辑模式</span><br>    <span class="hljs-keyword">if</span> (edit) &#123;<br>        tableView-&gt;setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="106-很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置"><a href="#106-很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置" class="headerlink" title="106. 很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置"></a>106. 很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QDialog dialog;<br>dialog.setWindowModality(Qt::WindowModal);<br></code></pre></td></tr></table></figure><h3 id="108-在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行"><a href="#108-在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行" class="headerlink" title="108. 在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行"></a>108. 在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这种方式设置的无边框窗体在嵌入式设备上无法产生焦点</span><br>setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);<br><br><span class="hljs-comment">//需要在show以后主动激活窗体</span><br>w-&gt;show();<br>w-&gt;activateWindow();<br></code></pre></td></tr></table></figure><h3 id="110-QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所"><a href="#110-QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所" class="headerlink" title="110. QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所"></a>110. QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所</h3><h3 id="119-QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用"><a href="#119-QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用" class="headerlink" title="119. QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用"></a>119. QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用</h3><h3 id="121-QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途"><a href="#121-QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途" class="headerlink" title="121. QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途"></a>121. QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途</h3><ul><li>限制输入只能输入IP地址。</li><li>限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//正在表达式限制输入</span><br>QString str = <span class="hljs-string">&quot;\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&quot;</span>;<br>ui-&gt;lineEdit-&gt;setValidator(<span class="hljs-keyword">new</span> QRegExpValidator(QRegExp(str)));<br><span class="hljs-comment">//用于占位</span><br>ui-&gt;lineEdit-&gt;setInputMask(<span class="hljs-string">&quot;000.000.000.000&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br><span class="hljs-comment">//下面代码设置浮点数范围限制失败</span><br>ui-&gt;lineEdit-&gt;setValidator(<span class="hljs-keyword">new</span> QDoubleValidator(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-comment">//下面代码设置浮点数范围限制成功</span><br>QDoubleValidator *validator = <span class="hljs-keyword">new</span> QDoubleValidator(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>);<br>validator-&gt;setNotation(QDoubleValidator::StandardNotation);<br>ui-&gt;lineEdit-&gt;setValidator(validator);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">//下面代码设置整数范围限制成功</span><br>ui-&gt;lineEdit-&gt;setValidator(<span class="hljs-keyword">new</span> QIntValidator(<span class="hljs-number">10</span>, <span class="hljs-number">120</span>));<br><br><span class="hljs-comment">//其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋</span><br><span class="hljs-comment">//需要来个万能的牛逼的 QRegExpValidator</span><br><br><span class="hljs-comment">//限制浮点数输入范围为[-180,180]</span><br><span class="hljs-function">QRegExp <span class="hljs-title">regexp</span><span class="hljs-params">(<span class="hljs-string">&quot;^-?(180|1?[0-7]?\\d(\\.\\d+)?)$&quot;</span>)</span></span>;<br><span class="hljs-comment">//限制浮点数输入范围为[-90,90]并限定为小数位后4位</span><br><span class="hljs-function">QRegExp <span class="hljs-title">regexp</span><span class="hljs-params">(<span class="hljs-string">&quot;^-?(90|[1-8]?\\d(\\.\\d&#123;1,4&#125;)?)$&quot;</span>)</span></span>;<br>QRegExpValidator *validator = <span class="hljs-keyword">new</span> QRegExpValidator(regexp, <span class="hljs-keyword">this</span>);<br>ui-&gt;lineEdit-&gt;setValidator(validator);<br></code></pre></td></tr></table></figure><h3 id="122-在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5-14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串-rtmp-58-200-131-2-1935-livetv-cctv1，会显示成-rtmp-…-，而在旧版本的Qt中会显示成-rtmp-58-200-131…-，很多时候我们并不想看到烦人的省略号，可以设置取消"><a href="#122-在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5-14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串-rtmp-58-200-131-2-1935-livetv-cctv1，会显示成-rtmp-…-，而在旧版本的Qt中会显示成-rtmp-58-200-131…-，很多时候我们并不想看到烦人的省略号，可以设置取消" class="headerlink" title="122. 在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://…  ，而在旧版本的Qt中会显示成 rtmp://58.200.131… ，很多时候我们并不想看到烦人的省略号，可以设置取消"></a>122. 在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://…  ，而在旧版本的Qt中会显示成 rtmp://58.200.131… ，很多时候我们并不想看到烦人的省略号，可以设置取消</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//取消自动换行</span><br>tableView-&gt;setWordWrap(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//超出文本不显示省略号</span><br>tableView-&gt;setTextElideMode(Qt::ElideNone);<br></code></pre></td></tr></table></figure><h3 id="在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致"><a href="#在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致" class="headerlink" title="在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致"></a>在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致</h3><h3 id="138-对高分屏不同缩放比例的自适应处理方法"><a href="#138-对高分屏不同缩放比例的自适应处理方法" class="headerlink" title="138. 对高分屏不同缩放比例的自适应处理方法"></a>138. 对高分屏不同缩放比例的自适应处理方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1：在main函数的最前面加上下面这句 5.6版本才开始有这个函数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))</span><br>    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);<br>    <span class="hljs-comment">//开启高缩放支持以后图片可能发虚还要开启下面这个属性</span><br>    QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//方法2：在可执行文件同目录下新建文件 qt.conf 填入下面内容</span><br>[Platforms]<br>WindowsArguments = dpiawareness=<span class="hljs-number">0</span><br><span class="hljs-comment">//下面这行用来解决Qt高DPI下文字显示有锯齿的问题</span><br>WindowsArguments = fontengine=freetype<br><br><span class="hljs-comment">//方法3：在main函数最前面设置Qt内部的环境变量</span><br>qputenv(<span class="hljs-string">&quot;QT_AUTO_SCREEN_SCALE_FACTOR&quot;</span>, <span class="hljs-string">&quot;1.5&quot;</span>);<br><br><span class="hljs-comment">//方法4：新版本的Qt比如Qt5.14修正了对高分屏的处理支持不是整数的缩放</span><br>qputenv(<span class="hljs-string">&quot;QT_ENABLE_HIGHDPI_SCALING&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);<br><br><span class="hljs-comment">//禁用缩放</span><br><span class="hljs-comment">//测试发现AA_Use96Dpi属性在Qt5.9以上版本完全正常，以下版本比如5.7有部分控件在175%缩放不正常比如QTextEdit，需要外层套个widget才行。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    QApplication::setAttribute(Qt::AA_Use96Dpi);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,14,0))</span><br>    QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="139-QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮"><a href="#139-QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮" class="headerlink" title="139. QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮"></a>139. QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对tabWidget设置无切换按钮</span><br>ui-&gt;tabWidget-&gt;setUsesScrollButtons(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//对tabBar设置无切换按钮</span><br>ui-&gt;tabWidget-&gt;tabBar()-&gt;setUsesScrollButtons(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//对整个系统的选项卡设置无切换按钮</span><br>QTabBar&#123;qproperty-usesScrollButtons:<span class="hljs-literal">false</span>;&#125;<br><span class="hljs-comment">//设置选项卡自动拉伸 这玩意居然之前自动计算来设置原来内置了哇咔咔</span><br>QTabBar&#123;qproperty-expanding:<span class="hljs-literal">false</span>;&#125;<br><span class="hljs-comment">//设置选项卡关闭按钮可见</span><br>QTabBar&#123;qproperty-tabsClosable:<span class="hljs-literal">true</span>;&#125;<br><span class="hljs-comment">//还有其他属性参见QTabBar头文件有惊喜</span><br><span class="hljs-comment">//依旧是万能大法所有可视化类的 Q_PROPERTY 包含的属性都可以这样设置</span><br></code></pre></td></tr></table></figure><h3 id="140-QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容"><a href="#140-QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容" class="headerlink" title="140. QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容"></a>140. QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//真的是做梦也没想到要这样设置</span><br>QMainWindow::separator&#123;width:<span class="hljs-number">1</span>px;height:<span class="hljs-number">1</span>px;margin:<span class="hljs-number">1</span>px;padding:<span class="hljs-number">1</span>px;background:#FF0000;&#125;<br></code></pre></td></tr></table></figure><h3 id="142-在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文"><a href="#142-在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文" class="headerlink" title="142. 在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文"></a>142. 在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//需要设置共享上下文不然停靠窗体从正常到浮动后QOpenGLWidget窗体会失效</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span><br>    QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="143-关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99-以上的Qt版本的乱码问题"><a href="#143-关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99-以上的Qt版本的乱码问题" class="headerlink" title="143. 关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题"></a>143. 关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题</h3><ul><li>第一步：代码文件选择用utf8编码带bom。</li><li>第二步：在有中文汉字的代码文件顶部加一行（一般是cpp文件） #pragma execution_character_set(“utf-8”) 可以考虑放在head.h中，然后需要的地方就引入head头文件就行，而不是这行代码写的到处都是；这行代码是为了告诉msvc编译器当前代码文件用utf8去编译。</li><li>第三步：main函数中加入设置编码的代码，以便兼容Qt4，如果没有Qt4的场景可以不用，从Qt5开始默认就是utf8编码。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QUIHelper::setCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &lt;= QT_VERSION_CHECK(5,0,0))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER</span><br>    QTextCodec *codec = QTextCodec::codecForName(<span class="hljs-string">&quot;gbk&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    QTextCodec *codec = QTextCodec::codecForName(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    QTextCodec::setCodecForLocale(codec);<br>    QTextCodec::setCodecForCStrings(codec);<br>    QTextCodec::setCodecForTr(codec);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    QTextCodec *codec = QTextCodec::codecForName(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>    QTextCodec::setCodecForLocale(codec);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="145-通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4-7到5-15任意版本，通过查看对应函数的源码可以看到内部会检查是否是-‘file-‘-开头，是的话则自动读取样式表文件进行设置，无需手动读取"><a href="#145-通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4-7到5-15任意版本，通过查看对应函数的源码可以看到内部会检查是否是-‘file-‘-开头，是的话则自动读取样式表文件进行设置，无需手动读取" class="headerlink" title="145. 通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 ‘file:///‘ 开头，是的话则自动读取样式表文件进行设置，无需手动读取"></a>145. 通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 ‘file:///‘ 开头，是的话则自动读取样式表文件进行设置，无需手动读取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以前都是下面的方法</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;:/qss/psblack.css&quot;</span>)</span></span>;<br><span class="hljs-keyword">if</span> (file.open(QFile::ReadOnly)) &#123;<br>    QString qss = QLatin1String(file.readAll());<br>    qApp-&gt;setStyleSheet(qss);<br>    file.close();<br>&#125;<br><br><span class="hljs-comment">//其实一行代码就行</span><br>qApp-&gt;setStyleSheet(<span class="hljs-string">&quot;file:///:/qss/psblack.css&quot;</span>);<br><span class="hljs-comment">//特别说明，只支持qApp-&gt;setStyleSheet 不支持其他比如widget-&gt;setStyleSheet</span><br></code></pre></td></tr></table></figure><h3 id="146-Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板-QCalendarWidget-就是-QToolButton-QSpinBox-QTableView-等组成，妙用-findChildren-可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等"><a href="#146-Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板-QCalendarWidget-就是-QToolButton-QSpinBox-QTableView-等组成，妙用-findChildren-可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等" class="headerlink" title="146. Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等"></a>146. Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//打印子类类名集合</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printObjectChild</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QObject *obj, <span class="hljs-keyword">int</span> spaceCount)</span></span><br><span class="hljs-function"></span>&#123;<br>    qDebug() &lt;&lt; QString(<span class="hljs-string">&quot;%1%2 : %3&quot;</span>)<br>             .arg(<span class="hljs-string">&quot;&quot;</span>, spaceCount)<br>             .arg(obj-&gt;metaObject()-&gt;className())<br>             .arg(obj-&gt;objectName());<br><br>    QObjectList childs = obj-&gt;children();<br>    foreach (QObject *child, childs) &#123;<br>        printObjectChild(child, spaceCount + <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//拿到对话框进行设置和美化</span><br>QFileDialog *fileDialog = <span class="hljs-keyword">new</span> QFileDialog(<span class="hljs-keyword">this</span>);<br>fileDialog-&gt;setOption(QFileDialog::DontUseNativeDialog, <span class="hljs-literal">true</span>);<br>QLabel *lookinLabel = fileDialog-&gt;findChild&lt;QLabel*&gt;(<span class="hljs-string">&quot;lookInLabel&quot;</span>);<br>lookinLabel-&gt;setText(QString::fromLocal8Bit(<span class="hljs-string">&quot;文件目录：&quot;</span>));<br>lookinLabel-&gt;setStyleSheet(<span class="hljs-string">&quot;color:red;&quot;</span>);<br><br><span class="hljs-comment">//设置日期框默认值为空</span><br>QLineEdit *edit = ui-&gt;dateEdit-&gt;findChild&lt;QLineEdit *&gt;(<span class="hljs-string">&quot;qt_spinbox_lineedit&quot;</span>);<br><span class="hljs-keyword">if</span> (!edit-&gt;text().isEmpty()) &#123;<br>    edit-&gt;clear();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="147-Qt内置了各种对话框，比如文件对话框-QFileDialog-，颜色对话框-QColorDialog-，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理"><a href="#147-Qt内置了各种对话框，比如文件对话框-QFileDialog-，颜色对话框-QColorDialog-，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理" class="headerlink" title="147. Qt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理"></a>147. Qt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QFileDialog *fileDialog = <span class="hljs-keyword">new</span> QFileDialog(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//不设置此属性根本查找不到任何子元素,因为默认采用的系统对话框</span><br>fileDialog-&gt;setOption(QFileDialog::DontUseNativeDialog, <span class="hljs-literal">true</span>);<br>qDebug() &lt;&lt; fileDialog-&gt;findChildren&lt;QLabel *&gt;();<br><span class="hljs-comment">//打印输出 QLabel(0x17e2ff68, name=&quot;lookInLabel&quot;), QLabel(0x17e35f88, name=&quot;fileNameLabel&quot;), QLabel(0x17e35e68, name=&quot;fileTypeLabel&quot;)</span><br></code></pre></td></tr></table></figure><h3 id="150-Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件"><a href="#150-Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件" class="headerlink" title="150. Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件"></a>150. Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件</h3><ul><li>斗气：qss内容写得到处都是，哪里需要就写在哪里，各种控件调用 setStyleSheet方法传入样式表内容，或者直接对应控件鼠标右键弹出菜单选择改变样式表填入内容；</li><li>斗者：qss内容放在文件，读取文件内容设置样式表，程序发布的时候带上qss文件；</li><li>斗师：qss文件作为资源文件放到qrc文件，直接编译到可执行文件中，防止篡改；</li><li>斗灵：在qss文件中自定义一些标志充当变量使用，读取以后替换对应的变量为颜色值，类似动态换肤；</li><li>斗王：放在文件容易被篡改，集成到可执行文件不够灵活，一旦样式表更新需要重新编译文件，如何做到既能只更新样式表文件，又不需要重新编译可执行文件，又能防止被篡改：采用rcc命令将资源文件编译生成二进制，只需要替换该二进制文件即可；</li><li>斗皇：继承qstyle类自己实现完成所有样式接口，统一整体风格，大名鼎鼎的UOS系统默认规则就是如此，不允许用样式表，全部painter绘制；</li></ul><h3 id="151-当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载"><a href="#151-当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载" class="headerlink" title="151. 当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载"></a>151. 当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Qt中使用二进制资源文件方法如下</span><br><span class="hljs-comment">//将qrc编译为二进制文件rcc，在控制台执行下列命令 </span><br>rcc -binary main.qrc -o main.rcc<br><span class="hljs-comment">//在应用程序中注册资源，一般在main函数启动后就注册</span><br>QResource::registerResource(qApp-&gt;applicationDirPath() + <span class="hljs-string">&quot;/main.rcc&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="152-关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有"><a href="#152-关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有" class="headerlink" title="152. 关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有"></a>152. 关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget</span><br><br><span class="hljs-comment">//下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFont</span><br>QFont font;<br>font.setPixelSize(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">this</span>-&gt;setFont(font);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;&#123;font:26px;&#125;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;QWidget&#123;font:26px;&#125;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;Widget&#123;font:26px;&#125;&quot;</span>);<br><br><span class="hljs-comment">//下面才是通过样式表设置整个控件+子控件的字体</span><br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;font:26px;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;*&#123;font:26px;&#125;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;QWidget&gt;*&#123;font:26px;&#125;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;Widget&gt;*&#123;font:26px;&#125;&quot;</span>);<br><br><span class="hljs-comment">//下面设置全局字体</span><br>qApp-&gt;setFont(font);<br></code></pre></td></tr></table></figure><h3 id="156-Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下"><a href="#156-Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下" class="headerlink" title="156. Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下"></a>156. Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmMain::on_btnMenu_Max_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ......<br><br>    <span class="hljs-comment">//最大化以后有个BUG,悬停样式没有取消掉,需要主动模拟鼠标动一下    </span><br>    <span class="hljs-function">QEvent <span class="hljs-title">event</span><span class="hljs-params">(QEvent::Leave)</span></span>;<br>    QApplication::sendEvent(ui-&gt;btnMenu_Max, &amp;event);    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="158-Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多"><a href="#158-Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多" class="headerlink" title="158. Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多"></a>158. Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ui-&gt;textEdit-&gt;setUndoRedoEnabled(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="160-QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充"><a href="#160-QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充" class="headerlink" title="160. QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充"></a>160. QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1：字符串空格填充</span><br>ui-&gt;tabWidget-&gt;addTab(httpClient1, <span class="hljs-string">&quot;测    试&quot;</span>);<br>ui-&gt;tabWidget-&gt;addTab(httpClient1, <span class="hljs-string">&quot;人员管理&quot;</span>);<br>ui-&gt;tabWidget-&gt;addTab(httpClient1, <span class="hljs-string">&quot;系统设置&quot;</span>);<br><br><span class="hljs-comment">//方法2：识别尺寸改变事件自动设置最小宽度</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::resizeEvent</span><span class="hljs-params">(QResizeEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> count = ui-&gt;tabWidget-&gt;tabBar()-&gt;count();<br>    <span class="hljs-keyword">int</span> width = <span class="hljs-keyword">this</span>-&gt;width() - <span class="hljs-number">30</span>;<br>    QString qss = QString(<span class="hljs-string">&quot;QTabBar::tab&#123;min-width:%1px;&#125;&quot;</span>).arg(width / count);<br>    <span class="hljs-keyword">this</span>-&gt;setStyleSheet(qss);<br>&#125;<br><br><span class="hljs-comment">//方法3：设置全局样式，不同选项卡个数的设置不同的宽度</span><br>QStringList <span class="hljs-built_in">list</span>;<br><span class="hljs-built_in">list</span> &lt;&lt; QString(&quot;QTabWidget[tabCount=\&quot;2\&quot;]&gt;QTabBar::tab&#123;min-width:%<span class="hljs-number">1</span>px;&#125;<span class="hljs-string">&quot;).arg(100);</span><br><span class="hljs-string">list &lt;&lt; QString(&quot;</span>QTabWidget[tabCount=\<span class="hljs-string">&quot;3\&quot;]&gt;QTabBar::tab&#123;min-width:%1px;&#125;&quot;</span>).arg(<span class="hljs-number">70</span>);<br>qApp-&gt;setStyleSheet(<span class="hljs-built_in">list</span>.join(<span class="hljs-string">&quot;&quot;</span>));<br><span class="hljs-comment">//设置了tabCount弱属性自动去找对应的宽度设置</span><br>ui-&gt;tabWidget-&gt;setProperty(<span class="hljs-string">&quot;tabCount&quot;</span>, <span class="hljs-number">2</span>);<br>ui-&gt;tabWidget-&gt;setProperty(<span class="hljs-string">&quot;tabCount&quot;</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//方法4：强烈推荐-》使用内置的方法 setExpanding setDocumentMode 两个属性都必须设置</span><br><span class="hljs-comment">//Qt4的tabBar()是propected的，所以建议还是通过样式表设置</span><br>ui-&gt;tabWidget-&gt;tabBar()-&gt;setDocumentMode(<span class="hljs-literal">true</span>);<br>ui-&gt;tabWidget-&gt;tabBar()-&gt;setExpanding(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//样式表一步到位不用每个都单独设置</span><br>QString(<span class="hljs-string">&quot;QTabBar&#123;qproperty-usesScrollButtons:false;qproperty-documentMode:true;qproperty-expanding:true;&#125;&quot;</span>);<br><span class="hljs-comment">//在5.9以前开启这个设置后，貌似选项卡个数按照真实个数+1计算宽度，也就是永远会留空一个tab的占位。</span><br><span class="hljs-comment">//5.9以后貌似修复了这个BUG，按照理想中的拉伸填充等分设置tab的宽度。</span><br></code></pre></td></tr></table></figure><h3 id="163-如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸"><a href="#163-如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸" class="headerlink" title="163. 如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸"></a>163. 如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">setMinimumSize(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);<br></code></pre></td></tr></table></figure><h3 id="166-有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用-blockSignals-方法"><a href="#166-有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用-blockSignals-方法" class="headerlink" title="166. 有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法"></a>166. 有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。</span><br>disconnect(ui-&gt;cbox, SIGNAL(currentIndexChanged(<span class="hljs-keyword">int</span>)), <span class="hljs-keyword">this</span>, SLOT(on_cbox_currentIndexChanged(<span class="hljs-keyword">int</span>)));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>    ui-&gt;cbox-&gt;addItem(QString::number(i));<br>&#125;<br>connect(ui-&gt;cbox, SIGNAL(currentIndexChanged(<span class="hljs-keyword">int</span>)), <span class="hljs-keyword">this</span>, SLOT(on_cbox_currentIndexChanged(<span class="hljs-keyword">int</span>)));<br><br><span class="hljs-comment">//方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。</span><br><span class="hljs-comment">//如果需要指定某个信号进行断开那就只能用 disconnect 来处理。</span><br>ui-&gt;cbox-&gt;blockSignals(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>    ui-&gt;cbox-&gt;addItem(QString::number(i));<br>&#125;<br>ui-&gt;cbox-&gt;blockSignals(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="177-很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用"><a href="#177-很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用" class="headerlink" title="177. 很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用"></a>177. 很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::showEvent</span><span class="hljs-params">(QShowEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> isLoad = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!isLoad) &#123;<br>        isLoad = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//执行对应的处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="189-对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行"><a href="#189-对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行" class="headerlink" title="189. 对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行"></a>189. 对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QCheckBox::indicator,QGroupBox::indicator,QTreeWidget::indicator,QListWidget::indicator&#123;<br>width:<span class="hljs-number">13</span>px;<br>height:<span class="hljs-number">13</span>px;<br>&#125;<br><br>QCheckBox::indicator:unchecked,QGroupBox::indicator:unchecked,QTreeWidget::indicator:unchecked,QListWidget::indicator:unchecked&#123;<br>image:url(:/qss/flatwhite/checkbox_unchecked.png);<br>&#125;<br><br>QCheckBox::indicator:unchecked:disabled,QGroupBox::indicator:unchecked:disabled,QTreeWidget::indicator:unchecked:disabled,QListWidget::indicator:disabled&#123;<br>image:url(:/qss/flatwhite/checkbox_unchecked_disable.png);<br>&#125;<br><br>QCheckBox::indicator:checked,QGroupBox::indicator:checked,QTreeWidget::indicator:checked,QListWidget::indicator:checked&#123;<br>image:url(:/qss/flatwhite/checkbox_checked.png);<br>&#125;<br><br>QCheckBox::indicator:checked:disabled,QGroupBox::indicator:checked:disabled,QTreeWidget::indicator:checked:disabled,QListWidget::indicator:checked:disabled&#123;<br>image:url(:/qss/flatwhite/checkbox_checked_disable.png);<br>&#125;<br><br>QCheckBox::indicator:indeterminate,QGroupBox::indicator:indeterminate,QTreeWidget::indicator:indeterminate,QListWidget::indicator:indeterminate&#123;<br>image:url(:/qss/flatwhite/checkbox_parcial.png);<br>&#125;<br><br>QCheckBox::indicator:indeterminate:disabled,QGroupBox::indicator:indeterminate:disabled,QTreeWidget::indicator:indeterminate:disabled,QListWidget::indicator:indeterminate:disabled&#123;<br>image:url(:/qss/flatwhite/checkbox_parcial_disable.png);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="190-关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列"><a href="#190-关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列" class="headerlink" title="190. 关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列"></a>190. 关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmSimple::initForm</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//实例化数据模型</span><br>    model = <span class="hljs-keyword">new</span> QStandardItemModel(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">//设置行数列数</span><br>    row = <span class="hljs-number">100</span>;<br>    column = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//设置列名列宽</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; column; ++i) &#123;<br>        columnNames &lt;&lt; QString(<span class="hljs-string">&quot;列%1&quot;</span>).arg(i + <span class="hljs-number">1</span>);<br>        columnWidths &lt;&lt; <span class="hljs-number">60</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmSimple::on_btnLoad1_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//先设置数据模型,否则 setColumnWidth 不起作用</span><br>    ui-&gt;tableView-&gt;setModel(model);<br><br>    <span class="hljs-comment">//设置列数及列标题和列宽</span><br>    model-&gt;setColumnCount(column);<br>    <span class="hljs-comment">//简便方法设置列标题集合</span><br>    model-&gt;setHorizontalHeaderLabels(columnNames);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; column; ++i) &#123;<br>        ui-&gt;tableView-&gt;setColumnWidth(i, columnWidths.at(i));<br>    &#125;<br><br>    <span class="hljs-comment">//循环添加行数据</span><br>    QDateTime now = QDateTime::currentDateTime();<br>    model-&gt;setRowCount(row);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; ++j) &#123;<br>            QStandardItem *item = <span class="hljs-keyword">new</span> QStandardItem;<br>            <span class="hljs-comment">//最后一列显示时间区别开来</span><br>            <span class="hljs-keyword">if</span> (j == column - <span class="hljs-number">1</span>) &#123;<br>                item-&gt;setText(now.addSecs(i).toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                item-&gt;setText(QString(<span class="hljs-string">&quot;%1_%2&quot;</span>).arg(i + <span class="hljs-number">1</span>).arg(j + <span class="hljs-number">1</span>));<br>            &#125;<br>            model-&gt;setItem(i, j, item);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmSimple::on_btnLoad2_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置列标题和列数及列宽</span><br>    ui-&gt;tableWidget-&gt;setColumnCount(column);<br>    <span class="hljs-comment">//简便方法设置列标题集合</span><br>    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(columnNames);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; column; ++i) &#123;<br>        ui-&gt;tableWidget-&gt;setColumnWidth(i, columnWidths.at(i));<br>    &#125;<br><br>    <span class="hljs-comment">//添加数据</span><br>    QDateTime now = QDateTime::currentDateTime();<br>    ui-&gt;tableWidget-&gt;setRowCount(row);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; ++j) &#123;<br>            QTableWidgetItem *item = <span class="hljs-keyword">new</span> QTableWidgetItem;<br>            <span class="hljs-comment">//最后一列显示时间区别开来</span><br>            <span class="hljs-keyword">if</span> (j == column - <span class="hljs-number">1</span>) &#123;<br>                item-&gt;setText(now.addSecs(i).toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                item-&gt;setText(QString(<span class="hljs-string">&quot;%1_%2&quot;</span>).arg(i + <span class="hljs-number">1</span>).arg(j + <span class="hljs-number">1</span>));<br>            &#125;<br>            ui-&gt;tableWidget-&gt;setItem(i, j, item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="193-Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值"><a href="#193-Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值" class="headerlink" title="193. Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值"></a>193. Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值</h3><h3 id="194-Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5-6开始提供了-AA-EnableHighDpiScaling-的属性设置开启高分屏，到了5-14以后还可以指定缩放的策略-HighDpiScaleFactorRoundingPolicy-比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了-AA-EnableHighDpiScaling-属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放"><a href="#194-Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5-6开始提供了-AA-EnableHighDpiScaling-的属性设置开启高分屏，到了5-14以后还可以指定缩放的策略-HighDpiScaleFactorRoundingPolicy-比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了-AA-EnableHighDpiScaling-属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放" class="headerlink" title="194. Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放"></a>194. Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//永远不应用高分屏及缩放</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    QApplication::setAttribute(Qt::AA_Use96Dpi);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,14,0))</span><br>    QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    ....<br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br><br><span class="hljs-comment">//自动应用高分屏及缩放</span><br><span class="hljs-comment">//方法很多，综合对比下来还是采用配置文件指定缩放策略最适中。</span><br><span class="hljs-comment">//新建qt.conf文件放到可执行文件同一目录</span><br>[Platforms]<br>WindowsArguments = dpiawareness=<span class="hljs-number">0</span><br><br><span class="hljs-comment">//有时候想让用户去选择何种策略，需要开启高分屏的之后只需要将qt.conf文件放到可执行文件同一目录即可，就算代码中设置了不应用高分屏及缩放，也无效，也是优先取qt.conf文件的策略。</span><br></code></pre></td></tr></table></figure><h3 id="195-关于QSS要注意的坑"><a href="#195-关于QSS要注意的坑" class="headerlink" title="195. 关于QSS要注意的坑"></a>195. 关于QSS要注意的坑</h3><ul><li>qss源自css，相当于css的一个子集，主要支持的是css2标准，很多网上的css3的标准的写法在qss这里是不生效的，所以不要大惊小怪。</li><li>qss也不是完全支持所有的css2，比如text-align官方文档就有说明，只支持 QPushButton and QProgressBar，务必看清楚。</li><li>有时候偷懒直接来一句 *{xxx}，你会发现大部分是应用了，也有小部分或者极个别没有应用，你可能需要在对应的窗体中 this-&gt;setStyleSheet() 来设置。</li><li>qss的执行是有优先级的，如果没有指定父对象，则对所有的应用，比如在窗体widget中 {color:#ff0000;} 这样会对widget以及widget的所有子对象应用该样式，这种问题各大Qt群每周都在上演，你会发现各种奇奇怪怪的异样不正常，怎么办呢，你需要指定类名或者对象名，比如 #widget{color:#ff0000;} 这样就只会对widget对象应用该样式，另一种写法 QWidget#widget{color:#ff0000;}，只想对窗体本身而不是子控件按钮标签等 .QWidget{color:#ff0000;} ，具体详细规则参见官方说明。</li><li>qss整体来说还是可以的，尽管有着有那的BUG，怀着包容的心对待它。</li></ul><h2 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h2><h3 id="65-在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致"><a href="#65-在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致" class="headerlink" title="65. 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致"></a>65. 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QRect <span class="hljs-title">rect</span><span class="hljs-params">(-radius, -radius, radius * <span class="hljs-number">2</span>, radius * <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-comment">//以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形</span><br>painter-&gt;drawArc(rect, <span class="hljs-number">0</span>, <span class="hljs-number">360</span> * <span class="hljs-number">16</span>);<br>painter-&gt;drawEllipse(rect);<br></code></pre></td></tr></table></figure><h3 id="78-很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色"><a href="#78-很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色" class="headerlink" title="78. 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色"></a>78. 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//根据背景色自动计算合适的前景色</span><br><span class="hljs-keyword">double</span> gray = (<span class="hljs-number">0.299</span> * color.red() + <span class="hljs-number">0.587</span> * color.green() + <span class="hljs-number">0.114</span> * color.blue()) / <span class="hljs-number">255</span>;<br>QColor textColor = gray &gt; <span class="hljs-number">0.5</span> ? Qt::black : Qt::white;<br></code></pre></td></tr></table></figure><h3 id="100-setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU"><a href="#100-setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU" class="headerlink" title="100. setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU"></a>100. setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU</h3><h3 id="101-如果需要在尺寸改变的时候不重绘窗体，则设置属性即可-this-gt-setAttribute-Qt-WA-StaticContents-true-这样可以避免可以避免对已经显示区域的重新绘制"><a href="#101-如果需要在尺寸改变的时候不重绘窗体，则设置属性即可-this-gt-setAttribute-Qt-WA-StaticContents-true-这样可以避免可以避免对已经显示区域的重新绘制" class="headerlink" title="101. 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-&gt;setAttribute(Qt::WA_StaticContents, true); 这样可以避免可以避免对已经显示区域的重新绘制"></a>101. 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-&gt;setAttribute(Qt::WA_StaticContents, true); 这样可以避免可以避免对已经显示区域的重新绘制</h3><h3 id="153-Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format-ARGB32或者Format-RGBA8888"><a href="#153-Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format-ARGB32或者Format-RGBA8888" class="headerlink" title="153. Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888"></a>153. Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//pixel      函数获取像素点的颜色 setPixel      函数设置像素点的颜色 此函数任意Qt版本都有</span><br><span class="hljs-comment">//pixelColor 函数获取像素点的颜色 setPixelColor 函数设置像素点的颜色 此函数Qt5.6以后才有</span><br><span class="hljs-comment">//pixel函数取出来的是QRgb格式需要用 qRed qGreen qBlue qAlpha 进行转换</span><br><span class="hljs-function">QImage <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-string">&quot;1.png&quot;</span>)</span></span>;<br>image = image.convertToFormat(QImage::Format_ARGB32);<br><span class="hljs-keyword">int</span> width = image.width();<br><span class="hljs-keyword">int</span> height = image.height();<br><span class="hljs-comment">//遍历图像的每一个像素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; width; ++x) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; height; ++y) &#123;<br>        QString name = image.pixelColor(x, y).name();<br>        <span class="hljs-comment">//将白色以外的颜色全部替换成红色</span><br>        <span class="hljs-keyword">if</span> (name != <span class="hljs-string">&quot;#ffffff&quot;</span>) &#123;<br>            image.setPixelColor(x, y, Qt::red);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//保存文件</span><br>image.save(<span class="hljs-string">&quot;2.png&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="161-经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条"><a href="#161-经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条" class="headerlink" title="161. 经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条"></a>161. 经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条</h3><h2 id="QtCore"><a href="#QtCore" class="headerlink" title="QtCore"></a>QtCore</h2><h3 id="46-巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行"><a href="#46-巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行" class="headerlink" title="46. 巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行"></a>46. 巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QEventLoop loop;<br>connect(reply, SIGNAL(finished()), &amp;loop, SLOT(quit()));<br>loop.exec();<br></code></pre></td></tr></table></figure><h3 id="70-Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等"><a href="#70-Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等" class="headerlink" title="70. Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等"></a>70. Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QDateTime dateTime;<br>QString dateTime_str = dateTime.currentDateTime().toString(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br><span class="hljs-comment">//从字符串转换为毫秒（需完整的年月日时分秒）</span><br>datetime.fromString(<span class="hljs-string">&quot;2011-09-10 12:07:50:541&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>).toMSecsSinceEpoch();<br><span class="hljs-comment">//从字符串转换为秒（需完整的年月日时分秒）</span><br>datetime.fromString(<span class="hljs-string">&quot;2011-09-10 12:07:50:541&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>).toTime_t();<br><span class="hljs-comment">//从毫秒转换到年月日时分秒</span><br>datetime.fromMSecsSinceEpoch(<span class="hljs-number">1315193829218</span>).toString(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>);<br><span class="hljs-comment">//从秒转换到年月日时分秒（若有zzz，则为000）</span><br>datetime.fromTime_t(<span class="hljs-number">1315193829</span>).toString(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss[:zzz]&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="71-在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用-at-取值而不是-操作符，在官方书籍《C-GUI-Qt-4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用-at-与使用-操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用-at-函数而不用-操作符，因为Qt的容器类不能辨别-操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而-at-函数则不被允许出现在一个赋值的左边"><a href="#71-在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用-at-取值而不是-操作符，在官方书籍《C-GUI-Qt-4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用-at-与使用-操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用-at-函数而不用-操作符，因为Qt的容器类不能辨别-操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而-at-函数则不被允许出现在一个赋值的左边" class="headerlink" title="71. 在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边"></a>71. 在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边</h3><h3 id="73-安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如-qDeleteAll-btns"><a href="#73-安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如-qDeleteAll-btns" class="headerlink" title="73. 安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns)"></a>73. 安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns)</h3><p>主要是记录后半句</p><h3 id="82-QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法"><a href="#82-QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法" class="headerlink" title="82. QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法"></a>82. QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (variant.typeName() == <span class="hljs-string">&quot;QColor&quot;</span>) &#123;<br>    QColor color = variant.value&lt;QColor&gt;();<br>    QFont font = variant.value&lt;QFont&gt;();<br>    QString nodeValue = color.name(QColor::HexArgb);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="83-Qt中的QString和const-char-之间转换，最好用toStdString-c-str-而不是toLocal8Bit-constData-，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常"><a href="#83-Qt中的QString和const-char-之间转换，最好用toStdString-c-str-而不是toLocal8Bit-constData-，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常" class="headerlink" title="83. Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常"></a>83. Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常</h3><h3 id="85-QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets-qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突"><a href="#85-QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets-qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突" class="headerlink" title="85. QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突"></a>85. QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突</h3><h3 id="87-在Qt5-10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-gt-tableView-gt-horizontalHeader-gt-setMinimumSectionSize-0"><a href="#87-在Qt5-10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-gt-tableView-gt-horizontalHeader-gt-setMinimumSectionSize-0" class="headerlink" title="87. 在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-&gt;tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0)"></a>87. 在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-&gt;tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0)</h3><h3 id="95-QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值"><a href="#95-QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值" class="headerlink" title="95. QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值"></a>95. QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QStyle::sliderValueFromPosition(minimum(), maximum(), event-&gt;x(), width());<br></code></pre></td></tr></table></figure><h3 id="97-用QFile-readAll-读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果"><a href="#97-用QFile-readAll-读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果" class="headerlink" title="97. 用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果"></a>97. 用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmMain::initStyle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//加载样式表</span><br>    QString qss;<br>    <span class="hljs-comment">//QFile file(&quot;:/qss/psblack.css&quot;);</span><br>    <span class="hljs-comment">//QFile file(&quot;:/qss/flatwhite.css&quot;);</span><br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;:/qss/lightblue.css&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (file.open(QFile::ReadOnly)) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 1</span><br>        <span class="hljs-comment">//用QTextStream读取样式文件不用区分文件编码 带bom也行</span><br>        QStringList <span class="hljs-built_in">list</span>;<br>        <span class="hljs-function">QTextStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br>        <span class="hljs-comment">//in.setCodec(&quot;utf-8&quot;);</span><br>        <span class="hljs-keyword">while</span> (!in.atEnd()) &#123;<br>            QString line;<br>            in &gt;&gt; line;<br>            <span class="hljs-built_in">list</span> &lt;&lt; line;<br>        &#125;<br><br>        qss = <span class="hljs-built_in">list</span>.join(&quot;\n&quot;);<br>#<span class="hljs-keyword">else</span><br>        //用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开<br>        qss = QLatin1String(file.readAll());<br>#endif<br>        QString paletteColor = qss.mid(20, 7);<br>        qApp-&gt;setPalette(QPalette(QColor(paletteColor)));<br>        qApp-&gt;setStyleSheet(qss);<br>        file.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="98-QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用-qSetRealNumberPrecision-函数设置精确度位数即可"><a href="#98-QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用-qSetRealNumberPrecision-函数设置精确度位数即可" class="headerlink" title="98. QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可"></a>98. QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString s1, s2;<br>s1 = <span class="hljs-string">&quot;666.5567124&quot;</span>;<br>s2.setNum(<span class="hljs-number">888.5632123</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">7</span>);<br>qDebug() &lt;&lt; qSetRealNumberPrecision(<span class="hljs-number">10</span>) &lt;&lt; s1.toDouble() &lt;&lt; s2.toDouble();<br></code></pre></td></tr></table></figure><h3 id="118-Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置-setTimerType-Qt-PreciseTimer-。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用-startTimer-interval-Qt-PreciseTimer"><a href="#118-Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置-setTimerType-Qt-PreciseTimer-。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用-startTimer-interval-Qt-PreciseTimer" class="headerlink" title="118. Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer)"></a>118. Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer)</h3><ul><li>Qt::PreciseTimer 精确的定时器，尽量保持毫秒精度。</li><li>Qt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。</li><li>Qt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。</li><li>精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。</li></ul><h3 id="155-Qt5-10以后提供了新的类-QRandomGenerator-QRandomGenerator64-管理随机数，使用更方便，尤其是取某个区间的随机数"><a href="#155-Qt5-10以后提供了新的类-QRandomGenerator-QRandomGenerator64-管理随机数，使用更方便，尤其是取某个区间的随机数" class="headerlink" title="155. Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数"></a>155. Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//早期处理办法 先初始化随机数种子然后取随机数</span><br>qsrand(QTime::currentTime().msec());<br><span class="hljs-comment">//取 0-10 之间的随机数</span><br>qrand() % <span class="hljs-number">10</span>;<br><span class="hljs-comment">//取 0-1 之间的浮点数</span><br>qrand() / <span class="hljs-keyword">double</span>(RAND_MAX);<br><br><span class="hljs-comment">//新版处理办法 支持5.10以后的所有版本包括qt6</span><br>QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">10</span>);      <span class="hljs-comment">//生成一个0和10之间的整数</span><br>QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">10.123</span>);  <span class="hljs-comment">//生成一个0和10.123之间的浮点数</span><br>QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">//生成一个10和15之间的整数</span><br><br><span class="hljs-comment">//兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数</span><br>srand(QTime::currentTime().msec());<br>rand() % <span class="hljs-number">10</span>;<br>rand() / <span class="hljs-keyword">double</span>(RAND_MAX);<br><br><span class="hljs-comment">//通用公式 a是起始值,n是整数的范围</span><br><span class="hljs-keyword">int</span> value = a + rand() % n;<br><span class="hljs-comment">//(min, max)的随机数</span><br><span class="hljs-keyword">int</span> value = min + <span class="hljs-number">1</span> + (rand() % (max - min - <span class="hljs-number">1</span>));<br><span class="hljs-comment">//(min, max]的随机数</span><br><span class="hljs-keyword">int</span> value = min + <span class="hljs-number">1</span> + (rand() % (max - min + <span class="hljs-number">0</span>));<br><span class="hljs-comment">//[min, max)的随机数</span><br><span class="hljs-keyword">int</span> value = min + <span class="hljs-number">0</span> + (rand() % (max - min + <span class="hljs-number">0</span>));<br><span class="hljs-comment">//[min, max]的随机数</span><br><span class="hljs-keyword">int</span> value = min + <span class="hljs-number">0</span> + (rand() % (max - min + <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。</span><br><span class="hljs-comment">//取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。</span><br><span class="hljs-comment">//切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大</span><br>srand((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)currentThreadId());<br>qrand((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)currentThreadId());<br></code></pre></td></tr></table></figure><h3 id="164-Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-gt-mouseButtons-，全局的鼠标坐标可以用QCursor-pos"><a href="#164-Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-gt-mouseButtons-，全局的鼠标坐标可以用QCursor-pos" class="headerlink" title="164. Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-&gt;mouseButtons()，全局的鼠标坐标可以用QCursor::pos()"></a>164. Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-&gt;mouseButtons()，全局的鼠标坐标可以用QCursor::pos()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在鼠标右键的地方弹出菜单，如果菜单是QMenu而不是QAction则只能通过下面的方式弹出</span><br><span class="hljs-keyword">if</span> (qApp-&gt;mouseButtons() == Qt::RightButton) &#123;<br>    videoMenu-&gt;exec(QCursor::pos());<br>&#125;<br><br><span class="hljs-comment">//全局剪切板</span><br>qApp-&gt;clipboard();<br><span class="hljs-comment">//顶层控件对象集合</span><br>qApp-&gt;topLevelWidgets()<br><span class="hljs-comment">//当前焦点所在控件</span><br>qApp-&gt;focusWidget()<br><span class="hljs-comment">//当前平台名称</span><br>qApp-&gt;platformName()<br><span class="hljs-comment">//调用系统蜂鸣器</span><br>qApp-&gt;beep()<br><span class="hljs-comment">//打印当前Qt版本信息</span><br>qApp-&gt;aboutQt()<br><span class="hljs-comment">//设置全局的鼠标样式</span><br>qApp-&gt;setOverrideCursor()<br><span class="hljs-comment">//不使用系统的标准颜色字体等</span><br>QGuiApplication::setDesktopSettingsAware(<span class="hljs-keyword">bool</span> on);<br><span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br><span class="hljs-comment">//更多的全局对象属性等可以查阅 qguiapplication.h 头文件，你会发现新大陆。</span><br></code></pre></td></tr></table></figure><h3 id="171-在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen-s函数，比如fmod中也是这个情况。这个时候就需要转码处理"><a href="#171-在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen-s函数，比如fmod中也是这个情况。这个时候就需要转码处理" class="headerlink" title="171. 在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理"></a>171. 在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString fileName = <span class="hljs-string">&quot;c:/测试目录/1.txt&quot;</span>;<br><span class="hljs-comment">//如果应用程序main函数中没有设置编码则默认采用系统的编码，可以直接通过toLocal8Bit转成正确的数据</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = fileName.toLocal8Bit().constData();<br><br><span class="hljs-comment">//如果设置过了下面两句则需要主动转码</span><br>QTextCodec *codec = QTextCodec::codecForName(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>QTextCodec::setCodecForLocale(codec);<br><br>QTextCodec *code = QTextCodec::codecForName(<span class="hljs-string">&quot;gbk&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = code-&gt;fromUnicode(fileName).constData();<br><br><span class="hljs-comment">//推荐方式2以防万一保证绝对的正确，哪怕是设置过主程序的编码</span><br><span class="hljs-comment">//切记一旦设置过QTextCodec::setCodecForLocale会影响toLocal8Bit</span><br><br><span class="hljs-comment">//有时候可能还有下面这种情况</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400)</span><br>    QTextCodec *code = QTextCodec::codecForName(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    QTextCodec *code = QTextCodec::codecForName(<span class="hljs-string">&quot;gbk&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = code-&gt;fromUnicode(fileName).constData();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = fileName.toUtf8().constData();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="175-Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick-qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。"><a href="#175-Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick-qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。" class="headerlink" title="175. Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。"></a>175. Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果是控制台程序则下面的QApplication换成QCoreApplication</span><br><span class="hljs-comment">//如果是quick/qml程序则下面的QApplication换成QGuiApplication</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard</span><br>    qputenv(<span class="hljs-string">&quot;QT_IM_MODULE&quot;</span>, QByteArray(<span class="hljs-string">&quot;qtvirtualkeyboard&quot;</span>));<br>    <br>    <span class="hljs-comment">//设置不应用操作系统设置比如字体</span><br>    QApplication::setDesktopSettingsAware(<span class="hljs-literal">false</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span><br>    <span class="hljs-comment">//设置高分屏缩放舍入策略</span><br>    QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))</span><br>    <span class="hljs-comment">//设置启用高分屏缩放支持</span><br>    <span class="hljs-comment">//要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下</span><br>    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);<br>    <span class="hljs-comment">//设置启用高分屏图片支持</span><br>    QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span><br>    <span class="hljs-comment">//设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL</span><br>    <span class="hljs-comment">//在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速</span><br>    <span class="hljs-comment">//如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2</span><br>    <span class="hljs-comment">//QApplication::setAttribute(Qt::AA_UseOpenGLES);</span><br>    <span class="hljs-comment">//设置opengl共享上下文</span><br>    QApplication::setAttribute(Qt::AA_ShareOpenGLContexts);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    QWidget w;<br>    w.show();<br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="178-Qt获取当前所用的Qt版本、编译器、位数等信息"><a href="#178-Qt获取当前所用的Qt版本、编译器、位数等信息" class="headerlink" title="178. Qt获取当前所用的Qt版本、编译器、位数等信息"></a>178. Qt获取当前所用的Qt版本、编译器、位数等信息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//详细的Qt版本+编译器+位数</span><br>QString compilerString = <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>;<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(Q_CC_CLANG)</span><br>    QString isAppleString;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__apple_build_version__)</span><br>    isAppleString = QLatin1String(<span class="hljs-string">&quot; (Apple)&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    compilerString = QLatin1String(<span class="hljs-string">&quot;Clang &quot;</span>) + QString::number(__clang_major__) + QLatin1Char(<span class="hljs-string">&#x27;.&#x27;</span>) + QString::number(__clang_minor__) + isAppleString;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(Q_CC_GNU)</span><br>    compilerString = QLatin1String(<span class="hljs-string">&quot;GCC &quot;</span>) + QLatin1String(__VERSION__);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(Q_CC_MSVC)</span><br>    <span class="hljs-keyword">if</span> (_MSC_VER &gt; <span class="hljs-number">1999</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC &lt;unknown&gt;&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1920</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2019&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1910</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2017&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1900</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2015&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1800</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2013&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1700</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2012&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1600</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2010&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC &lt;old&gt;&quot;</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">//拓展知识 查看 QSysInfo 类下面有很多好东西</span><br><span class="hljs-comment">// qVersion() = QT_VERSION_STR</span><br>QString version = QString(<span class="hljs-string">&quot;%1 %2 %3&quot;</span>).arg(qVersion()).arg(compilerString).arg(QString::number(QSysInfo::WordSize));<br></code></pre></td></tr></table></figure><h3 id="179-QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如-ddd-周二-Tue-dddd-星期二-Tuesday-，此时如果只想永远是中文就需要用到QLocale进行转换"><a href="#179-QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如-ddd-周二-Tue-dddd-星期二-Tuesday-，此时如果只想永远是中文就需要用到QLocale进行转换" class="headerlink" title="179. QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如 ddd = 周二 Tue  dddd = 星期二 Tuesday ，此时如果只想永远是中文就需要用到QLocale进行转换"></a>179. QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如 ddd = 周二 Tue  dddd = 星期二 Tuesday ，此时如果只想永远是中文就需要用到QLocale进行转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//格式化输出受到本地操作系统语言的影响</span><br><br><span class="hljs-comment">//英文操作系统</span><br><span class="hljs-comment">//这样获取到的是Mon到Sun，英文星期的3个字母的缩写。</span><br>QDateTime::currentDateTime().toString(<span class="hljs-string">&quot;ddd&quot;</span>);<br><span class="hljs-comment">//这样获取到的是Monday到Sunday，英文星期完整单词。</span><br>QDateTime::currentDateTime().toString(<span class="hljs-string">&quot;dddd&quot;</span>);<br><br><span class="hljs-comment">//中文操作系统</span><br><span class="hljs-comment">//这样获取到的是周一到周日。</span><br>QDateTime::currentDateTime().toString(<span class="hljs-string">&quot;ddd&quot;</span>);<br><span class="hljs-comment">//这样获取到的是星期一到星期日。</span><br>QDateTime::currentDateTime().toString(<span class="hljs-string">&quot;dddd&quot;</span>);<br><br><span class="hljs-comment">//主动指定语言转换</span><br><span class="hljs-comment">//如果没有指定本地语言则默认采用系统的语言环境。</span><br>QLocale locale;<br><span class="hljs-comment">//QLocale locale = QLocale::Chinese;</span><br><span class="hljs-comment">//QLocale locale = QLocale::English;</span><br><span class="hljs-comment">//QLocale locale = QLocale::Japanese;</span><br><br><span class="hljs-comment">//下面永远输出中文的周一到周日</span><br>locale.toString(QDateTime::currentDateTime(), <span class="hljs-string">&quot;ddd&quot;</span>);<br><span class="hljs-comment">//下面永远输出中文的星期一到星期日</span><br>locale.toString(QDateTime::currentDateTime(), <span class="hljs-string">&quot;dddd&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="182-Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等"><a href="#182-Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等" class="headerlink" title="182. Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等"></a>182. Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Qt5开始提供了日志上下文信息输出，比如输出当前打印消息所在的代码文件、行号、函数名等。</span><br><span class="hljs-comment">//如果是release还需要在pro中加上 DEFINES += QT_MESSAGELOGCONTEXT 才能输出上下文，默认release关闭的。</span><br><span class="hljs-comment">//切记不要在日志钩子函数中再写qdebug之类的，那样就死循环了。</span><br><span class="hljs-comment">//日志重定向一般就三种处理</span><br><span class="hljs-comment">//1: 输出到日志文件比如txt文本文件。</span><br><span class="hljs-comment">//2: 存储到数据库，可以分类存储，以便相关人员查询分析。</span><br><span class="hljs-comment">//3: 重定向到网络，对方用小工具连接程序后，所有打印信息通过tcp发过去。</span><br><br><span class="hljs-comment">//日志重定向</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(QtMsgType type, <span class="hljs-keyword">const</span> QMessageLogContext &amp;context, <span class="hljs-keyword">const</span> QString &amp;msg)</span></span><br><span class="hljs-function"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(QtMsgType type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//加锁,防止多线程中qdebug太频繁导致崩溃</span><br>    <span class="hljs-keyword">static</span> QMutex mutex;<br>    <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mutex)</span></span>;<br>    QString content;<br><br>    <span class="hljs-comment">//这里可以根据不同的类型加上不同的头部用于区分</span><br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> QtDebugMsg:<br>            content = QString(<span class="hljs-string">&quot;%1&quot;</span>).arg(msg);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> QtWarningMsg:<br>            content = QString(<span class="hljs-string">&quot;%1&quot;</span>).arg(msg);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> QtCriticalMsg:<br>            content = QString(<span class="hljs-string">&quot;%1&quot;</span>).arg(msg);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> QtFatalMsg:<br>            content = QString(<span class="hljs-string">&quot;%1&quot;</span>).arg(msg);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//加上打印代码所在代码文件、行号、函数名</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    <span class="hljs-keyword">if</span> (SaveLog::Instance()-&gt;getUseContext()) &#123;<br>        <span class="hljs-keyword">int</span> line = context.line;<br>        QString file = context.file;<br>        QString function = context.function;<br>        <span class="hljs-keyword">if</span> (line &gt; <span class="hljs-number">0</span>) &#123;<br>            content = QString(<span class="hljs-string">&quot;行号: %1  文件: %2  函数: %3\n%4&quot;</span>).arg(line).arg(file).arg(function).arg(content);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">//将内容传给函数进行处理</span><br>    SaveLog::Instance()-&gt;save(content);<br>&#125;<br><br><span class="hljs-comment">//安装日志钩子,输出调试信息到文件,便于调试</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveLog::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    qInstallMessageHandler(Log);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    qInstallMsgHandler(Log);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">//卸载日志钩子</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveLog::stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    qInstallMessageHandler(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    qInstallMsgHandler(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="184-由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4-Qt5-Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用-QT-VERSION-CHECK-需要先引入-include-“qglobal-h”不然编译失败，因为-QT-VERSION-CHECK-这个函数在-qglobal-h-头文件中"><a href="#184-由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4-Qt5-Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用-QT-VERSION-CHECK-需要先引入-include-“qglobal-h”不然编译失败，因为-QT-VERSION-CHECK-这个函数在-qglobal-h-头文件中" class="headerlink" title="184. 由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4/Qt5/Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用 QT_VERSION_CHECK 需要先引入#include “qglobal.h”不然编译失败，因为 QT_VERSION_CHECK 这个函数在 qglobal.h 头文件中"></a>184. 由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4/Qt5/Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用 QT_VERSION_CHECK 需要先引入#include “qglobal.h”不然编译失败，因为 QT_VERSION_CHECK 这个函数在 qglobal.h 头文件中</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//至少要包含 qglobal.h，理论上Qt所有的类都包含了这个头文件，所以你引入Qt的其他头文件也行比如 qobject.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;qglobal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;qscreen.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;qdesktopwidget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="185-在使用QString转换到char-或者const-char-的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对"><a href="#185-在使用QString转换到char-或者const-char-的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对" class="headerlink" title="185. 在使用QString转换到char *或者const char *的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对"></a>185. 在使用QString转换到char *或者const char *的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对</h3><ul><li>转换前QString的内容无关中文还是英文，要出问题都一样。</li><li>转换中QByteArray无关具体类型，toUtf8、toLatin1、toLocal8Bit、toStdString等方法，要出问题都一样。</li><li>转换后无关char *还是const char *，要出问题都一样。</li><li>出问题的随机性的，概率出现，理论上debug的概率更大。</li><li>根据酷码大佬分析可能的原因(不确定)是msvc为了方便调试，debug会在内存释放后做填充，release则不会。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString text = <span class="hljs-string">&quot;xxxxx&quot;</span>;<br><span class="hljs-comment">//下面这样转换很可能会有问题</span><br><span class="hljs-keyword">char</span> *data = text.toUtf8().data();<br><span class="hljs-comment">//分两步转换肯定不会有问题</span><br>QByteArray buffer = text.toUtf8();<br><span class="hljs-keyword">char</span> *data = buffer.data();<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data = buffer.constData();<br></code></pre></td></tr></table></figure></li></ul><h3 id="192-Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型"><a href="#192-Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型" class="headerlink" title="192. Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型"></a>192. Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//qwindowdefs.h</span><br><span class="hljs-keyword">typedef</span> QList&lt;QWidget *&gt; QWidgetList;<br><span class="hljs-keyword">typedef</span> QList&lt;QWindow *&gt; QWindowList;<br><span class="hljs-keyword">typedef</span> QHash&lt;WId, QWidget *&gt; QWidgetMapper;<br><span class="hljs-keyword">typedef</span> QSet&lt;QWidget *&gt; QWidgetSet;<br><br><span class="hljs-comment">//qmetatype.h</span><br><span class="hljs-keyword">typedef</span> QList&lt;QVariant&gt; QVariantList;<br><span class="hljs-keyword">typedef</span> QMap&lt;QString, QVariant&gt; QVariantMap;<br><span class="hljs-keyword">typedef</span> QHash&lt;QString, QVariant&gt; QVariantHash;<br><span class="hljs-keyword">typedef</span> QList&lt;QByteArray&gt; QByteArrayList;<br></code></pre></td></tr></table></figure><h3 id="196-关于Qt延时的几种方法"><a href="#196-关于Qt延时的几种方法" class="headerlink" title="196. 关于Qt延时的几种方法"></a>196. 关于Qt延时的几种方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QUIHelperCore::sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msec)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (msec &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 1</span><br>    <span class="hljs-comment">//非阻塞方式延时,现在很多人推荐的方法</span><br>    QEventLoop loop;<br>    QTimer::singleShot(msec, &amp;loop, SLOT(quit()));<br>    loop.exec();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    <span class="hljs-comment">//阻塞方式延时,如果在主线程会卡住主界面</span><br>    QThread::msleep(msec);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-comment">//非阻塞方式延时,不会卡住主界面,据说可能有问题</span><br>    QTime endTime = QTime::currentTime().addMSecs(msec);<br>    <span class="hljs-keyword">while</span> (QTime::currentTime() &lt; endTime) &#123;<br>        QCoreApplication::processEvents(QEventLoop::AllEvents, <span class="hljs-number">100</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pro"><a href="#pro" class="headerlink" title="pro"></a>pro</h2><h3 id="7-管理员运行程序，限定在MSVC编译器"><a href="#7-管理员运行程序，限定在MSVC编译器" class="headerlink" title="7.管理员运行程序，限定在MSVC编译器"></a>7.<code>管理员运行程序</code>，限定在MSVC编译器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QMAKE_LFLAGS += /MANIFESTUAC:<span class="hljs-string">&quot;level=&#x27;requireAdministrator&#x27; uiAccess=&#x27;false&#x27;&quot;</span> #以管理员运行<br>QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,<span class="hljs-string">&quot;5.01&quot;</span> #VS2013 在XP运行<br></code></pre></td></tr></table></figure><h3 id="8-运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上这个，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的"><a href="#8-运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上这个，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的" class="headerlink" title="8. 运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上这个，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的"></a>8. 运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上这个，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，<code>一般没法正常运行的程序都会打印一些提示信息缺啥之类的</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CONFIG      += console<br></code></pre></td></tr></table></figure><h3 id="13-根据操作系统位数判断加载"><a href="#13-根据操作系统位数判断加载" class="headerlink" title="13. 根据操作系统位数判断加载"></a>13. 根据操作系统位数判断加载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>win32 &#123;<br><br>​    contains(DEFINES, WIN64) &#123;<br><br>​        DESTDIR = $$PWD/../bin64<br><br>​    &#125; <span class="hljs-keyword">else</span> &#123; <br><br>​        DESTDIR = $$PWD/../bin32<br><br>​    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="31-判断编译器类型、编译器版本、操作系统"><a href="#31-判断编译器类型、编译器版本、操作系统" class="headerlink" title="31. 判断编译器类型、编译器版本、操作系统"></a>31. 判断编译器类型、编译器版本、操作系统</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//GCC编译器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __GNUC__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __GNUC__ &gt;= 3   <span class="hljs-comment">// GCC3.0  以上</span></span><br><br><span class="hljs-comment">//MSVC编译器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1000 <span class="hljs-comment">// VC++4.0 以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1100 <span class="hljs-comment">// VC++5.0 以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1200 <span class="hljs-comment">// VC++6.0 以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1300 <span class="hljs-comment">// VC2003  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1400 <span class="hljs-comment">// VC2005  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1500 <span class="hljs-comment">// VC2008  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1600 <span class="hljs-comment">// VC2010  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1700 <span class="hljs-comment">// VC2012  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1800 <span class="hljs-comment">// VC2013  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1900 <span class="hljs-comment">// VC2015  以上</span></span><br><br><span class="hljs-comment">//Borland C++</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __BORLANDC__</span><br><br><span class="hljs-comment">//Cygwin</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CYGWIN__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CYGWIN32__</span><br><br><span class="hljs-comment">//mingw</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span><br><br><span class="hljs-comment">//windows</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32           <span class="hljs-comment">//32bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64           <span class="hljs-comment">//64bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WINDOWS         <span class="hljs-comment">//图形界面程序</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _CONSOLE         <span class="hljs-comment">//控制台程序</span></span><br><br><span class="hljs-comment">//Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x030a)  <span class="hljs-comment">// Windows 3.1以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0400)  <span class="hljs-comment">// Windows 95/NT4.0以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0410)  <span class="hljs-comment">// Windows 98以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0500)  <span class="hljs-comment">// Windows Me/2000以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0501)  <span class="hljs-comment">// Windows XP以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0600)  <span class="hljs-comment">// Windows Vista以上</span></span><br><br><span class="hljs-comment">//_WIN32_WINNT 内核版本</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (_WIN32_WINNT &gt;= 0x0500) <span class="hljs-comment">// Windows 2000以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (_WIN32_WINNT &gt;= 0x0501) <span class="hljs-comment">// Windows XP以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (_WIN32_WINNT &gt;= 0x0600) <span class="hljs-comment">// Windows Vista以上</span></span><br><br></code></pre></td></tr></table></figure><h3 id="32-在pro中判断Qt版本及构建套件位数"><a href="#32-在pro中判断Qt版本及构建套件位数" class="headerlink" title="32. 在pro中判断Qt版本及构建套件位数"></a>32. 在pro中判断Qt版本及构建套件位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#打印版本信息<br>message(qt version: $$QT_VERSION)<br>#判断当前qt版本号<br>QT_VERSION = $$[QT_VERSION]<br>QT_VERSION = $$split(QT_VERSION, <span class="hljs-string">&quot;.&quot;</span>)<br>QT_VER_MAJ = $$member(QT_VERSION, <span class="hljs-number">0</span>)<br>QT_VER_MIN = $$member(QT_VERSION, <span class="hljs-number">1</span>)<br>#下面是表示 Qt5<span class="hljs-number">.5</span>及以上版本<br>greaterThan(QT_VER_MAJ, <span class="hljs-number">4</span>) &#123;<br>greaterThan(QT_VER_MIN, <span class="hljs-number">4</span>) &#123;<br>#自己根据需要做一些处理<br>&#125;&#125;<br><br>#QT_ARCH是Qt5新增的,在Qt4上没效果<br>#打印当前Qt构建套件的信息<br>message($$QT_ARCH)<br>#表示arm平台构建套件<br>contains(QT_ARCH, arm) &#123;&#125;<br>#表示<span class="hljs-number">32</span>位的构建套件<br>contains(QT_ARCH, i386) &#123;&#125;<br>#表示<span class="hljs-number">64</span>位的构建套件<br>contains(QT_ARCH, x86_64) &#123;&#125;<br><br>#其实Qt内置了主版本号和子版本号变量<br>#判断当前qt版本号<br>message($$QT_ARCH : $$QT_VERSION -&gt; $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION)<br><br>#下面的含义是如果版本 &lt; <span class="hljs-number">4.8</span><br>lessThan(QT_MAJOR_VERSION, <span class="hljs-number">5</span>) &#123;<br>lessThan(QT_MINOR_VERSION, <span class="hljs-number">8</span>) &#123;<br>#这里放要做的处理<br>&#125;&#125;<br><br>#下面的含义是如果版本 &lt; <span class="hljs-number">5.12</span><span class="hljs-number">.0</span><br>REQ_QT_MAJOR = <span class="hljs-number">5</span><br>REQ_QT_MINOR = <span class="hljs-number">12</span><br>REQ_QT_PATCH = <span class="hljs-number">0</span><br>lessThan(QT_MAJOR_VERSION, $$REQ_QT_MAJOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_MINOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_PATCH) &#123;<br>#这里放要做的处理<br>&#125;<br><br>#下面的含义是如果版本 &gt;= <span class="hljs-number">5.5</span><br>greaterThan(QT_MAJOR_VERSION, <span class="hljs-number">4</span>) &#123;<br>greaterThan(QT_MINOR_VERSION, <span class="hljs-number">4</span>) &#123;<br>#这里放要做的处理<br>&#125;&#125;<br><br><span class="hljs-comment">//代码中判断版本不要太简单</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span><br><span class="hljs-comment">//这里放要做的处理</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//下面表示 &gt;= 5.0.0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> QT_VERSION &gt;= 0x050000</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//下面表示 &lt; 5.12.10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> QT_VERSION &lt; 0x050C0A</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="47-多种预定义变量-if-defined-webkit-defined-webengine-，去掉生成空的debug和release目录-CONFIG-debug-and-release"><a href="#47-多种预定义变量-if-defined-webkit-defined-webengine-，去掉生成空的debug和release目录-CONFIG-debug-and-release" class="headerlink" title="47. 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug和release目录 CONFIG -= debug_and_release"></a>47. 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug和release目录 CONFIG -= debug_and_release</h3><h3 id="52-Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启-CONFIG-resources-big"><a href="#52-Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启-CONFIG-resources-big" class="headerlink" title="52. Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启 CONFIG += resources_big"></a>52. Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启 <code>CONFIG += resources_big</code></h3><h3 id="80-从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES-QT-DISABLE-DEPRECATED-BEFORE-0"><a href="#80-从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES-QT-DISABLE-DEPRECATED-BEFORE-0" class="headerlink" title="80. 从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0"></a>80. 从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0</h3><h3 id="104-在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则"><a href="#104-在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则" class="headerlink" title="104. 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则"></a>104. 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TEMPLATE = subdirs<br>#设置ordered参数以后会依次编译 projA projB projC<br>CONFIG  += ordered<br>SUBDIRS += projA<br>SUBDIRS += projB<br>SUBDIRS += projC<br>#还可以通过设置depends指定某个项目依赖 比如下面指定projB依赖projA<br>projB.depends = projA<br>projC.depends = projA<br>projD.depends = projC<br></code></pre></td></tr></table></figure><h3 id="115-有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有-QT-的方式添加的模块，可以用-contains来判断"><a href="#115-有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有-QT-的方式添加的模块，可以用-contains来判断" class="headerlink" title="115. 有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT += 的方式添加的模块，可以用 contains来判断"></a>115. 有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT += 的方式添加的模块，可以用 contains来判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">qtHaveModule(webenginewidgets) &#123;<br>message(<span class="hljs-string">&quot;当前Qt库有找到 webenginewidgets 模块&quot;</span>)<br>&#125;<br><br>!qtHaveModule(webkit) &#123;<br>message(<span class="hljs-string">&quot;当前Qt库没有找到 webkit 模块&quot;</span>)<br>&#125;<br><br>contains(QT, network) &#123;<br>message(<span class="hljs-string">&quot;当前项目已经引入 network 模块&quot;</span>)<br>&#125;<br><br>!contains(QT, widgets) &#123;<br>message(<span class="hljs-string">&quot;当前项目没有引入 widgets 模块&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="126-Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出"><a href="#126-Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出" class="headerlink" title="126. Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出"></a>126. Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#禁用qdebug打印输出<br>DEFINES += QT_NO_DEBUG_OUTPUT<br></code></pre></td></tr></table></figure><h3 id="127-在使用-QT-NO-DEBUG-OUTPUT-关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实-QT-NO-DEBUG-OUTPUT-禁用的-qdebug-的输出，Qt还有其他几种打印信息比如-qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用-qInfo-来输出信息就好。特别注意：qFatal-打印完信息程序会自动结束"><a href="#127-在使用-QT-NO-DEBUG-OUTPUT-关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实-QT-NO-DEBUG-OUTPUT-禁用的-qdebug-的输出，Qt还有其他几种打印信息比如-qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用-qInfo-来输出信息就好。特别注意：qFatal-打印完信息程序会自动结束" class="headerlink" title="127. 在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束"></a>127. 在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">qDebug() &lt;&lt; <span class="hljs-string">&quot;qDebug&quot;</span>;<br>qInfo() &lt;&lt; <span class="hljs-string">&quot;qInfo&quot;</span>;<br>qWarning() &lt;&lt; <span class="hljs-string">&quot;qWarning&quot;</span>;<br>qCritical() &lt;&lt; <span class="hljs-string">&quot;qCritical&quot;</span>;<br><br>qDebug(<span class="hljs-string">&quot;qDebug&quot;</span>);<br>qWarning(<span class="hljs-string">&quot;qWarning&quot;</span>);<br>qCritical(<span class="hljs-string">&quot;qCritical&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="128-Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去"><a href="#128-Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去" class="headerlink" title="128. Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去"></a>128. Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#禁用qdebug打印输出<br>DEFINES     += QT_NO_DEBUG_OUTPUT<br><br>#自定义define变量 可以在整个项目中使用<br><span class="hljs-meta">#pro文件可以这样判断 contains(DEFINES, videovlc) &#123;&#125;</span><br>#代码文件可以这样判断 <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> videovlc</span><br>DEFINES     += videovlc1 videoffmpeg<br><br>#关闭编译警告提示 眼不见为净<br>CONFIG      += warn_off<br><br>#指定编译生成的文件到temp目录 分门别类存储<br>MOC_DIR     = temp/moc<br>RCC_DIR     = temp/rcc<br>UI_DIR      = temp/ui<br>OBJECTS_DIR = temp/obj<br><br>#指定编译生成的可执行文件到bin目录<br>DESTDIR     = bin<br></code></pre></td></tr></table></figure><h3 id="130-Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过-QMAKE-POST-LINK和QMAKE-PRE-LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索-qmake-Function-Reference-查看详情说明"><a href="#130-Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过-QMAKE-POST-LINK和QMAKE-PRE-LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索-qmake-Function-Reference-查看详情说明" class="headerlink" title="130. Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过 QMAKE_POST_LINK和QMAKE_PRE_LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索 qmake Function Reference 查看详情说明"></a>130. Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过 QMAKE_POST_LINK和QMAKE_PRE_LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索 qmake Function Reference 查看详情说明</h3><ul><li>QMAKE_PRE_LINK    表示编译前执行内容</li><li>QMAKE_POST_LINK   表示编译后执行内容</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">srcFile1 = $$PWD/<span class="hljs-number">1.</span>txt<br>srcFile2 = $$PWD/<span class="hljs-number">2.</span>txt<br>dstDir = $$PWD/../bin<br><span class="hljs-meta">#windows上需要转换路径斜杠 其他系统不需要</span><br>srcFile1 = $$replace(srcFile1, /, \\);<br>srcFile2 = $$replace(srcFile2, /, \\);<br>dstDir = $$replace(dstDir, /, \\);<br><br>#编译前执行拷贝 多个拷贝可以通过 &amp;&amp; 符号隔开<br>QMAKE_PRE_LINK += copy /Y $$srcFile1 $$dstDir &amp;&amp; copy /Y $$srcFile2 $$dstDir<br>#编译后执行拷贝 多个拷贝可以通过 &amp;&amp; 符号隔开<br>QMAKE_POST_LINK += copy /Y $$srcFile1 $$dstDir &amp;&amp; copy /Y $$srcFile2 $$dstDir<br></code></pre></td></tr></table></figure><h3 id="132-Qt6-0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件-QT-core5compat-才能用，-具体说明在https-doc-qt-io-qt-6-qtcore5-index-html"><a href="#132-Qt6-0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件-QT-core5compat-才能用，-具体说明在https-doc-qt-io-qt-6-qtcore5-index-html" class="headerlink" title="132. Qt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT += core5compat 才能用， 具体说明在https://doc.qt.io/qt-6/qtcore5-index.html"></a>132. Qt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT += core5compat 才能用， 具体说明在<a href="https://doc.qt.io/qt-6/qtcore5-index.html">https://doc.qt.io/qt-6/qtcore5-index.html</a></h3><h3 id="157-项目中启用c-11语法支持"><a href="#157-项目中启用c-11语法支持" class="headerlink" title="157. 项目中启用c++11语法支持"></a>157. 项目中启用c++11语法支持</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">greaterThan(QT_MAJOR_VERSION, <span class="hljs-number">4</span>): CONFIG += c++<span class="hljs-number">11</span><br>lessThan(QT_MAJOR_VERSION, <span class="hljs-number">5</span>): QMAKE_CXXFLAGS += -<span class="hljs-built_in">std</span>=c++<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h3 id="165-Qt对区分不同的编译器也做了非常细致的处理"><a href="#165-Qt对区分不同的编译器也做了非常细致的处理" class="headerlink" title="165. Qt对区分不同的编译器也做了非常细致的处理"></a>165. Qt对区分不同的编译器也做了非常细致的处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#pro文件可以这样判断</span><br>msvc &#123;<br><span class="hljs-comment">//要做的处理</span><br>&#125;<br><br>mingw &#123;<br><span class="hljs-comment">//要做的处理</span><br>&#125;<br><br><span class="hljs-comment">//代码中可以这样判断</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_CC_MINGW</span><br><span class="hljs-comment">//mingw编译器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> Q_CC_MSVC</span><br><span class="hljs-comment">//msvc编译器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//判断编译器和编译器版本</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined Q_CC_MSVC &amp;&amp; _MSC_VER &lt; 1300</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(Q_CC_GNU) &amp;&amp; (__GNUC__ &lt; 4)</span><br><br><span class="hljs-comment">//代码中判断ARM平台</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> QT_ARCH_ARM</span><br><span class="hljs-comment">//多个条件判断</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE)</span><br></code></pre></td></tr></table></figure><h3 id="167-项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2"><a href="#167-项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2" class="headerlink" title="167. 项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2"></a>167. 项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1：pro文件直接全部引入，而不是每个都添加一次，省心省力。</span><br>HEADERS += *.h<br>SOURCES += *.cpp<br><br><span class="hljs-comment">//方法2：分模块文件夹存放，不同模块用pri包含代码文件，比如界面可以放在ui文件夹，下面搞个ui.pri，然后pro项目文件只需要引入这个pri文件即可。</span><br>include($$PWD/ui/ui.pri)<br><span class="hljs-comment">//还可以加上一句包含路径这样可以省去在使用代码的时候不用写文件夹</span><br>INCLUDEPATH += $$PWD/ui<br><span class="hljs-comment">//加上上面这行，在使用头文件的时候可以直接 include &quot;form.h&quot;，没有加则需要 include &quot;ui/form.h&quot;。</span><br></code></pre></td></tr></table></figure><h2 id="元对象"><a href="#元对象" class="headerlink" title="元对象"></a>元对象</h2><h3 id="2-定时器是个好东西-QMetaObject-invokeMethod的使用"><a href="#2-定时器是个好东西-QMetaObject-invokeMethod的使用" class="headerlink" title="2. 定时器是个好东西(QMetaObject::invokeMethod的使用)"></a>2. 定时器是个好东西(<code>QMetaObject::invokeMethod的使用</code>)</h3><p>定时器是个好东西，学会好使用它，有时候用QTimer::singleShot单次定时器和<strong>QMetaObject::invokeMethod</strong>可以解决意想不到的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//异步执行load函数</span><br>QMetaObject::invokeMethod(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;load&quot;</span>, Qt::QueuedConnection);<br></code></pre></td></tr></table></figure><h3 id="11-获取类的属性"><a href="#11-获取类的属性" class="headerlink" title="11. 获取类的属性"></a>11. 获取类的属性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">const</span> QMetaObject *metaobject = object-&gt;metaObject();<br><br><span class="hljs-keyword">int</span> count = metaobject-&gt;propertyCount();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br><br>​    QMetaProperty metaproperty = metaobject-&gt;property(i);<br><br>​    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = metaproperty.name();<br><br>​    QVariant value = object-&gt;property(name);<br><br>​    qDebug() &lt;&lt; name &lt;&lt; value;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="18-巧妙的使用inherits判断是否属于某种类"><a href="#18-巧妙的使用inherits判断是否属于某种类" class="headerlink" title="18. 巧妙的使用inherits判断是否属于某种类"></a>18. 巧妙的使用inherits判断是否属于某种类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QTimer *timer = <span class="hljs-keyword">new</span> QTimer;         <span class="hljs-comment">// QTimer inherits QObject</span><br>timer-&gt;inherits(<span class="hljs-string">&quot;QTimer&quot;</span>);          <span class="hljs-comment">// returns true</span><br>timer-&gt;inherits(<span class="hljs-string">&quot;QObject&quot;</span>);         <span class="hljs-comment">// returns true</span><br>timer-&gt;inherits(<span class="hljs-string">&quot;QAbstractButton&quot;</span>); <span class="hljs-comment">// returns false</span><br></code></pre></td></tr></table></figure><h3 id="112-巧用QMetaObject-invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用-QMetaObject-invokeMethod-obj-“fun”-Qt-QueuedConnection-这种方式来就可以"><a href="#112-巧用QMetaObject-invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用-QMetaObject-invokeMethod-obj-“fun”-Qt-QueuedConnection-这种方式来就可以" class="headerlink" title="112. 巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, “fun”, Qt::QueuedConnection); 这种方式来就可以"></a>112. 巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, “fun”, Qt::QueuedConnection); 这种方式来就可以</h3><ul><li>invokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。</li><li>invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！</li><li>测试下来发现只能执行signals或者slots标识的方法。</li><li>默认可以执行private(protected/public) slots下的函数，但是不能执行private(protected/public)下的函数。</li><li>毛总补充：前提必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。</li><li>2021-11-06补充：如果要执行private(protected/public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字，今天又学到了，必须加鸡腿。</li><li>其实这样看下来，就是任何方法函数都能执行了，这就超越了private(protected/public)的权限限定了，相当于一个类的私有函数用了 Q_INVOKABLE 关键字修饰也可以被 invokeMethod 执行，哇咔咔。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件声明信号和槽函数</span><br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sig_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type,<span class="hljs-keyword">double</span> value)</span></span>;<br><span class="hljs-keyword">private</span> slots:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slot_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> value)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">Q_INVOKABLE <span class="hljs-keyword">void</span> <span class="hljs-title">fun_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> value)</span></span>;<br><br><span class="hljs-comment">//构造函数关联信号槽</span><br>connect(<span class="hljs-keyword">this</span>, SIGNAL(sig_test(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)), <span class="hljs-keyword">this</span>, SLOT(slot_test(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)));<br><br><span class="hljs-comment">//单击按钮触发信号和槽,这里是同时举例信号槽都可以</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::on_pushButton_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QMetaObject::invokeMethod(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;sig_test&quot;</span>, Q_ARG(<span class="hljs-keyword">int</span>, <span class="hljs-number">66</span>), Q_ARG(<span class="hljs-keyword">double</span>, <span class="hljs-number">66.66</span>));<br>    QMetaObject::invokeMethod(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;slot_test&quot;</span>, Q_ARG(<span class="hljs-keyword">int</span>, <span class="hljs-number">88</span>), Q_ARG(<span class="hljs-keyword">double</span>, <span class="hljs-number">88.88</span>));<br>    QMetaObject::invokeMethod(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;fun_test&quot;</span>, Q_ARG(<span class="hljs-keyword">int</span>, <span class="hljs-number">99</span>), Q_ARG(<span class="hljs-keyword">double</span>, <span class="hljs-number">99.99</span>));<br>&#125;<br><br><span class="hljs-comment">//会打印 66 66.66、88 88.88</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::slot_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    qDebug() &lt;&lt; type &lt;&lt; value;<br>&#125;<br><br><span class="hljs-comment">//会打印 99.99</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::fun_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    qDebug() &lt;&lt; type &lt;&lt; value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="webengine"><a href="#webengine" class="headerlink" title="webengine"></a>webengine</h2><h3 id="23-如果用了webengine模块，发布程序的时候带上QtWebEngineProcess-exe-translations文件夹-resources文件夹"><a href="#23-如果用了webengine模块，发布程序的时候带上QtWebEngineProcess-exe-translations文件夹-resources文件夹" class="headerlink" title="23. 如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe+translations文件夹+resources文件夹"></a>23. 如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe+translations文件夹+resources文件夹</h3><h3 id="94-QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染"><a href="#94-QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染" class="headerlink" title="94. QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染"></a>94. QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span><br>    <span class="hljs-comment">//下面两种方法都可以,Qt默认采用的是AA_UseDesktopOpenGL</span><br>    QCoreApplication::setAttribute(Qt::AA_UseOpenGLES);<br>    <span class="hljs-comment">//QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br></code></pre></td></tr></table></figure><p>另外一个方法解决 全屏+QWebEngineView控件一起会产生右键菜单无法弹出的bug,需要上移一个像素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QRect rect = qApp-&gt;desktop()-&gt;geometry();<br>rect.setY(<span class="hljs-number">-1</span>);<br>rect.setHeight(rect.height());<br><span class="hljs-keyword">this</span>-&gt;setGeometry(rect);<br></code></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="19-使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-gt-dynamicPropertyNames-列出所有弱属性名称，然后通过widget-gt-property-“name”-取出对应的弱属性的值"><a href="#19-使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-gt-dynamicPropertyNames-列出所有弱属性名称，然后通过widget-gt-property-“name”-取出对应的弱属性的值" class="headerlink" title="19. 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-&gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-&gt;property(“name”)取出对应的弱属性的值"></a>19. 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-&gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-&gt;property(“name”)取出对应的弱属性的值</h3><h3 id="22-善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来"><a href="#22-善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来" class="headerlink" title="22. 善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来"></a>22. 善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来</h3><h3 id="162-Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5-9以前需要拿到原有的窗体属性做运算，后面可以用新的方法"><a href="#162-Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5-9以前需要拿到原有的窗体属性做运算，后面可以用新的方法" class="headerlink" title="162. Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法"></a>162. Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//增加一个无边框属性</span><br>setWindowFlags(windowFlags() | Qt::FramelessWindowHint);<br><span class="hljs-comment">//移除无边框属性</span><br>setWindowFlags(windowFlags() &amp; ~Qt::FramelessWindowHint);<br><br><span class="hljs-comment">//下面是5.9以后新增的方法</span><br><span class="hljs-comment">//增加一个无边框属性到窗体属性链表</span><br>setWindowFlag(Qt::FramelessWindowHint, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">//从窗体属性链表中移除无边框属性</span><br>setWindowFlag(Qt::FramelessWindowHint, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><h3 id="29-Qtcreator软件的配置文件存放在：C-Users-Administrator-AppData-Roaming-QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可"><a href="#29-Qtcreator软件的配置文件存放在：C-Users-Administrator-AppData-Roaming-QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可" class="headerlink" title="29. Qtcreator软件的配置文件存放在：C:\Users\Administrator\AppData\Roaming\QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可"></a>29. Qtcreator软件的配置文件存放在：C:\Users\Administrator\AppData\Roaming\QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可</h3><h3 id="48-新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About-Plugins。也可以设置代码检查级别，Tools》Options-》C-》Code-Model"><a href="#48-新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About-Plugins。也可以设置代码检查级别，Tools》Options-》C-》Code-Model" class="headerlink" title="48. 新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model"></a>48. 新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model</h3><h3 id="148-QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息"><a href="#148-QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息" class="headerlink" title="148. QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息"></a>148. QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息</h3><ul><li>菜单-&gt;工具-&gt;选项-&gt;文本编辑器-&gt;右侧tab页面片段(snippets)；</li><li>组选择C++, 可以看到这里面已经内置了不少定义比如foreach，可以依葫芦画瓢；</li><li>添加一个片段, 比如名字是fun, 触发种类是这个片段的简单描述；</li><li>当我们在代码文件中键入fun时, 会自动弹出智能提醒, 选择我们的代码片段回车, 自动填充代码；</li><li>按tab可以在变量间切换, 输入完成后回车, 完成编辑；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief $name$</span><br><span class="hljs-comment">  * @param $param$</span><br><span class="hljs-comment">  * @author feiyangqingyun</span><br><span class="hljs-comment">  * @date $date$</span><br><span class="hljs-comment">  */</span><br>$ret$ $name$($param$)<br>&#123;<br>    $$<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="51-在某些http-post数据的时候，如果采用的是-amp-字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码"><a href="#51-在某些http-post数据的时候，如果采用的是-amp-字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码" class="headerlink" title="51. 在某些http post数据的时候，如果采用的是&amp;字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码"></a>51. 在某些http post数据的时候，如果采用的是&amp;字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString content = <span class="hljs-string">&quot;测试中文&quot;</span>;<br>QString note = content.toUtf8().toPercentEncoding();<br></code></pre></td></tr></table></figure><h3 id="56-在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接"><a href="#56-在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接" class="headerlink" title="56. 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接"></a>56. 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> fd = tcpSocket-&gt;socketDescriptor();<br><span class="hljs-keyword">int</span> keepAlive = <span class="hljs-number">1</span>;      <span class="hljs-comment">//开启keepalive属性,缺省值:0(关闭)</span><br><span class="hljs-keyword">int</span> keepIdle = <span class="hljs-number">5</span>;       <span class="hljs-comment">//如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s)</span><br><span class="hljs-keyword">int</span> keepInterval = <span class="hljs-number">2</span>;   <span class="hljs-comment">//探测时发探测包的时间间隔为2秒,缺省值:75(s)</span><br><span class="hljs-keyword">int</span> keepCount = <span class="hljs-number">2</span>;      <span class="hljs-comment">//探测重试的次数,全部超时则认定连接失效,缺省值:9(次)</span><br>setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (<span class="hljs-keyword">void</span> *)&amp;keepAlive, <span class="hljs-keyword">sizeof</span>(keepAlive));<br>setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (<span class="hljs-keyword">void</span> *)&amp;keepIdle, <span class="hljs-keyword">sizeof</span>(keepIdle));<br>setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (<span class="hljs-keyword">void</span> *)&amp;keepInterval, <span class="hljs-keyword">sizeof</span>(keepInterval));<br>setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (<span class="hljs-keyword">void</span> *)&amp;keepCount, <span class="hljs-keyword">sizeof</span>(keepCount));<br></code></pre></td></tr></table></figure><h3 id="89-理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理"><a href="#89-理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理" class="headerlink" title="89. 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理"></a>89. 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理</h3><h3 id="92-新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写"><a href="#92-新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写" class="headerlink" title="92. 新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写"></a>92. 新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incomingConnection</span><span class="hljs-params">(qintptr handle)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incomingConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> handle)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="107-很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源"><a href="#107-很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源" class="headerlink" title="107. 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源"></a>107. 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源</h3><ul><li>如果你没有使用wait***函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的；</li><li>还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给UI造成很大的压力的，最好的办法是解决如何不要频繁绘制UI比如合并数据一起绘制等；</li><li>如果是因为绘制UI造成的卡，那多线程也是没啥用的，因为UI只能在主线程；</li><li>串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中；</li><li>如果没有严格的数据同步需求，根本不需要调用wait***之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了；</li><li>有严格数据同步需求的场景还是放到多线程会好一些，不然你wait***就卡在那边了；</li><li>多线程是需要占用系统资源的，理论上来说，如果线程数量超过了CPU的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊；</li><li>再次强调，不要指望Qt的网络通信支持高并发，最多到1000个能正常工作就万事大吉，一般建议500以内的连接数。有大量高并发的需求请用第三方库比如swoole等。</li></ul><h3 id="168-在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的"><a href="#168-在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的" class="headerlink" title="168. 在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的"></a>168. 在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//tcp客户端</span><br>QTcpSocket *socket = <span class="hljs-keyword">new</span> QTcpSocket(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//断开所有连接和操作</span><br>socket-&gt;<span class="hljs-built_in">abort</span>();<br><span class="hljs-comment">//绑定网卡和端口</span><br>socket-&gt;bind(QHostAddress(<span class="hljs-string">&quot;192.168.1.2&quot;</span>), <span class="hljs-number">6005</span>);<br><span class="hljs-comment">//连接服务器</span><br>socket-&gt;connectToHost(<span class="hljs-string">&quot;192.168.1.3&quot;</span>, <span class="hljs-number">6000</span>);<br><br><span class="hljs-comment">//打印通信用的本地绑定地址和端口</span><br>qDebug() &lt;&lt; socket-&gt;localAddress() &lt;&lt; socket-&gt;localPort();<br><span class="hljs-comment">//打印通信服务器对方的地址和端口</span><br>qDebug() &lt;&lt; socket-&gt;peerAddress() &lt;&lt; socket-&gt;peerPort() &lt;&lt; socket-&gt;peerName();<br><br><span class="hljs-comment">//udp客户端</span><br>QUdpSocket *socket = <span class="hljs-keyword">new</span> QUdpSocket(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//绑定网卡和端口,没有绑定过才需要绑定</span><br><span class="hljs-comment">//采用端口是否一样来判断是为了方便可以直接动态绑定切换端口</span><br><span class="hljs-keyword">if</span> (socket-&gt;localPort() != <span class="hljs-number">6005</span>) &#123;<br>    socket-&gt;<span class="hljs-built_in">abort</span>();<br>    socket-&gt;bind(QHostAddress(<span class="hljs-string">&quot;192.168.1.2&quot;</span>), <span class="hljs-number">6005</span>);<br>&#125;<br><span class="hljs-comment">//指定地址和端口发送数据</span><br>socket-&gt;writeDatagram(buffer, QHostAddress(<span class="hljs-string">&quot;192.168.1.3&quot;</span>), <span class="hljs-number">6000</span>);<br><br><span class="hljs-comment">//上面是Qt5可以使用bind，Qt4中的QTcpSocket的对应接口是protected的没法直接使用，需要继承类重新实现把接口放出来。</span><br><span class="hljs-comment">//Qt4中的QUdpSocket有bind函数是开放的，奇怪了，为何Qt4中独独QTcpSocket不开放。</span><br>TcpSocket *socket = <span class="hljs-keyword">new</span> TcpSocket(<span class="hljs-keyword">this</span>);<br>socket-&gt;setLocalAddress(QHostAddress(<span class="hljs-string">&quot;192.168.1.2&quot;</span>));<br>socket-&gt;setLocalPort(<span class="hljs-number">6005</span>);<br></code></pre></td></tr></table></figure><h3 id="169-关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯"><a href="#169-关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯" class="headerlink" title="169. 关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯"></a>169. 关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯</h3><ul><li>tcp对网卡1监听了端口6000，还可以对网卡2监听端口6000。</li><li>tcp对网卡1监听了端口6000，udp对网卡1还可以继续监听端口6000。</li><li>tcp对网卡1监听了端口6000，在网卡1上其他tcp只能监听6000以外的端口。</li><li>udp协议也是上面的逻辑。</li></ul><h3 id="174-在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5-15开始内置了setTransferTimeout来设置超时时间，非常好用"><a href="#174-在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5-15开始内置了setTransferTimeout来设置超时时间，非常好用" class="headerlink" title="174. 在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用"></a>174. 在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//局部的事件循环,不卡主界面</span><br>QEventLoop eventLoop;<br><br><span class="hljs-comment">//设置超时 5.15开始自带了超时时间函数 默认30秒</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,15,0))</span><br>manager-&gt;setTransferTimeout(timeout);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>QTimer timer;<br>connect(&amp;timer, SIGNAL(timeout()), &amp;eventLoop, SLOT(quit()));<br>timer.setSingleShot(<span class="hljs-literal">true</span>);<br>timer.start(timeout);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>QNetworkReply *reply = manager-&gt;get(QNetworkRequest(QUrl(url)));<br>connect(reply, SIGNAL(finished()), &amp;eventLoop, SLOT(quit()));<br>eventLoop.exec();<br><br><span class="hljs-keyword">if</span> (reply-&gt;bytesAvailable() &gt; <span class="hljs-number">0</span> &amp;&amp; reply-&gt;error() == QNetworkReply::NoError) &#123;<br>    <span class="hljs-comment">//读取所有数据保存成文件</span><br>    QByteArray data = reply-&gt;readAll();<br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(dirName + fileName)</span></span>;<br>    <span class="hljs-keyword">if</span> (file.open(QFile::WriteOnly | QFile::Truncate)) &#123;<br>        file.write(data);<br>        file.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="30-QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV-Filters安装即可（k-lite或者LAV-Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）"><a href="#30-QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV-Filters安装即可（k-lite或者LAV-Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）" class="headerlink" title="30. QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）"></a>30. QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）</h3><h3 id="41-如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库"><a href="#41-如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库" class="headerlink" title="41. 如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库"></a>41. 如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QSqlDatabase db = QSqlDatabase::addDatabase(<span class="hljs-string">&quot;QSQLITE&quot;</span>);<br>db.setDatabaseName(<span class="hljs-string">&quot;:memory:&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="49-QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据"><a href="#49-QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据" class="headerlink" title="49. QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据"></a>49. QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据</h3><p>如果数据量很小，也可以采用如下方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//主动加载所有数据,不然获取到的行数&lt;=256</span><br><span class="hljs-keyword">while</span>(model-&gt;canFetchMore()) &#123;<br>    model-&gt;fetchMore();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="62-对于大段的注释代码，建议用-if-0-endif-将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是-if-0则只要把0改成1即可，开发效率提升很多"><a href="#62-对于大段的注释代码，建议用-if-0-endif-将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是-if-0则只要把0改成1即可，开发效率提升很多" class="headerlink" title="62. 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多"></a>62. 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多</h3><h3 id="88-Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private-widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT-gui-private才能使用"><a href="#88-Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private-widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT-gui-private才能使用" class="headerlink" title="88. Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用"></a>88. Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;QtGui/private/qzipreader_p.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;QtGui/private/qzipwriter_p.h&quot;</span></span><br><br><span class="hljs-function">QZipReader <span class="hljs-title">reader</span><span class="hljs-params">(dirPath)</span></span>;<br><span class="hljs-function">QString <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br><span class="hljs-comment">//解压文件夹到当前目录</span><br>reader.extractAll(path);<br><span class="hljs-comment">//文件夹名称</span><br>QZipReader::FileInfo fileInfo = reader.entryInfoAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//解压文件</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(filePath)</span></span>;<br>file.open(QIODevice::WriteOnly);<br>file.write(reader.fileData(QString::fromLocal8Bit(<span class="hljs-string">&quot;%1&quot;</span>).arg(filePath)));<br>file.close();<br>reader.close();<br><br>QZipWriter *writer = <span class="hljs-keyword">new</span> QZipWriter(dirPath);<br><span class="hljs-comment">//添加文件夹</span><br>writer-&gt;addDirectory(unCompress);<br><span class="hljs-comment">//添加文件</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(filePath)</span></span>;<br>file.open(QIODevice::ReadOnly);<br>writer-&gt;addFile(data, file.readAll());<br>file.close();<br>writer-&gt;close();<br></code></pre></td></tr></table></figure><h3 id="91-数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题"><a href="#91-数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题" class="headerlink" title="91. 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题"></a>91. 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题</h3><h3 id="105-MSVC编译器的选择说明"><a href="#105-MSVC编译器的选择说明" class="headerlink" title="105. MSVC编译器的选择说明"></a>105. MSVC编译器的选择说明</h3><ul><li>如果是32位的Qt则编译器选择x86开头的</li><li>如果是64位的Qt则编译器选择amd64开头的</li><li>具体是看安装的Qt构建套件版本以及目标运行平台的系统位数和架构</li><li>一般现在的电脑默认以64位的居多，选择amd64即可</li><li>如果用户需要兼容32位的系统则建议选择32位的Qt，这样即可在32位也可以在64位系统运行</li><li>诸葛大佬补充：x86/x64都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。</li></ul><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>x86</td><td>32/64位系统上编译在32/64位系统上运行</td></tr><tr><td>x86_amd64</td><td>32/64位系统上编译在64位系统上运行</td></tr><tr><td>x86_arm</td><td>32/64位系统上编译在arm系统上运行</td></tr><tr><td>amd64</td><td>64位系统上编译在64位系统上运行</td></tr><tr><td>amd64_x86</td><td>64位系统上编译在32/64位系统上运行</td></tr><tr><td>amd64_arm</td><td>64位系统上编译在arm系统上运行</td></tr></tbody></table><h3 id="116-c-11新引入了原始字符串格式，用户避免在字符串中加入转义字符-，可以用于表示json字符串等场景"><a href="#116-c-11新引入了原始字符串格式，用户避免在字符串中加入转义字符-，可以用于表示json字符串等场景" class="headerlink" title="116. c++11新引入了原始字符串格式，用户避免在字符串中加入转义字符\，可以用于表示json字符串等场景"></a>116. c++11新引入了原始字符串格式，用户避免在字符串中加入转义字符\，可以用于表示json字符串等场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString s1 = <span class="hljs-string">R&quot;(test\001.jpg)&quot;</span>;<br>s1.replace(<span class="hljs-string">&quot;\\&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>);<br>qDebug()&lt;&lt; s1;<br><span class="hljs-comment">//结果 test#001.jpg</span><br></code></pre></td></tr></table></figure><h3 id="120-用QSettings设置注册表，如果不是管理员身份运行会打印-QSettings-failed-to-set-subkey-“xxx”-拒绝访问。-，你需要手动鼠标右键管理员身份运行就可以"><a href="#120-用QSettings设置注册表，如果不是管理员身份运行会打印-QSettings-failed-to-set-subkey-“xxx”-拒绝访问。-，你需要手动鼠标右键管理员身份运行就可以" class="headerlink" title="120. 用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey “xxx” (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以"></a>120. 用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey “xxx” (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以</h3><h3 id="129-Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理"><a href="#129-Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理" class="headerlink" title="129. Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理"></a>129. Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//主窗体头文件</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">nativeEvent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QByteArray &amp;eventType, <span class="hljs-keyword">void</span> *message, <span class="hljs-keyword">long</span> *result)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">winEvent</span><span class="hljs-params">(MSG *message, <span class="hljs-keyword">long</span> *result)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//主窗体实现函数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">frmMain::nativeEvent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QByteArray &amp;eventType, <span class="hljs-keyword">void</span> *message, <span class="hljs-keyword">long</span> *result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (eventType == <span class="hljs-string">&quot;windows_generic_MSG&quot;</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br>        MSG *msg = <span class="hljs-keyword">static_cast</span>&lt;MSG *&gt;(message);<br>        <span class="hljs-comment">//qDebug() &lt;&lt; TIMEMS &lt;&lt; msg-&gt;message;</span><br>        <span class="hljs-keyword">if</span> (msg-&gt;wParam == PBT_APMSUSPEND &amp;&amp; msg-&gt;message == WM_POWERBROADCAST) &#123;<br>            <span class="hljs-comment">//系统休眠的时候自动最小化可以规避程序可能出现的问题</span><br>            <span class="hljs-keyword">this</span>-&gt;showMinimized();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg-&gt;wParam == PBT_APMRESUMEAUTOMATIC) &#123;<br>            <span class="hljs-comment">//休眠唤醒后自动打开</span><br>            <span class="hljs-keyword">this</span>-&gt;showNormal();<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eventType == <span class="hljs-string">&quot;NSEvent&quot;</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_MACOS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">frmMain::winEvent</span><span class="hljs-params">(MSG *message, <span class="hljs-keyword">long</span> *result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> nativeEvent(<span class="hljs-string">&quot;windows_generic_MSG&quot;</span>, message, result);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="135-Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件"><a href="#135-Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件" class="headerlink" title="135. Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件"></a>135. Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//设置了编码以后配置文件内容为 Company=上海物联网技术研究中心</span><br><span class="hljs-comment">//没有设置编码则配置文件内容为 Company=\xe4\xb8\x8a\xe6\xb5\xb7\xe7\x89\xa9\xe8\x81\x94\xe7\xbd\x91\xe6\x8a\x80\xe6\x9c\xaf\xe7\xa0\x94\xe7\xa9\xb6\xe4\xb8\xad\xe5\xbf\x83</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">App::readConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QSettings <span class="hljs-title">set</span><span class="hljs-params">(App::ConfigFile, QSettings::IniFormat)</span></span>;<br>    <span class="hljs-built_in">set</span>.setIniCodec(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>    <span class="hljs-built_in">set</span>.beginGroup(<span class="hljs-string">&quot;AppConfig1&quot;</span>);<br>    App::Company = <span class="hljs-built_in">set</span>.value(<span class="hljs-string">&quot;Company&quot;</span>, App::Company).toString();<br>    <span class="hljs-built_in">set</span>.endGroup();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">App::writeConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QSettings <span class="hljs-title">set</span><span class="hljs-params">(App::ConfigFile, QSettings::IniFormat)</span></span>;<br>    <span class="hljs-built_in">set</span>.setIniCodec(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>    <span class="hljs-built_in">set</span>.beginGroup(<span class="hljs-string">&quot;AppConfig1&quot;</span>);<br>    <span class="hljs-built_in">set</span>.setValue(<span class="hljs-string">&quot;Company&quot;</span>, App::Company);<br>    <span class="hljs-built_in">set</span>.endGroup();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="137-Qt重载qDebug输出自定义的信息"><a href="#137-Qt重载qDebug输出自定义的信息" class="headerlink" title="137. Qt重载qDebug输出自定义的信息"></a>137. Qt重载qDebug输出自定义的信息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FunctionInfo</span> &#123;</span><br>    QString function;<br>    QString name;<br>    QString groupEnabled;<br>    QString action;<br>    QString group;<br><br>    <span class="hljs-keyword">friend</span> QDebug <span class="hljs-keyword">operator</span> &lt;&lt; (QDebug debug, <span class="hljs-keyword">const</span> FunctionInfo &amp;functionInfo) &#123;<br>        QString info = QString(<span class="hljs-string">&quot;功能: %1  名称: %2  启用: %3  方法: %4  分组: %5&quot;</span>)<br>                       .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled)<br>                       .arg(functionInfo.action).arg(functionInfo.group);<br>        debug &lt;&lt; info;<br>        <span class="hljs-keyword">return</span> debug;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="144-关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论"><a href="#144-关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论" class="headerlink" title="144. 关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论"></a>144. 关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论</h3><ul><li>Qt在二进制兼容这块，已经做了最大的努力，通过将各种代码细节隐藏，Q指针+D指针技巧，尽量保持了接口的统一；</li><li>是否兼容最主要考虑编译器的因素，毕竟任何Qt版本都是需要通过编译器编译成对应的二进制文件，由他说了算。如果两个Qt版本采用的编译器版本一样，极大概率可执行文件是兼容的，比如 Qt5.10+msvc2015 32 位 和 Qt5.11+msvc2015 32位 编译出来的可执行文件，都用Qt5.11的库是可行的；</li><li>mingw编译器的Qt版本也是如此，就是因为Qt官方安装包集成的mingw编译器一直在更新（极少附近版本没有更新mingw编译器版本除外），比如5.7用的mingw53，5.12用的mingw73，5.15用的mingw81，因为带的Qt库也是这个编译器编译出来的，所以导致看起来全部不兼容；</li><li>如果想要完全兼容，还有一个注意要素，那就是对应代码使用的类的头文件接口是否变了，按道理原有的接口极少会变，一般都是新增加，或者大版本才会改变，比如Qt4-Qt5-Qt6这种肯定没法兼容的，接口和模块都变了；</li><li>大胆的猜测：如果Qt5.6到Qt5.15你全部用一种编译器比如mingw73或者msvc2015重新编译生成对应的Qt运行库，然后在此基础上开发程序，最后生成的可执行文件用Qt5.15的库是都可以的，这样就轻松跨越了多个版本兼容；</li><li>大胆的建议：在附近的几个版本统一编译器，比如5.6-5.12之间就统一用mingw53或者msvc2015,5.12-5.15统一用msvc2017，要尝鲜其他编译器的可以自行源码编译其他版本，这样最起码附近的一大段版本（大概2-3年的版本周期）默认就兼容了。</li><li>本人测试的是widget部分，qml未做测试，不清楚是否机制一样；</li></ul><h3 id="154-在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论"><a href="#154-在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论" class="headerlink" title="154. 在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论"></a>154. 在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论</h3><ul><li>Qt天生内置了sqlite数据库，只需要发布的时候带上插件就行（可以看到插件动态库文件比其他几种都要大，那是因为直接将数据库的源码都编译进去了，而其他只编译了中间通信交互的插件源码），其他数据库要么还要带上动态库，要么还需要创建数据源；</li><li>速度上，绝对无与伦比的出类拔萃，同样的数据库结构（表结构、索引等完全一致），查询速度和批量更新速度、数据库事务等，速度都是其他几种的至少3倍以上，而且随着数据量的增大对比越发明显；</li><li>几千万的数据量完全没问题，而且速度和性能都还可以，不要以讹传讹网上部分菜鸡说的不支持百万以上的数据量，本人亲测亿级别，数据量建议千万级别以下，着重注意数据库表和索引的设计；</li><li>其他数据库还要注意版本的区别，ODBC数据源形式还容易出错和执行失败；</li><li>sqlite数据库也有几个重大缺点：不支持加密，不支持网络访问，不支持部分数据库高级特性，不支持海量数据（亿级别以上），但是对于绝大部分Qt项目还是足够；</li><li>数据库支持友好度大致是 sqlite &gt; postgresql &gt; mysql &gt; odbc ;</li><li>以上都是在Qt环境中个人测试得出的结论，结果未必正确，作为参考即可，其他编程环境比如C#、JAVA请忽略，也许差别可能在中间通信的效率造成的；</li></ul><h3 id="170-开源的图表控件QCustomPlot很经典，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点"><a href="#170-开源的图表控件QCustomPlot很经典，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点" class="headerlink" title="170. 开源的图表控件QCustomPlot很经典，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点"></a>170. 开源的图表控件QCustomPlot很经典，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点</h3><ul><li>可以将XY轴对调，然后形成横向的效果，无论是曲线图还是柱状图，分组图、堆积图等，都支持这个特性。</li><li>不需要的提示图例可以调用 legend-&gt;removeItem 进行移除。</li><li>两条曲线可以调用 setChannelFillGraph 设置合并为一个面积区域。</li><li>可以关闭抗锯齿 setAntialiased 加快绘制速度。</li><li>可以设置不同的线条样式（setLineStyle）、数据样式（setScatterStyle）。</li><li>坐标轴的箭头样式可更换 setUpperEnding。</li><li>可以用 QCPBarsGroup 实现柱状分组图，这个类在官方demo中没有，所以非常容易忽略。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对调XY轴，在最前面设置</span><br>QCPAxis *yAxis = customPlot-&gt;yAxis;<br>QCPAxis *xAxis = customPlot-&gt;xAxis;<br>customPlot-&gt;xAxis = yAxis;<br>customPlot-&gt;yAxis = xAxis;<br><br><span class="hljs-comment">//移除图例</span><br>customPlot-&gt;legend-&gt;removeItem(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//合并两个曲线画布形成封闭区域</span><br>customPlot-&gt;graph(<span class="hljs-number">0</span>)-&gt;setChannelFillGraph(customPlot-&gt;graph(<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//关闭抗锯齿以及设置拖动的时候不启用抗锯齿</span><br>customPlot-&gt;graph()-&gt;setAntialiased(<span class="hljs-literal">false</span>);<br>customPlot-&gt;setNoAntialiasingOnDrag(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//多种设置数据的方法</span><br>customPlot-&gt;graph(<span class="hljs-number">0</span>)-&gt;setData();<br>customPlot-&gt;graph(<span class="hljs-number">0</span>)-&gt;data()-&gt;<span class="hljs-built_in">set</span>();<br><br><span class="hljs-comment">//设置不同的线条样式、数据样式</span><br>customPlot-&gt;graph()-&gt;setLineStyle(QCPGraph::lsLine);<br>customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle::ssDot);<br>customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(shapes.at(i), <span class="hljs-number">10</span>));<br><br><span class="hljs-comment">//还可以设置为图片或者自定义形状</span><br>customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(QPixmap(<span class="hljs-string">&quot;./sun.png&quot;</span>)));<br>QPainterPath customScatterPath;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    customScatterPath.cubicTo(qCos(<span class="hljs-number">2</span> * M_PI * i / <span class="hljs-number">3.0</span>) * <span class="hljs-number">9</span>, qSin(<span class="hljs-number">2</span> * M_PI * i / <span class="hljs-number">3.0</span>) * <span class="hljs-number">9</span>, qCos(<span class="hljs-number">2</span> * M_PI * (i + <span class="hljs-number">0.9</span>) / <span class="hljs-number">3.0</span>) * <span class="hljs-number">9</span>, qSin(<span class="hljs-number">2</span> * M_PI * (i + <span class="hljs-number">0.9</span>) / <span class="hljs-number">3.0</span>) * <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br>customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(customScatterPath, QPen(Qt::black, <span class="hljs-number">0</span>), QColor(<span class="hljs-number">40</span>, <span class="hljs-number">70</span>, <span class="hljs-number">255</span>, <span class="hljs-number">50</span>), <span class="hljs-number">10</span>));<br><br><span class="hljs-comment">//更换坐标轴的箭头样式</span><br>customPlot-&gt;xAxis-&gt;setUpperEnding(QCPLineEnding::esSpikeArrow);<br>customPlot-&gt;yAxis-&gt;setUpperEnding(QCPLineEnding::esSpikeArrow);<br><br><span class="hljs-comment">//设置背景图片</span><br>customPlot-&gt;axisRect()-&gt;setBackground(QPixmap(<span class="hljs-string">&quot;./solarpanels.jpg&quot;</span>));<br><span class="hljs-comment">//画布也可以设置背景图片</span><br>customPlot-&gt;graph(<span class="hljs-number">0</span>)-&gt;setBrush(QBrush(QPixmap(<span class="hljs-string">&quot;./balboa.jpg&quot;</span>)));<br><span class="hljs-comment">//整体可以设置填充颜色或者图片</span><br>customPlot-&gt;setBackground(QBrush(gradient));<br><span class="hljs-comment">//设置零点线条颜色</span><br>customPlot-&gt;xAxis-&gt;grid()-&gt;setZeroLinePen(Qt::NoPen);<br><span class="hljs-comment">//控制是否鼠标滚轮缩放拖动等交互形式</span><br>customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);<br><br><span class="hljs-comment">//柱状分组图</span><br>QCPBarsGroup *group = <span class="hljs-keyword">new</span> QCPBarsGroup(customPlot);<br>QList&lt;QCPBars*&gt; bars;<br>bars &lt;&lt; fossil &lt;&lt; nuclear &lt;&lt; regen;<br>foreach (QCPBars *bar, bars) &#123;<br>    <span class="hljs-comment">//设置柱状图的宽度大小</span><br>    bar-&gt;setWidth(bar-&gt;width() / bars.size());<br>    group-&gt;append(bar);<br>&#125;<br><span class="hljs-comment">//设置分组之间的间隔</span><br>group-&gt;setSpacing(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="180-QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯"><a href="#180-QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯" class="headerlink" title="180. QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯"></a>180. QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//实例化数据库表模型</span><br>QSqlTableModel *model = <span class="hljs-keyword">new</span> QSqlTableModel(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//指定表名</span><br>model-&gt;setTable(<span class="hljs-string">&quot;table&quot;</span>);<br><span class="hljs-comment">//设置列排序</span><br>model-&gt;setSort(<span class="hljs-number">0</span>, Qt::AscendingOrder);<br><span class="hljs-comment">//设置提交模式</span><br>model-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit);<br><span class="hljs-comment">//立即查询一次</span><br>model-&gt;select();<br><span class="hljs-comment">//将数据库表模型设置到表格上</span><br>ui-&gt;tableView-&gt;setModel(model);<br><br><span class="hljs-comment">//测试发现过滤条件中除了可以带where语句还可以带排序及limit等</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 order by id desc limit 100&quot;</span>);<br><br><span class="hljs-comment">//如果在过滤条件中设置了排序语句则不可以再使用setSort方法</span><br><span class="hljs-comment">//下面的代码结果是执行出错，可能因为setSort又重新增加了order by语句导致多个order by语句冲突了。</span><br>model-&gt;setSort(<span class="hljs-number">0</span>, Qt::AscendingOrder);<br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 order by id desc limit 100&quot;</span>);<br><br><span class="hljs-comment">//通过setFilter设置单纯的where语句可以不用加1=1</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;name=&#x27;张三&#x27;&quot;</span>);<br><span class="hljs-comment">//如果还有其他语句比如排序或者limit等则需要最前面加上1=1</span><br><span class="hljs-comment">//下面表示按照id升序排序，查询结果显示第5-15条记录。</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 order by id asc limit 5,10&quot;</span>);<br><br><span class="hljs-comment">//多个条件用and连接</span><br><span class="hljs-comment">//建议任何时候用了setFilter则最前面写1=1最末尾加上 ; 防止有些地方无法正确执行。</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 and name=&#x27;张三&#x27; and result&gt;=70;&quot;</span>);<br><br><span class="hljs-comment">//下面表示查询姓名是张三的记录，按照id字段降序排序，结果从第10条开始100条，相当于从第10条到110条记录。</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 and name=&#x27;张三&#x27; order by id desc limit 10,100;&quot;</span>);<br><br><span class="hljs-comment">//在第3行开始添加一条记录</span><br>model-&gt;insertRow(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//立即填充刚刚新增加的行，默认为空需要用户手动在表格中输入。</span><br>model-&gt;setData(model-&gt;index(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>), <span class="hljs-number">100</span>);<br>model-&gt;setData(model-&gt;index(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), <span class="hljs-string">&quot;张三&quot;</span>);<br><span class="hljs-comment">//提交更新</span><br>model-&gt;submitAll();<br><br><span class="hljs-comment">//删除第4行</span><br>model-&gt;removeRow(<span class="hljs-number">3</span>);<br>model-&gt;submitAll();<br><br><span class="hljs-comment">//总之有增删改操作后都需要调用model-&gt;submitAll();来真正执行，否则仅仅是数据模型更新了数据，并不会更新到数据库中。</span><br><br><span class="hljs-comment">//撤销更改</span><br>model-&gt;revertAll();<br></code></pre></td></tr></table></figure><h3 id="183-自从c-11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记"><a href="#183-自从c-11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记" class="headerlink" title="183. 自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记"></a>183. 自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记</h3><ul><li>代码格式：<a href="parameters">capture</a> mutable -&gt;return-type {statement}</li><li>[capture]：捕捉列表，捕捉列表总是出现在Lambda函数的开始处，实际上，[]是Lambda引出符，编译器根据该引出符判断接下来的代码是否是Lambda函数，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用。</li><li>(parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号 () 一起省略。</li><li>mutable：mutable修饰符，默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</li><li>-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型，我们可以在不需要返回值的时候也可以连同符号 -&gt; 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li><li>{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li></ul><p>捕捉列表有以下几种形式：</p><ul><li>[var]表示值传递方式捕捉变量var。</li><li>[=]表示值传递方式捕捉所有父作用域的变量（包括this）。</li><li>[&amp;var]表示引用传递捕捉变量var。</li><li>[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）。</li><li>[this]表示值传递方式捕捉当前的this指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MainWindow::MainWindow(QWidget *parent)<br>    : QMainWindow(parent)<br>    , ui(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">//按钮单击不带参数</span><br>    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [] &#123;<br>        qDebug() &lt;&lt; <span class="hljs-string">&quot;hello lambda&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-comment">//按钮单击带参数</span><br>    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [] (<span class="hljs-keyword">bool</span> isCheck) &#123;<br>        qDebug() &lt;&lt; <span class="hljs-string">&quot;hello lambda&quot;</span> &lt;&lt; isCheck;<br>    &#125;);<br><br>    <span class="hljs-comment">//自定义信号带参数</span><br>    connect(<span class="hljs-keyword">this</span>, &amp;MainWindow::sig_test, [] (<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) &#123;<br>        qDebug() &lt;&lt; <span class="hljs-string">&quot;hello lambda&quot;</span> &lt;&lt; i &lt;&lt; j;<br>    &#125;);<br><br>    <span class="hljs-function">emit <span class="hljs-title">sig_test</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式模式与Qt信号槽</title>
    <link href="/noob/2022/01/09/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E4%BF%A1%E5%8F%B7%E6%A7%BD/"/>
    <url>/noob/2022/01/09/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E4%BF%A1%E5%8F%B7%E6%A7%BD/</url>
    
    <content type="html"><![CDATA[<p>填坑中。。。不填了，参见陈硕《Linux多线程服务端编程：使用muduo C++网络库》第一章</p>]]></content>
    
    
    <categories>
      
      <category>设计模式与Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QProcess调用外部程序-以截图软件Snipaste为例</title>
    <link href="/noob/2022/01/09/QProcess%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F-%E4%BB%A5%E6%88%AA%E5%9B%BE%E8%BD%AF%E4%BB%B6Snipaste%E4%B8%BA%E4%BE%8B/"/>
    <url>/noob/2022/01/09/QProcess%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F-%E4%BB%A5%E6%88%AA%E5%9B%BE%E8%BD%AF%E4%BB%B6Snipaste%E4%B8%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>QProcess调用外部程序两种方式的比较，以及路径空格问题的处理</p><span id="more"></span><p>参见项目示例<br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox/blob/master/ScreenShotWidget/ScreenShotWidget.py">github</a><br><a href="https://gitee.com/yuque/PyQtWidgetToyBox/blob/master/ScreenShotWidget/ScreenShotWidget.py">gitee</a></p></blockquote><p>有时需要调用外部程序，可通过QProcess实现该功能，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//代码0    </span><br>QProcess::startDetached(<span class="hljs-string">&quot;Snipaste/Snipaste.exe&quot;</span>) <span class="hljs-comment">//启动Snipaste</span><br>   QProcess::startDetached(<span class="hljs-string">&quot;Snipaste/Snipaste.exe&quot;</span> + <span class="hljs-string">&quot; snip&quot;</span>) <span class="hljs-comment">//执行截图命令</span><br>   <span class="hljs-comment">//QProcess::startDetached(&quot;\&quot;Snip  aste/Snipaste.exe\&quot;&quot; + &quot; snip&quot;) //路径中可以有空格</span><br><br></code></pre></td></tr></table></figure><p>注意：路径中不可有空格，详见下文。</p><h2 id="QProcess中的start-和startDetached-区别"><a href="#QProcess中的start-和startDetached-区别" class="headerlink" title="QProcess中的start()和startDetached()区别"></a><code>QProcess</code>中的<code>start()</code>和<code>startDetached()</code>区别</h2><ol><li><code>void QProcess::start()</code> 启动后， 外部程序将随主程序的退出而退出。</li><li><code>void QProcess:: startDetached()</code> 启动后，当主程序退出时外部程序并不退出，而是继续运行。</li></ol><h2 id="外部程序路径中不能带空格"><a href="#外部程序路径中不能带空格" class="headerlink" title="外部程序路径中不能带空格"></a>外部程序路径中不能带空格</h2><p>原因：QProcess会将路径当作命令，以空格进行分割。</p><h3 id="方法1-调用其他重载："><a href="#方法1-调用其他重载：" class="headerlink" title="方法1-调用其他重载："></a>方法1-调用其他重载：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;program, </span></span><br><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">const</span> QStringList &amp;arguments, </span></span><br><span class="hljs-function"><span class="hljs-params">           QIODevice::OpenMode mode)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">QProcess process;<br>process.start(<span class="hljs-string">&quot;\&quot;C:/Users/Tmp/Test Demo.exe\&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="方法2-调用以下重载并将路径配合转义-字符："><a href="#方法2-调用以下重载并将路径配合转义-字符：" class="headerlink" title="方法2 - 调用以下重载并将路径配合转义\字符："></a>方法2 - 调用以下重载并将路径配合转义<code>\</code>字符：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;command, QIODevice::OpenMode mode)</span></span><br></code></pre></td></tr></table></figure><p>示例见<code>代码0    </code>注释部分。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://cloud.tencent.com/developer/article/1464452">Qt君</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QProcess</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QProcess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QWebEngineView路径问题-将HTML/JS/CSS添加到qrc文件中</title>
    <link href="/noob/2022/01/02/QWebEngineView%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-%E5%B0%86HTML-JS-CSS%E6%B7%BB%E5%8A%A0%E5%88%B0qrc%E6%96%87%E4%BB%B6%E4%B8%AD/"/>
    <url>/noob/2022/01/02/QWebEngineView%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98-%E5%B0%86HTML-JS-CSS%E6%B7%BB%E5%8A%A0%E5%88%B0qrc%E6%96%87%E4%BB%B6%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<blockquote><p>通过QRC管理HTML/JS/CSS文件</p></blockquote><span id="more"></span><p>在<a href="https://yuque.gitee.io/noob/2021/10/30/QWebEngineView-C%E5%92%8Cjs%E4%BA%A4%E4%BA%92/">gitee-QWebEngineView C++和js交互</a> / <a href="https://noobplusplus.github.io/2021/10/30/QWebEngineView-C%E5%92%8Cjs%E4%BA%A4%E4%BA%92/">github-QWebEngineView C++和js交互</a> 中介绍了QWebEngine，QWebChannel的简单使用。</p><p>将<code>HTML/JS/CSS</code>文件放入到程序执行目录中，其主要代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">QWebEngineView* view = <span class="hljs-keyword">new</span> QWebEngineView(<span class="hljs-keyword">this</span>);<br>view-&gt;load(QUrl::fromLocalFile(qApp-&gt;applicationDirPath() + <span class="hljs-string">&quot;/test.html&quot;</span>));<br>view-&gt;show();<br></code></pre></td></tr></table></figure><ol><li><p>不方便<code>git</code>管理。</p></li><li><p>客户可以查看/修改前端代码。</p></li></ol><p>可通过将<code>HTML/JS/CSS</code>文件放入qrc中解决改问题。先将相关文件添加到<code>qrc</code>中，然后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">view-&gt;load(QUrl(<span class="hljs-string">&quot;qrc:/test.html&quot;</span>));<br></code></pre></td></tr></table></figure><ol><li>需要将<code>HTML/JS/CSS</code>文件都放入到qrc中，而不是只放HTML文件。</li><li>直接使用<code>qrc:</code>形式的路径，不要使用<code>QUrl::fromLocalFile(&quot;qrc:/test.html&quot;)</code>。</li></ol><p><strong>清理缓存：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">QWebEngineView* view = <span class="hljs-keyword">new</span> QWebEngineView(<span class="hljs-keyword">this</span>);<br><br>QWebEngineSettings * webEngineSettings = view-&gt;settings();<br>webEngineSettings-&gt;setAttribute(QWebEngineSettings::LocalStorageEnabled, <span class="hljs-literal">false</span>);<br>QWebEngineProfile * engineProfile = view-&gt;page()-&gt;profile();<br>engineProfile-&gt;clearHttpCache();<br>QString cachePath = engineProfile-&gt;cachePath();<br><span class="hljs-function">QDir <span class="hljs-title">cachePathDir</span><span class="hljs-params">(cachePath)</span></span>;<br><span class="hljs-keyword">if</span> (cachePathDir.exists()) &#123;<br>cachePathDir.removeRecursively();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QWebEngine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QWebEngine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deepin20.3安装Qt后Qt Creator后打不开的问题</title>
    <link href="/noob/2021/12/25/Deepin20-3%E5%AE%89%E8%A3%85Qt%E5%90%8EQtCreator%E5%90%8E%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/noob/2021/12/25/Deepin20-3%E5%AE%89%E8%A3%85Qt%E5%90%8EQtCreator%E5%90%8E%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>依赖库的命名问题，特此记录</p></blockquote><span id="more"></span><p>今天想看一个开源C++项目，心想安装Qt，通过Qt Creator打开、调试该项目。<br>结果一通操作后，双击运行Qt Creator毫无反应，终端运行报错。<br>网上搜了下，发现是依赖库的命名问题，这个依赖库不叫libxcb-util.so.1，而是叫libxcb-util.so.0。<br>解决方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>sudo ln -s /usr/lib/x86_64-linux-gnu/libxcb-util.so.0.0.0 /usr/lib/x86_64-linux-gnu/libxcb-util.so.1<br><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/weixin_42111284/article/details/119843984">CSDN</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt实现懒加载</title>
    <link href="/noob/2021/12/22/PyQt%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/noob/2021/12/22/PyQt%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<blockquote><p> PyQt通过 QStackedLayout/Dict 实现懒加载<br>参见项目示例<br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox/blob/master/LazyTabPane/LazyTabPane.py">github</a><br><a href="https://gitee.com/yuque/PyQtWidgetToyBox/blob/master/LazyTabPane/LazyTabPane.py">gitee</a></p></blockquote><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>为了学习PyQt，新建了个练手项目，每一个小主题一个tab页。<br>部分页面初始化时，需要Http请求、绘制图表，耗时较长。随着页面的增多，加载越来越慢。<br><img src="20211222204945.jpg"></p><h2 id="原实现方式"><a href="#原实现方式" class="headerlink" title="原实现方式"></a>原实现方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TabPane</span>(<span class="hljs-params">QFrame</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, buttonNameTuple, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(parent)<br>        self.mainStackedLayout = QStackedLayout(self)<br>        self.mainStackedLayout.setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(buttonNameTuple)):<br>            page = self.__pageFactory(buttonNameTuple[i][<span class="hljs-number">1</span>]) <span class="hljs-comment">#注意1</span><br>            self.mainStackedLayout.addWidget(page) <span class="hljs-comment">#注意2</span><br><br>        self.setLayout(self.mainStackedLayout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setCurrentIndex</span>(<span class="hljs-params">self, index</span>):</span><br>        self.mainStackedLayout.setCurrentIndex(index)<br><br></code></pre></td></tr></table></figure><ol><li>通过工厂函数<code>__pageFactory()</code>产生页面示例，详见<a href="https://yuque.gitee.io/noob/2021/12/15/python-%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/">python 反射实现简单工厂</a>/<a href="https://noobplusplus.github.io/2021/12/15/python-%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/">python 反射实现简单工厂</a></li><li>初始化时，将每个页面都构建并添加到QStackedLayout中。随着页面的增多，加载越来越慢。</li></ol><p>之前写WPF时，用到过一个叫做懒加载<code>Lazy&lt;T&gt;</code>的东西，受其启发，自己写了个<code>LazyTabPane</code>。</p><h2 id="懒加载-LazyTabPane"><a href="#懒加载-LazyTabPane" class="headerlink" title="懒加载(LazyTabPane)"></a>懒加载(LazyTabPane)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyTabPane</span>(<span class="hljs-params">QFrame</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, firstPageName, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(parent)<br>        self.__mainStackedLayout = QStackedLayout(self)<br>        self.__mainStackedLayout.setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        self.__pageDict = &#123;&#125;<br>        self.__addWidget(firstPageName)  <br>        self.setLayout(self.__mainStackedLayout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setCurrentPage</span>(<span class="hljs-params">self, pageName</span>):</span><br>        pageIndex = self.__pageDict.get(pageName, -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> pageIndex == -<span class="hljs-number">1</span>:<br>            self.__addWidget(pageName)<br>            pageIndex = self.__pageDict.get(pageName)<br><br>        self.__mainStackedLayout.setCurrentIndex(pageIndex)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__addWidget</span>(<span class="hljs-params">self, pageName</span>):</span><br>        page = self.__pageFactory(pageName)<br>        self.__pageDict[pageName] = self.__mainStackedLayout.count()<br>        self.__mainStackedLayout.addWidget(page)   <br><br></code></pre></td></tr></table></figure><ol><li>只初始化第一个页面</li><li>当调用<code>setCurrentPage()</code>切换其他页面时，判断<code>__pageDict</code>中是否已存有盖页面，如果没有则通过工厂函数创建该页面。然后求出该页面的索引并切换到该页。</li><li><code>__pageDict</code>中所存的索引和界面上的顺序不同。</li></ol>]]></content>
    
    
    <categories>
      
      <category>PyQt</category>
      
      <category>QWidget</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QWidget</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python骚操作记录</title>
    <link href="/noob/2021/12/18/python%E9%AA%9A%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <url>/noob/2021/12/18/python%E9%AA%9A%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习、阅读源码时遇到的一时迷惑的python操作,记录一下<br>参见项目示例<br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox/blob/master/TabPane/TabPane.py">github</a><br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox">gitee</a></p></blockquote><span id="more"></span><p>作为一个c++菜鸡，刚开始看<code>python</code>源码，很多地方非常很习惯，比如缩进和大括号。有些地方还会折腾好久，特记录如下，以备后面查阅</p><h2 id="实现-操作符"><a href="#实现-操作符" class="headerlink" title="实现?:操作符"></a>实现<code>?:</code>操作符</h2><p>很多语言中都有<code>?:</code>操作符。<br>比如<code>C++</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">int</span> y = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> x = (y &lt; <span class="hljs-number">10</span>) ? <span class="hljs-number">30</span> : <span class="hljs-number">40</span>;<br><br></code></pre></td></tr></table></figure><p>表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">40</span>;<br><span class="hljs-keyword">if</span>(y &lt; <span class="hljs-number">10</span>)<br>&#123; <br>   x = <span class="hljs-number">30</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>刚写<code>python</code>时也是按照上面的代码写。知道阅读<code>pyside</code>示例代码<code>碰撞老鼠</code>时，看到如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>self.angle += [-<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>][self.angle &lt; -Mouse.Pi / <span class="hljs-number">2</span>]<br><br></code></pre></td></tr></table></figure><p>一度以为是矩阵运算，知道看了<code>c++</code>版示例才恍然大悟。原来<code>python</code>版的<code>?:</code>操作符可以这么实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>x = [<span class="hljs-number">30</span>, <span class="hljs-number">40</span>][y &lt; <span class="hljs-number">10</span>]<br><br></code></pre></td></tr></table></figure><p><code>python</code>的<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code> 外加<code>js</code>的<code>[]</code>、<code>&#123;&#125;</code>着急把我搞迷糊了，赶紧复习一下。。。。</p><p>项目代码<br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox/blob/master/CollidingMice/CollidingMice.py">github</a><br><a href="https://gitee.com/yuque/PyQtWidgetToyBox/blob/master/CollidingMice/CollidingMice.py">gitee</a></p><h2 id="字符串前加b-表示后面字符串是bytes类型"><a href="#字符串前加b-表示后面字符串是bytes类型" class="headerlink" title="字符串前加b, 表示后面字符串是bytes类型"></a>字符串前加<code>b</code>, 表示后面字符串是<code>bytes</code>类型</h2><p>‘PyQt’实现窗口动画,需要使用<code>QPropertyAnimation</code>类，仿造<code>c++</code>版动画代码，写出如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>animationEnter = QPropertyAnimation(self.__newYearCountDown, <span class="hljs-string">&#x27;pos&#x27;</span>, self)<br><br></code></pre></td></tr></table></figure><p>执行时候程序崩溃</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><br>TypeError: arguments did not <span class="hljs-keyword">match</span> any overloaded <span class="hljs-keyword">cal</span><span class="hljs-variable">l:</span><br>  QPropertyAnimation(paren<span class="hljs-variable">t:</span> QObject = None): too many arguments<br>  QPropertyAnimation(QObject, Union[QByteArray, bytes, bytearray], paren<span class="hljs-variable">t:</span> QObject = None): <span class="hljs-keyword">argument</span> <span class="hljs-number">2</span> <span class="hljs-built_in">has</span> unexpected <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;str&#x27;</span><br><br></code></pre></td></tr></table></figure><p><code>PyQt</code>没有<code>QString</code>类，<code>str</code>也无法隐式转换为<code>Union[QByteArray, bytes, bytearray]</code>, 需要字符串前加 <code>b</code>，表示这是一个<code>bytes</code>对象</p><p><strong>项目代码</strong><br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox/blob/master/mainwindow.py">github</a><br><a href="https://gitee.com/yuque/PyQtWidgetToyBox/blob/master/mainwindow.py">gitee</a></p><p><strong>参考文献</strong><a href="https://www.cnblogs.com/liangmingshen/p/9274021.html">博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 反射实现简单工厂</title>
    <link href="/noob/2021/12/15/python-%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
    <url>/noob/2021/12/15/python-%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>python反射、简单工厂模式<br>参见项目示例<br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox/blob/master/TabPane/TabPane.py">github</a><br><a href="https://gitee.com/yuque/PyQtWidgetToyBox/blob/master/TabPane/TabPane.py">gitee</a></p></blockquote><span id="more"></span><p>在<a href="https://yuque.gitee.io/noob/2021/05/18/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E7%B1%BB%E5%8F%8D%E5%B0%842/">简单工厂模式与Qt类反射2</a>/<a href="https://noobplusplus.github.io/2021/05/18/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E7%B1%BB%E5%8F%8D%E5%B0%842/">简单工厂模式与Qt类反射2</a>中介绍了简单工厂模式介绍、实现、优缺点以及借助Qt反射实现简单工厂模式，实现方式相当繁琐。<br>对于python这种自带反射的语言，简单工厂实现起来就相当简单了。</p><h2 id="传统简单工厂"><a href="#传统简单工厂" class="headerlink" title="传统简单工厂"></a>传统简单工厂</h2><p>传统方式实现简单工厂通常如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> Welcome.Welcome <span class="hljs-keyword">import</span> Welcome<br><span class="hljs-keyword">from</span> Covid19Charts.Covid19Charts <span class="hljs-keyword">import</span> Covid19Charts<br><span class="hljs-keyword">from</span> Covid19Map.Covid19Map <span class="hljs-keyword">import</span> Covid19Map<br><span class="hljs-comment"># 注意1</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TabPane</span>(<span class="hljs-params">QFrame</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, buttonNameTuple, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># todo</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__pageFactory</span>(<span class="hljs-params">self, name</span>):</span> <span class="hljs-comment"># 注意2，此处name换成枚举更好</span><br>       <span class="hljs-keyword">if</span> name == <span class="hljs-string">&#x27;Welcome&#x27;</span>:<br>           <span class="hljs-keyword">return</span> Welcome(self)<br>       <span class="hljs-keyword">elif</span> name == <span class="hljs-string">&#x27;Covid19Charts&#x27;</span>:<br>           <span class="hljs-keyword">return</span> Covid19Charts(self)<br>       <span class="hljs-keyword">elif</span> name == <span class="hljs-string">&#x27;Covid19Map&#x27;</span>:<br>           <span class="hljs-keyword">return</span> Covid19Map(self)<br>       <span class="hljs-keyword">elif</span> name == <span class="hljs-string">&#x27;Covid19GeneralView&#x27;</span>:<br>           <span class="hljs-keyword">return</span> Covid19GeneralView(self)<br><br></code></pre></td></tr></table></figure><p>通常的做法是<code>import</code>一堆，然后根据不同的情况，<code>new</code>出不同的实例。<br>如<a href="https://yuque.gitee.io/noob/2021/05/29/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84if%E2%80%A6else%E6%9D%82%E8%B0%881/">代码中的if…else杂谈1</a>/<a href="https://noobplusplus.github.io/2021/05/29/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84if%E2%80%A6else%E6%9D%82%E8%B0%881/">代码中的if…else杂谈1</a>中所说这种写法不符合面向对象的<code>开闭原则</code>。</p><h2 id="反射实现简单工厂"><a href="#反射实现简单工厂" class="headerlink" title="反射实现简单工厂"></a>反射实现简单工厂</h2><p>python 反射实现简单工厂相当简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TabPane</span>(<span class="hljs-params">QFrame</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, buttonNameTuple, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># todo</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__pageFactory</span>(<span class="hljs-params">self, name</span>):</span><br>        <span class="hljs-comment"># import</span><br>        page = <span class="hljs-built_in">__import__</span>(name + <span class="hljs-string">&quot;.&quot;</span> + name, fromlist=[name])<br>        <span class="hljs-comment"># 实例化，获取方法</span><br>        pageClass = <span class="hljs-built_in">getattr</span>(page, name)<br>        <span class="hljs-keyword">return</span> pageClass(self)<br><br></code></pre></td></tr></table></figure><p>来自<code>C++</code>程序员的羡慕。。。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QML WebEngineView 和 js 交互</title>
    <link href="/noob/2021/12/11/QML-WebEngineView-%E5%92%8C-js-%E4%BA%A4%E4%BA%92/"/>
    <url>/noob/2021/12/11/QML-WebEngineView-%E5%92%8C-js-%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>QML WebEngine，WebChannel简单使用。</p><p>参见项目示例<br><a href="https://github.com/noobPlusPlus/PySideQMLToyBox/blob/master/Covid19Map/Covid19Map.qml">github</a><br><a href="https://gitee.com/yuque/PySideQMLToyBox/blob/master/Covid19Map/Covid19Map.qml">gitee</a></p><span id="more"></span></blockquote><p>和<a href="https://yuque.gitee.io/noob/2021/10/30/QWebEngineView-C%E5%92%8Cjs%E4%BA%A4%E4%BA%92/">QWebEngineView C++和js交互</a>思路类似，但是代码更简洁，纯QML/js代码，无需使用C++/python代码</p><h2 id="0-WebEngineView"><a href="#0-WebEngineView" class="headerlink" title="0. WebEngineView"></a>0. WebEngineView</h2><p>直接加载网页，无交互</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><br>import QtQuick 2.15<br>import QtQuick.Controls 2.12<br>import QtQuick.Layouts 1.15<br>import QtWebEngine 1.3<br><br>Item &#123;<br>    WebEngineView &#123;<br>        width:1000;<br>        anchors.centerIn: parent<br>        id:webview<br>        anchors.fill: parent<br>        url: &quot;charts.html&quot;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>需要在当前路径放入<code>html和js文件</code>以及<code>Qt</code>的<code>qwebchannel.js</code></p><h2 id="1-HTML的js调用QML-js"><a href="#1-HTML的js调用QML-js" class="headerlink" title="1.HTML的js调用QML/js"></a>1.HTML的js调用QML/js</h2><p><code>HTML</code>的<code>js</code>调用<code>QML/js</code>需要借助<code>WebChannel</code></p><p><code>QML</code>代码改为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json"><br>import QtQuick 2.15<br>import QtQuick.Controls 2.12<br>import QtQuick.Layouts 1.15<br>import QtWebEngine 1.3<br>import QtWebChannel 1.0<br><br>Item &#123;<br>    QtObject &#123;//注意3.1<br>        id: webObject<br>        WebChannel.id: &quot;webObject&quot; //注意3.2<br>        function pageLoadFinished()&#123; //注意3.3<br>           <span class="hljs-comment">//todo</span><br>        &#125;<br>    &#125;<br><br>    WebChannel &#123;<br>        id: channel<br>        registeredObjects: [webObject] //注意2<br>    &#125;<br><br>    WebEngineView &#123;<br>        width:1000;<br>        anchors.centerIn: parent<br>        id:webview<br>        anchors.fill: parent<br>        url: &quot;charts.html&quot;<br>        webChannel: channel //注意1<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>整体分为三个步骤</p><ol><li><p>通过<code>WebEngineView.webChannel</code>设置<code>WebChannel</code></p></li><li><p>通过<code>WebChannel.registeredObjects</code>注册对象。</p></li><li><p>实现注册对象。</p><ul><li>通过<code>2</code>注册的对象需为<code>QtObject</code>对象。</li><li><code>QtObject.WebChannel.id</code>字符串对应<code>js</code>中的对象名</li><li><code>pageLoadFinished()</code>函数名需与<code>js</code>中对应</li></ul></li></ol><p><code>html/js代码如下</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;qwebchannel.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">new</span> QWebChannel(qt.webChannelTransport,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> webObject = channel.objects.webObject; <span class="hljs-comment">//注意1</span></span><br><span class="javascript">        <span class="hljs-built_in">window</span>.webObject = webObject;</span><br><span class="javascript">        <span class="hljs-built_in">window</span>.webObject.pageLoadFinished(); <span class="hljs-comment">//注意2</span></span><br>      &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;today&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 1600px;height:500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;total&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 1600px;height:500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol><li>注意1中<code>channel.objects.webObject</code>中的对象名<code>webObject</code>需与<code>QtObject.WebChannel.id</code>字符串相同</li><li>注意2中<code>pageLoadFinished()</code>函数名需与<code>QtObject</code>类中的<code>槽函数</code>名称相同</li></ol><h2 id="2-QML-js调用HTML的js"><a href="#2-QML-js调用HTML的js" class="headerlink" title="2.QML/js调用HTML的js"></a>2.QML/js调用HTML的js</h2><p><code>QML</code>代码改为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json"><br>import QtQuick 2.15<br>import QtQuick.Controls 2.12<br>import QtQuick.Layouts 1.15<br>import QtWebEngine 1.3<br>import QtWebChannel 1.0<br><br>Item &#123;<br>    QtObject &#123;<br>        id: webObject<br>        WebChannel.id: &quot;webObject&quot;<br>        signal setData(string todayData, string totalData, string updateTime);//注意<br>    &#125;<br><br>    WebChannel &#123;<br>        id: channel<br>        registeredObjects: [webObject]<br>    &#125;<br><br>    WebEngineView &#123;<br>        width:1000;<br>        anchors.centerIn: parent<br>        id:webview<br>        anchors.fill: parent<br>        url: &quot;charts.html&quot;<br>        webChannel: channel<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>整体也是分为三个步骤。不同之处在于声明信号<code>setData</code>,, 信号名需与<code>js</code>中对应，并在合适的时机发射</p><p><code>html/js代码如下</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;qwebchannel.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> updateData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">todayData, totalData, updateTime</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-comment">//todo</span></span><br>    &#125;<br><br><span class="javascript">    <span class="hljs-keyword">new</span> QWebChannel(qt.webChannelTransport,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> webObject = channel.objects.webObject; <span class="hljs-comment">//注意1</span></span><br><span class="javascript">        <span class="hljs-built_in">window</span>.webObject = webObject;</span><br><span class="javascript">        <span class="hljs-built_in">window</span>.webObject.setData.connect(updateData); <span class="hljs-comment">//注意2</span></span><br>      &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;today&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 1600px;height:500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;total&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 1600px;height:500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol><li>注意1中<code>channel.objects.webObject</code>中的对象名<code>webObject</code>需与<code>QtObject.WebChannel.id</code>字符串相同</li><li>注意2中<code>window.webObject.setData</code>函数名需与<code>QtObject</code>类中的<code>信号</code>名称相同</li></ol>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QWebEngine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pyqt QWebEngineView-python和js交互</title>
    <link href="/noob/2021/12/05/pyqt-QWebEngineView-python%E5%92%8Cjs%E4%BA%A4%E4%BA%92/"/>
    <url>/noob/2021/12/05/pyqt-QWebEngineView-python%E5%92%8Cjs%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>PyQt下QWebEngine，QWebChannel简单使用。</p><span id="more"></span><p>PyQt下使用QWebEngine，QWebChannel整体流程与C++版类似</p><p>参见项目<br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox/blob/master/Covid19Map/Covid19Map.py">github</a><br><a href="https://gitee.com/yuque/PyQtWidgetToyBox/blob/master/Covid19Map/Covid19Map.py">gitee</a></p></blockquote><h2 id="0-QWebEngineView"><a href="#0-QWebEngineView" class="headerlink" title="0. QWebEngineView"></a>0. QWebEngineView</h2><p>直接加载网页，无交互</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QFrame, QVBoxLayout<br><span class="hljs-keyword">from</span> PyQt5.QtWebEngineWidgets <span class="hljs-keyword">import</span> QWebEngineView<br><span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> QUrl<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Covid19Charts</span>(<span class="hljs-params">QFrame</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(parent)<br><br>        webView = QWebEngineView(self)<br>        webView.load(QUrl.fromLocalFile(<span class="hljs-string">&quot;/Covid19Charts/charts.html&quot;</span>))<br>        webView.show()<br><br>        layout = QVBoxLayout()<br>        layout.setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        layout.addWidget(webView)<br>        self.setLayout(layout)<br><br></code></pre></td></tr></table></figure><p>需要在当前路径放入<code>html和js文件</code>以及<code>Qt</code>的<code>qwebchannel.js</code></p><h2 id="1-js调用python"><a href="#1-js调用python" class="headerlink" title="1.js调用python"></a>1.js调用python</h2><p><code>js</code>调用<code>python</code> 需要借助<code>QWebChannel</code></p><p><code>Covid19Charts</code>类代码改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QFrame, QVBoxLayout<br><span class="hljs-keyword">from</span> PyQt5.QtWebEngineWidgets <span class="hljs-keyword">import</span> QWebEngineView<br><span class="hljs-keyword">from</span> PyQt5.QtWebChannel <span class="hljs-keyword">import</span> QWebChannel<br><span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> QUrl<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Covid19Charts</span>(<span class="hljs-params">QFrame</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(parent)<br><br>        webView = QWebEngineView(self)<br>        webView.load(QUrl.fromLocalFile(<span class="hljs-string">&quot;/Covid19Charts/charts.html&quot;</span>))<br>        webView.show()<br><br>        layout = QVBoxLayout()<br>        layout.setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        layout.addWidget(webView)<br>        self.setLayout(layout)<br><br>        webChannel = QWebChannel(self) <span class="hljs-comment">#步骤1</span><br>        self.__webObject = ChartsWebClass(self) <span class="hljs-comment">#步骤2</span><br>        webChannel.registerObject(<span class="hljs-string">&quot;webObject&quot;</span>, self.__webObject) <span class="hljs-comment">#步骤2</span><br>        webView.page().setWebChannel(webChannel) <span class="hljs-comment">#步骤1</span><br></code></pre></td></tr></table></figure><p>整体分为两个步骤</p><ol><li>通过<code>QWebEngineView.setWebChannel()</code>设置<code>WebChannel</code></li><li>通过<code>QWebChannel.registerObject()</code>中注册对象。<ul><li>该对象需继承自<code>QObject</code>类。</li><li><code>QWebChannel.registerObject()</code>第一个参数字符串对应<code>js</code>中的对象名</li></ul></li></ol><p><code>ChartsWebClass</code>类代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> QObject, pyqtSlot<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChartsWebClass</span>(<span class="hljs-params">QObject</span>):</span> <span class="hljs-comment">#注意1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(parent)<br><br><span class="hljs-meta">    @pyqtSlot() </span><span class="hljs-comment">#注意3</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pageLoadFinished</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment">#注意2</span><br>        <span class="hljs-comment"># todo</span><br><br></code></pre></td></tr></table></figure><p>此处有三个注意事项</p><ol><li><code>ChartsWebClass</code>需继承自<code>QObject</code></li><li><code>pageLoadFinished()</code>函数名需与<code>js</code>中对应</li><li><code>pageLoadFinished()</code>函数需为<code>槽函数</code></li></ol><p><code>html/js代码如下</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;qwebchannel.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">new</span> QWebChannel(qt.webChannelTransport,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> webObject = channel.objects.webObject; <span class="hljs-comment">//注意1</span></span><br><span class="javascript">        <span class="hljs-built_in">window</span>.webObject = webObject;</span><br><span class="javascript">        <span class="hljs-built_in">window</span>.webObject.pageLoadFinished(); <span class="hljs-comment">//注意2</span></span><br>      &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;today&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 1600px;height:500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;total&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 1600px;height:500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol><li>注意1中<code>channel.objects.webObject</code>中的对象名<code>webObject</code>需与<code>QWebChannel.registerObject()</code>注册名称相同</li><li>注意2中<code>pageLoadFinished()</code>函数名需与<code>ChartsWebClass</code>类中的<code>槽函数</code>名称相同</li></ol><h2 id="2-python调用js"><a href="#2-python调用js" class="headerlink" title="2.python调用js"></a>2.python调用js</h2><p>与<code>1.js调用python</code>类似，也是通过需要借助<code>QWebChannel</code><br><code>Covid19Charts</code>类不变。<br><code>ChartsWebClass</code>类代码改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChartsWebClass</span>(<span class="hljs-params">QObject</span>):</span><br>    setData = pyqtSignal(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>) <span class="hljs-comment">#注意1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(parent)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setDatas</span>(<span class="hljs-params">self, datas</span>):</span> <span class="hljs-comment">#无关代码，外层调用</span><br>        self.setData.emit(datas[<span class="hljs-number">0</span>], datas[<span class="hljs-number">1</span>], datas[<span class="hljs-number">2</span>]) <span class="hljs-comment">#注意2</span><br><br></code></pre></td></tr></table></figure><ol><li>声明信号<code>setData()</code>, 信号名需与<code>js</code>中对应。</li><li>在合适的时机发射信号。</li></ol><p><code>html/js代码如下</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;qwebchannel.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> updateData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">todayData, totalData, updateTime</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-comment">//todo</span></span><br>    &#125;<br><br><span class="javascript">    <span class="hljs-keyword">new</span> QWebChannel(qt.webChannelTransport,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">channel</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> webObject = channel.objects.webObject; <span class="hljs-comment">//注意1</span></span><br><span class="javascript">        <span class="hljs-built_in">window</span>.webObject = webObject;</span><br><span class="javascript">        <span class="hljs-built_in">window</span>.webObject.setData.connect(updateData); <span class="hljs-comment">//注意2</span></span><br>      &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;today&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 1600px;height:500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;total&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 1600px;height:500px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol><li>注意1中<code>channel.objects.webObject</code>中的对象名<code>webObject</code>需与<code>QWebChannel.registerObject()</code>注册名称相同</li><li>注意2中<code>window.webObject.setData</code>函数名需与<code>ChartsWebClass</code>类中的<code>信号</code>名称相同</li></ol>]]></content>
    
    
    <categories>
      
      <category>PyQt</category>
      
      <category>QWebEngine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QWebEngine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QWebEngineView C++和js交互</title>
    <link href="/noob/2021/10/30/QWebEngineView-C%E5%92%8Cjs%E4%BA%A4%E4%BA%92/"/>
    <url>/noob/2021/10/30/QWebEngineView-C%E5%92%8Cjs%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>QWebEngine，QWebChannel简单使用。</p></blockquote><span id="more"></span><h2 id="0-QWebEngineView"><a href="#0-QWebEngineView" class="headerlink" title="0. QWebEngineView"></a>0. QWebEngineView</h2><p><code>pro</code>文件中添加</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">QT       +</span>=<span class="hljs-string">  webenginewidgets</span><br></code></pre></td></tr></table></figure><p><code>.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QWebEngineView&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QUrl&gt;</span></span><br><br>Widget::Widget(QWidget *parent)<br>    : QWidget(parent)<br>&#123;<br>    QWebEngineView* view = <span class="hljs-keyword">new</span> QWebEngineView(<span class="hljs-keyword">this</span>);<br>    view-&gt;load(QUrl::fromLocalFile(qApp-&gt;applicationDirPath() + <span class="hljs-string">&quot;/2.html&quot;</span>));<br>    view-&gt;show();<br><br>    QVBoxLayout* layout = <span class="hljs-keyword">new</span> QVBoxLayout;<br>    layout-&gt;setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    layout-&gt;addWidget(view);<br><br>    <span class="hljs-keyword">this</span>-&gt;setLayout(layout);<br>    <span class="hljs-keyword">this</span>-&gt;setFixedSize(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要在<code>exe</code>的路径下放入<code>html和js文件</code>以及<code>Qt</code>的<code>qwebchannel.js</code></p><h2 id="1-js调用C"><a href="#1-js调用C" class="headerlink" title="1.js调用C++"></a>1.js调用C++</h2><p><code>pro</code>文件中添加</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">QT       +</span>=<span class="hljs-string"> webenginewidgets webchannel</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebClass</span> :</span> <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">WebClass</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br><br>signals:<br><br><span class="hljs-keyword">public</span> slots:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jscallme</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;text)</span></span><br><span class="hljs-function">    </span>&#123;<br>        QMessageBox::information(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;jscallme&quot;</span>, text);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++">MainWindow::MainWindow(QWidget *parent)<br>    : QMainWindow(parent)<br>&#123;<br>    webView = <span class="hljs-keyword">new</span> QWebEngineView(<span class="hljs-keyword">this</span>);<br>    webView-&gt;load(QUrl::fromLocalFile(qApp-&gt;applicationDirPath() + <span class="hljs-string">&quot;/2.html&quot;</span>));<br><br>    webChannel = <span class="hljs-keyword">new</span> QWebChannel(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">auto</span> webobj = <span class="hljs-keyword">new</span> WebClass(<span class="hljs-keyword">this</span>);<br>    webChannel-&gt;registerObject(<span class="hljs-string">&quot;webobj&quot;</span>, webobj);<br>    webView-&gt;page()-&gt;setWebChannel(webChannel);<br><br>    QVBoxLayout* layout = <span class="hljs-keyword">new</span> QVBoxLayout;<br>    layout-&gt;setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    layout-&gt;addWidget(webView);<br><br>    QFrame* centerFrame = <span class="hljs-keyword">new</span> QFrame(<span class="hljs-keyword">this</span>);<br>    centerFrame-&gt;setLayout(layout);<br>    <span class="hljs-keyword">this</span>-&gt;setCentralWidget(centerFrame);<br>    <span class="hljs-keyword">this</span>-&gt;showMaximized();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;qwebchannel.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">new</span> QWebChannel(qt.webChannelTransport,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">channel</span>)</span>&#123;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> webobj = channel.objects.webobj;</span><br><span class="javascript">  <span class="hljs-built_in">window</span>.foo = webobj;</span><br><span class="javascript">  webobj.jscallme(<span class="hljs-string">&#x27;中文调用&#x27;</span>);;</span><br>  &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-c-调用js"><a href="#2-c-调用js" class="headerlink" title="2.c++调用js"></a>2.c++调用js</h2><p><strong>直接调用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++">MainWindow::MainWindow(QWidget *parent)<br>    : QMainWindow(parent)<br>&#123;<br>    webView = <span class="hljs-keyword">new</span> QWebEngineView(<span class="hljs-keyword">this</span>);<br>    webView-&gt;load(QUrl::fromLocalFile(qApp-&gt;applicationDirPath() + <span class="hljs-string">&quot;/2.html&quot;</span>));<br><br>    webChannel = <span class="hljs-keyword">new</span> QWebChannel(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">auto</span> webobj = <span class="hljs-keyword">new</span> WebClass(<span class="hljs-keyword">this</span>);<br>    webChannel-&gt;registerObject(<span class="hljs-string">&quot;webobj&quot;</span>, webobj);<br>    webView-&gt;page()-&gt;setWebChannel(webChannel);<br><br>    QPushButton* button = <span class="hljs-keyword">new</span> QPushButton(<span class="hljs-string">&quot;click me&quot;</span>,<span class="hljs-keyword">this</span>);<br><br>    QVBoxLayout* layout = <span class="hljs-keyword">new</span> QVBoxLayout;<br>    layout-&gt;setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    layout-&gt;addWidget(button);<br>    layout-&gt;addWidget(webView);<br><br>    QFrame* centerFrame = <span class="hljs-keyword">new</span> QFrame(<span class="hljs-keyword">this</span>);<br>    centerFrame-&gt;setLayout(layout);<br>    <span class="hljs-keyword">this</span>-&gt;setCentralWidget(centerFrame);<br>    <span class="hljs-keyword">this</span>-&gt;showMaximized();<br><br>    connect(button, &amp;QPushButton::clicked, [=]()&#123;<br>        webView-&gt;page()-&gt;runJavaScript(<span class="hljs-string">&quot;cppCallJs();&quot;</span>,<br>                                       [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">const</span> QVariant &amp;v) &#123;<br>            qDebug()&lt;&lt;v.toString();<br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;qwebchannel.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">      <span class="hljs-keyword">var</span> cppCallJs=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span></span><br>      &#123;<br><span class="javascript">         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cppCassJs down!&quot;</span>;</span><br>      &#125;<br><br><span class="javascript">      <span class="hljs-keyword">new</span> QWebChannel(qt.webChannelTransport,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">channel</span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">var</span> webobj = channel.objects.webobj;</span><br><span class="javascript">      <span class="hljs-built_in">window</span>.foo = webobj;</span><br>      &#125;);<br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>信号</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebClass</span> :</span> <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">WebClass</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(QString _content)</span></span>&#123;<span class="hljs-function">emit <span class="hljs-title">contentChanged</span><span class="hljs-params">(_content)</span></span>;&#125;;<br><br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contentChanged</span><span class="hljs-params">(QString)</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">connect(button, &amp;QPushButton::clicked, [=]()&#123;<br>    webobj-&gt;setContent(<span class="hljs-string">&quot;11111&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;qwebchannel.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><br><span class="javascript">      <span class="hljs-keyword">var</span> updateattribute=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>)</span></span><br>      &#123;<br><span class="javascript">        <span class="hljs-built_in">document</span>.write(text);</span><br>      &#125;<br><br><span class="javascript">      <span class="hljs-keyword">new</span> QWebChannel(qt.webChannelTransport,</span><br><span class="javascript">      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">channel</span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">var</span> webobj = channel.objects.webobj;</span><br><span class="javascript">      <span class="hljs-built_in">window</span>.foo = webobj;</span><br>      webobj.contentChanged.connect(updateattribute);<br><br>      &#125;);<br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>属性-信号</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebClass</span> :</span> <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">WebClass</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br>    Q_PROPERTY(QString content MEMBER content_ NOTIFY contentChanged)<br><br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contentChanged</span><span class="hljs-params">(QString)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    QString content_;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">connect(button, &amp;QPushButton::clicked, [=]()&#123;<br>   webobj-&gt;setProperty(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;222222&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://myprogrammingnotes.com/communication-c-javascript-qt-webengine.html">myprogrammingnotes</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/sunnyloves/article/details/88683090">csdn</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QWebEngine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QWebEngine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5 加载UI文件</title>
    <link href="/noob/2021/10/29/PyQt5-%E5%8A%A0%E8%BD%BDUI%E6%96%87%E4%BB%B6/"/>
    <url>/noob/2021/10/29/PyQt5-%E5%8A%A0%E8%BD%BDUI%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p> PyQt5直接加载UI文件，而不是将其转化为.py文件。</p></blockquote><span id="more"></span><h2 id="PySide2直接加载UI文件"><a href="#PySide2直接加载UI文件" class="headerlink" title="PySide2直接加载UI文件"></a>PySide2直接加载UI文件</h2><p>通过Qt Creator新建Qt for Python项目</p><p><img src="image-20211029095545433.png"></p><p>自动生成直接加载UI文件代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># This Python file uses the following encoding: utf-8</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">from</span> PySide2.QtWidgets <span class="hljs-keyword">import</span> QApplication, QWidget<br><span class="hljs-keyword">from</span> PySide2.QtCore <span class="hljs-keyword">import</span> QFile<br><span class="hljs-keyword">from</span> PySide2.QtUiTools <span class="hljs-keyword">import</span> QUiLoader<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UITest</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(UITest, self).__init__()<br>        self.load_ui()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_ui</span>(<span class="hljs-params">self</span>):</span><br>        loader = QUiLoader()<br>        path = os.fspath(Path(__file__).resolve().parent / <span class="hljs-string">&quot;form.ui&quot;</span>)<br>        ui_file = QFile(path)<br>        ui_file.<span class="hljs-built_in">open</span>(QFile.ReadOnly)<br>        loader.load(ui_file, self)<br>        ui_file.close()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app = QApplication([])<br>    widget = UITest()<br>    widget.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><h2 id="PyQt5直接加载UI文件"><a href="#PyQt5直接加载UI文件" class="headerlink" title="PyQt5直接加载UI文件"></a>PyQt5直接加载UI文件</h2><p>仿造上述代码</p><p>```python</p><h1 id="This-Python-file-uses-the-following-encoding-utf-8"><a href="#This-Python-file-uses-the-following-encoding-utf-8" class="headerlink" title="This Python file uses the following encoding: utf-8"></a>This Python file uses the following encoding: utf-8</h1><p>import sys</p><p>from PyQt5.QtWidgets import QApplication, QWidget<br>from PyQt5.uic import loadUi</p><p>class UITest(QWidget):<br>    def <strong>init</strong>(self, parent=None):<br>        super().<strong>init</strong>()<br>        loadUi(‘form.ui’, self)<br>        self.setFixedSize(600, 400)<br>        self.pushButton.clicked.connect(self.onButtonClicked)#可直接self.pushButton,该QPushButton变量在UI中定义</p><pre><code>def onButtonClicked(self):    x = random.randint(self.pushButton.width(), self.width() - self.pushButton.width())    y = random.randint(self.pushButton.height(), self.height() - self.pushButton.height())    self.pushButton.move(x, y)</code></pre><p>if <strong>name</strong> == “<strong>main</strong>“:<br>    app = QApplication([])<br>    widget = UITest()<br>    widget.show()<br>    sys.exit(app.exec_())</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>参见项目示例<br><a href="https://github.com/noobPlusPlus/PyQtWidgetToyBox/tree/master/Welcome">github</a><br><a href="https://gitee.com/yuque/PyQtWidgetToyBox/tree/master/Welcome">gitee</a></p>]]></content>
    
    
    <categories>
      
      <category>PyQt</category>
      
      <category>QWidget</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QWidget</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QListWidget</title>
    <link href="/noob/2021/10/28/QListWidget/"/>
    <url>/noob/2021/10/28/QListWidget/</url>
    
    <content type="html"><![CDATA[<blockquote><p>QListWidget记录汇总。</p></blockquote><span id="more"></span><h2 id="1-QListWidget-itemChanged-QListWidgetItem-item"><a href="#1-QListWidget-itemChanged-QListWidgetItem-item" class="headerlink" title="1. QListWidget::itemChanged(QListWidgetItem * _item)"></a>1. QListWidget::itemChanged(QListWidgetItem * _item)</h2><ol><li><p>当允许编辑时，编辑后失去焦点可触发该信号，假设槽函数为<code>onItemChanged</code>，如果此时选中其他行，此时的<code>currentRow()</code>不是被编辑的<code>row</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test::onItemChanged</span><span class="hljs-params">(QListWidgetItem * _item)</span> <span class="hljs-comment">//</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> row = listWidget-&gt;currentRow();<span class="hljs-comment">//错</span><br>    <span class="hljs-keyword">auto</span> row2 = listWidget-&gt;row(_item);<span class="hljs-comment">//对</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-增加行"><a href="#2-增加行" class="headerlink" title="2. 增加行"></a>2. 增加行</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> listWidgetItem = <span class="hljs-keyword">new</span> QListWidgetItem(<span class="hljs-string">&quot;test&quot;</span>, listWidget);<br></code></pre></td></tr></table></figure><p>可编辑、可选中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">listWidgetItem-&gt;setFlags(Qt::ItemIsEnabled | Qt::ItemIsEditable | Qt::ItemIsSelectable);<br></code></pre></td></tr></table></figure><p>增加一行会触发<code>QListWidget::itemChanged(QListWidgetItem * _item)</code>信号，不想触发可以关闭</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">disconnect(listWidget, &amp;QListWidget::itemChanged, <span class="hljs-keyword">this</span>, &amp;Test::onItemChanged);<br><span class="hljs-keyword">auto</span> listWidgetItem = <span class="hljs-keyword">new</span> QListWidgetItem(<span class="hljs-string">&quot;test&quot;</span>, listWidget);<br>listWidgetItem-&gt;setFlags(Qt::ItemIsEnabled | Qt::ItemIsEditable | Qt::ItemIsSelectable);<br>connect(listWidget, &amp;QListWidget::itemChanged, <span class="hljs-keyword">this</span>, &amp;Test::onItemChanged);<br></code></pre></td></tr></table></figure><h2 id="3-删除行"><a href="#3-删除行" class="headerlink" title="3. 删除行"></a>3. 删除行</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> item = listWidget-&gt;takeItem(index);<br><span class="hljs-keyword">delete</span> item;<br></code></pre></td></tr></table></figure><h2 id="4-去掉item选中的虚线框"><a href="#4-去掉item选中的虚线框" class="headerlink" title="4. 去掉item选中的虚线框"></a>4. 去掉item选中的虚线框</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">listWidget-&gt;setFocusPolicy(Qt::NoFocus);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">QListWidget</span>&#123;<br>    <span class="hljs-attribute">outline</span>:<span class="hljs-number">0px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-item颜色交替"><a href="#5-item颜色交替" class="headerlink" title="5. item颜色交替"></a>5. item颜色交替</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">listWidget-&gt;setAlternatingRowColors(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">QListWidget</span> &#123;<br><span class="hljs-attribute">background</span>:gray;<br>    <span class="hljs-attribute">alternate-background-color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20211028133540429.png"></p><p>算上背景色有两种颜色</p><p>或</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">QListWidget</span> &#123;<br><span class="hljs-attribute">background</span>:gray;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span><span class="hljs-selector-pseudo">::item</span><span class="hljs-selector-pseudo">:alternate</span> <span class="hljs-comment">/*偶数行*/</span><br>&#123;<br><span class="hljs-attribute">background</span>:pink;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span><span class="hljs-selector-pseudo">::item</span>:!<span class="hljs-selector-tag">alternate</span> <span class="hljs-comment">/*奇数行*/</span><br>&#123;<br><span class="hljs-attribute">background</span>:black;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20211028134455905.png"></p><p>算上背景色有三种颜色</p><h2 id="6-编辑框"><a href="#6-编辑框" class="headerlink" title="6. 编辑框"></a>6. 编辑框</h2><p>同QLineEdit</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">QListWidget</span> <span class="hljs-selector-tag">QLineEdit</span><br>&#123;<br>    <span class="hljs-attribute">background</span>: gray;<br><span class="hljs-attribute">color</span>:white;<br><span class="hljs-attribute">border</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-部分样式"><a href="#7-部分样式" class="headerlink" title="7. 部分样式"></a>7. 部分样式</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">QListWidget</span> &#123;<br><span class="hljs-attribute">border</span>: none;<br><span class="hljs-attribute">background</span>:gray;<br>    <span class="hljs-comment">/*alternate-background-color: black;*/</span><br><span class="hljs-attribute">color</span>: green;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span>&#123;<br>    <span class="hljs-attribute">outline</span>:<span class="hljs-number">0px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span> <span class="hljs-selector-tag">QLineEdit</span><br>&#123;<br>    <span class="hljs-attribute">background</span>: gray;<br><span class="hljs-attribute">color</span>:white;<br><span class="hljs-attribute">border</span>:none;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span><span class="hljs-selector-pseudo">::item</span><span class="hljs-selector-pseudo">:alternate</span><br>&#123;<br><span class="hljs-attribute">background</span>:pink;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span><span class="hljs-selector-pseudo">::item</span>:!<span class="hljs-selector-tag">alternate</span><br>&#123;<br><span class="hljs-attribute">background</span>:black;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span><span class="hljs-selector-pseudo">::item</span>&#123;<br><span class="hljs-attribute">color</span>: yellow;<br><span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid blue;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span><span class="hljs-selector-pseudo">::item</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background</span>: red;<br><span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-tag">QListWidget</span><span class="hljs-selector-pseudo">::item</span><span class="hljs-selector-pseudo">:selected</span> &#123;<br>    <span class="hljs-attribute">background</span>: red;<br><span class="hljs-attribute">color</span>:white;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="image-20211028135145129.png"></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QWidget</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QWidget</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防止同一信号多次触发-使用disconnect()函数</title>
    <link href="/noob/2021/09/10/%E9%98%B2%E6%AD%A2%E5%90%8C%E4%B8%80%E4%BF%A1%E5%8F%B7%E5%A4%9A%E6%AC%A1%E8%A7%A6%E5%8F%91-%E4%BD%BF%E7%94%A8disconnect()%E5%87%BD%E6%95%B0/"/>
    <url>/noob/2021/09/10/%E9%98%B2%E6%AD%A2%E5%90%8C%E4%B8%80%E4%BF%A1%E5%8F%B7%E5%A4%9A%E6%AC%A1%E8%A7%A6%E5%8F%91-%E4%BD%BF%E7%94%A8disconnect()%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>QObject::disconnect()</code>函数使用,以及个人发现的小问题</p></blockquote><span id="more"></span><p>当界面交互过于复杂，又无法该需求时，有时会出现一个操作使某个控件多次触发同一信号，导致同一信号槽多次执行，不仅影响程序运行效率，有时还会导致逻辑错误。该问题可以通过<code>QObject::disconnect()</code>解决-在需要的时候暂时关闭某一信号连接，处理完后再重新连接。</p><blockquote><p>Disconnects <em>signal</em> in object <em>sender</em> from <em>method</em> in object <em>receiver</em>. <strong>Returns true if the connection is successfully broken; otherwise returns false.</strong></p><p>A signal-slot connection is removed when either of the objects involved are destroyed.</p></blockquote><ol><li><p>Disconnect everything connected to an object’s signals (断开与<code>myObject</code>的信号与其他对象间的连接):<br><code> disconnect(myObject, nullptr, nullptr, nullptr);</code><br>equivalent to the non-static overloaded function<br> <code>myObject-&gt;disconnect();</code></p></li><li><p>Disconnect everything connected to a specific signal(断开与<code>myObject</code>的<code>mySignal()</code>信号与其他对象间的连接):<br> <code>disconnect(myObject, SIGNAL(mySignal()), nullptr, nullptr);</code><br>equivalent to the non-static overloaded function<br> <code>myObject-&gt;disconnect(SIGNAL(mySignal()));</code></p></li><li><p>Disconnect a specific receiver(断开<code>myObject</code>与<code>myReceiver</code>对象间的连接):<br> <code>disconnect(myObject, nullptr, myReceiver, nullptr);</code><br>equivalent to the non-static overloaded function<br> <code>myObject-&gt;disconnect(myReceiver);</code></p></li></ol><p><code>nullptr</code>可以用作通配符，分别表示“任何信号”、“任何接收对象”或“接收对象中的任何槽”。  </p><p>发送者可能永远不会是<code>nullptr</code>。 (不能在一个调用中断开来自多个对象的信号。)  </p><p>如果信号为<code>nullptr</code>，它断开接收器和方法与任何信号的连接。 如果不是，则只断开指定的信号。  </p><p>如果接收器是<code>nullptr</code>，它断开任何连接到信号。 如果不是，则接收端以外的对象的槽不会断开。  </p><p>如果方法是<code>nullptr</code>，它会断开任何连接到接收器的连接。 如果不是，只有命名为method的槽将被断开，而所有其他槽将被保留。 如果没有接收方，该方法必须为<code>nullptr</code>，因此不能断开所有对象上指定名称的槽位。  </p><h2 id="QCombobox为例"><a href="#QCombobox为例" class="headerlink" title="QCombobox为例"></a>QCombobox为例</h2><p><img src="disconnect_image.png"></p><p>点击<code>更改</code>按钮后会重置<code>comboBox_</code>中的内容，此时会触发两次<code>&amp;QComboBox::currentIndexChanged</code>信号，分别为<code>comboBox_-&gt;clear();</code>和<code>setData()---&gt;comboBox_-&gt;addItems;</code>。为避免多次触发该信号，可以在<code>comboBox_-&gt;clear();</code>前后分别<code>disconnect</code>()和<code>connect()</code>,代码如下所示：</p><p>测试环境<code>VS2022 + Qt5.15.2</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++">Dialog::Dialog(QWidget *parent)<br>    : QDialog(parent)<br>&#123;<br>initUI();<br>&#125;<br><br>Dialog::~Dialog()<br>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dialog::initUI</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>comboBox_ = <span class="hljs-keyword">new</span> QComboBox(<span class="hljs-keyword">this</span>);<br>label_ = <span class="hljs-keyword">new</span> QLabel(<span class="hljs-keyword">this</span>);<br>pushButton_ = <span class="hljs-keyword">new</span> QPushButton(<span class="hljs-string">u8&quot;更改&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>QHBoxLayout* topHLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>topHLayout-&gt;setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>topHLayout-&gt;setSpacing(<span class="hljs-number">10</span>);<br>topHLayout-&gt;addWidget(comboBox_);<br>topHLayout-&gt;addWidget(pushButton_);<br><br>QVBoxLayout* mainVLayout = <span class="hljs-keyword">new</span> QVBoxLayout;<br>mainVLayout-&gt;setSpacing(<span class="hljs-number">10</span>);<br>mainVLayout-&gt;addLayout(topHLayout);<br>mainVLayout-&gt;addWidget(label_);<br><br><span class="hljs-keyword">this</span>-&gt;setLayout(mainVLayout);<br><span class="hljs-keyword">this</span>-&gt;setFixedSize(<span class="hljs-number">200</span>, <span class="hljs-number">100</span>);<br>setData();<br><br>connect(pushButton_, &amp;QPushButton::clicked, <span class="hljs-keyword">this</span>, [=]() &#123;<br>count_ = <span class="hljs-number">0</span>;<br>label_-&gt;setText(QString::number(count_));<br><span class="hljs-keyword">auto</span> b = disconnect(comboBox_, <span class="hljs-literal">nullptr</span>, <span class="hljs-keyword">this</span>, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//1</span><br><span class="hljs-comment">//auto b = disconnect(comboBox_, static_cast&lt;void(QComboBox::*)(int)&gt;(&amp;QComboBox::currentIndexChanged),</span><br><span class="hljs-comment">//  this, nullptr); //2</span><br><span class="hljs-comment">//auto b = QObject::disconnect(comboBox_);  //3</span><br><span class="hljs-comment">//auto b = comboBox_-&gt;disconnect(); //4</span><br><span class="hljs-comment">//auto b = comboBox_-&gt;disconnect(comboBox_, nullptr, this, nullptr); //5</span><br><span class="hljs-comment">//auto b = comboBox_-&gt;disconnect(comboBox_, static_cast&lt;void(QComboBox::*)(int)&gt;(&amp;QComboBox::currentIndexChanged), </span><br><span class="hljs-comment">//this, nullptr); //6</span><br><span class="hljs-comment">//auto b = comboBox_-&gt;disconnect(comboBox_, static_cast&lt;void(QComboBox::*)(int)&gt;(&amp;QComboBox::currentIndexChanged),</span><br><span class="hljs-comment">//nullptr, nullptr); //7</span><br>        <span class="hljs-comment">//auto b = comboBox_-&gt;disconnect(comboBox_, static_cast&lt;void(QComboBox::*)(int)&gt;(&amp;QComboBox::currentIndexChanged),</span><br><span class="hljs-comment">//this, nullptr); //8 代码同6，只是connect不同</span><br><br>comboBox_-&gt;clear();<br>setComboBoxConnects();<br>setData();<br>&#125;);<br><br>setComboBoxConnects();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dialog::setComboBoxConnects</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>connect(comboBox_,<br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>(QComboBox::*)(<span class="hljs-keyword">int</span>)&gt;(&amp;QComboBox::currentIndexChanged),<br>[=](<span class="hljs-keyword">int</span> _index) &#123;<br><span class="hljs-keyword">if</span> (_index &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br><br>count_++;<br>label_-&gt;setText(QString::number(count_));<br>&#125;);<br>    <br>    connect(comboBox_,<br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>(QComboBox::*)(<span class="hljs-keyword">int</span>)&gt;(&amp;QComboBox::currentIndexChanged),<br>         <span class="hljs-keyword">this</span>, <span class="hljs-comment">//此处不同</span><br>[=](<span class="hljs-keyword">int</span> _index) &#123;<br><span class="hljs-keyword">if</span> (_index &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br><br>count_++;<br>label_-&gt;setText(QString::number(count_));<br>&#125;); <span class="hljs-comment">//8</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dialog::setData</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">const</span> QStringList listToShow = &#123;<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,&#125;;<br>comboBox_-&gt;addItems(listToShow);<br>&#125;<br></code></pre></td></tr></table></figure><p>第36-45行代码每次测试一行，注释掉其中两行。</p><table><thead><tr><th>条件（注释号）</th><th>b</th><th>count_</th></tr></thead><tbody><tr><td>4、7、8</td><td>true</td><td>1</td></tr><tr><td>1、2、3、5、6</td><td>false</td><td>2、3、4、5、6、7</td></tr></tbody></table><p>由上可得：</p><ol><li>是否<code>disconnect()</code>成功可以通过其返回值确定。</li><li>多次<code>connect()</code>会执行多次槽函数。</li><li><code>connect()</code>时候有无<code>receiver</code>也会影响是否<code>disconnect()</code>成功</li></ol><h2 id="blockSignals（摘自刘典武经验）"><a href="#blockSignals（摘自刘典武经验）" class="headerlink" title="blockSignals（摘自刘典武经验）"></a>blockSignals（摘自刘典武经验）</h2><p>先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。<br>如果需要指定某个信号进行断开那就只能用 disconnect 来处理。</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>信号槽</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/noob/2021/09/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/noob/2021/09/06/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>整理中</p></blockquote><span id="more"></span><h2 id="修改-gitignore-文件，如何重新生效"><a href="#修改-gitignore-文件，如何重新生效" class="headerlink" title="修改 .gitignore 文件，如何重新生效"></a>修改 .gitignore 文件，如何重新生效</h2><blockquote><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的;</p></blockquote><p><strong>命令</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git rm -r <span class="hljs-comment">--cached .</span><br>git <span class="hljs-keyword">add</span> .<br>git <span class="hljs-keyword">commit</span> -m &quot;update .gitignore&quot;<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/bymingliang/p/12273742.html">修改 .gitignore 文件，如何重新生效 - 一叶千秋 - 博客园 (cnblogs.com)</a></p><h2 id="修改remote地址"><a href="#修改remote地址" class="headerlink" title="修改remote地址"></a>修改remote地址</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> <span class="hljs-string">XXX</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器删除元素的方法（备份csdn博客，防止删除）</title>
    <link href="/noob/2021/09/01/%E5%AE%B9%E5%99%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%A4%87%E4%BB%BDcsdn%E5%8D%9A%E5%AE%A2%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%EF%BC%89/"/>
    <url>/noob/2021/09/01/%E5%AE%B9%E5%99%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%A4%87%E4%BB%BDcsdn%E5%8D%9A%E5%AE%A2%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Effective STL 第一章 第9条<br>1、要删除容器中有特定值的所有对象;</p><p>2、要删除容器中满足特定判断式（条件）的所有对象;</p><p>3、要在循环内部做某些（除了删除对象之外的）操作。</p><p>完全复制粘贴自<a href="https://blog.csdn.net/xlf13872135090/article/details/18040955%EF%BC%8C%E8%AF%A5%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93%E8%87%B3%E3%80%8AEffective">https://blog.csdn.net/xlf13872135090/article/details/18040955，该博客总结至《Effective</a> STL 第一章 第9条》，本文主要作用为备份，防止突然找不到。</p><span id="more"></span></blockquote><p>先写总结，在写例子：</p><p>1、要删除容器中有特定值的所有对象：</p><p>如果容器是vector, string或deque，则使用erase-remove习惯用法</p><p>如果容器是list，则使用list::remove</p><p>如果容器是一个标准关联容器，则使用它的erase成员函数</p><p>2、要删除容器中满足特定判断式（条件）的所有对象：</p><p>如果容器是vector、string和deque，则使用erase-remove-if用法</p><p>如果容器是list, 则使用list::remove_if</p><p>如果容器是一个标准关联容器，则使用remove_copy_if和swap，或者写一个循环来遍历容器中的元素，当把迭代器传给erase时，要对它进行后缀递增。</p><p>3、要在循环内部做某些（除了删除对象之外的）操作：</p><p>如果容器是一个标准序列容器，则写一个循环来遍历容器中的元素，每次调用erase时，要用它的返回值更新迭代器</p><p>如果容器是一个标准关联容器，则写一个循环来遍历容器中的元素，每次迭代器传给erase时，要对它进行后缀递增</p><p>以下是例子:</p><p>假定一个容器c，包含int类型，Container<int> c;</p><h2 id="问题1：当要删除c中所有值为1963的元素"><a href="#问题1：当要删除c中所有值为1963的元素" class="headerlink" title="问题1：当要删除c中所有值为1963的元素"></a>问题1：当要删除c中所有值为1963的元素</h2><p>（1）如果是一个连续内存容器(vectordeque string),使用erase-remove方法</p><p>remove操作并没有移除元素，而是将后面的元素覆盖删除元素，</p><p>返回新区间的逻辑终点，即下一个没有被删除的位置</p><p>（注意这里会使原来及其后面的迭代器失效，因为指向了不正确的元素）</p><p>erase删除两个迭代器之间的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">c.erase(remove(c.begin(), c.end(), <span class="hljs-number">1963</span>),c.end());<br></code></pre></td></tr></table></figure><p>（2）对于list，这一办法同样适用，但是适用list成员函数remove更高效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">c.remove(<span class="hljs-number">1963</span>);<br></code></pre></td></tr></table></figure><p>（3）当c是标准关联容器（set multiset map multimap）时，不能使用remove操作，</p><p>因为没有这个成员函数，使用remove算法可能会覆盖容器的值，同时可能会破坏容器</p><p>正确方法是 调用erase</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">c.erase(<span class="hljs-number">1963</span>);    <span class="hljs-comment">//只需要对数时间开销，序列容器需要线性时间</span><br></code></pre></td></tr></table></figure><h2 id="问题2：如果是使下面判断式返回true的每一个对象"><a href="#问题2：如果是使下面判断式返回true的每一个对象" class="headerlink" title="问题2：如果是使下面判断式返回true的每一个对象"></a>问题2：如果是使下面判断式返回true的每一个对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">badValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;  <span class="hljs-comment">//返回x是否是“坏值”</span><br></code></pre></td></tr></table></figure><p>(1) 对于序列容器（vectorstring deque list）,对remove的调用换成remove_if就可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">c.erase(remove_if(c.begin(), c.end(),badValue), c.end());<br><br><span class="hljs-built_in">list</span>：c.remove_if(badValue)<br></code></pre></td></tr></table></figure><p>（2）对于标准关联容器，解决方案有两种：</p><p>第一种：利用remove_copy_if把我们需要复制的值复制到一个新容器中，然后把原来容器的内容和新容器的内容相互交换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">AssocContainer&lt;<span class="hljs-keyword">int</span>&gt; c;          <span class="hljs-comment">//c是标准关联容器</span><br><br>…<br><br>AssocContainer&lt;<span class="hljs-keyword">int</span>&gt; goodValue;  <span class="hljs-comment">//保存不被删除的值的临时容器</span><br><br>remove_copy_if(c.begin(), c.end(),  <span class="hljs-comment">//把不被删除的值从c复制到goodValues中</span><br><br>inserter(goodValues,goodValues.end()), badValue);<br><br>c.swap(goodValue);       <span class="hljs-comment">//交换c和goodValues的值</span><br></code></pre></td></tr></table></figure><p>缺点是：需要复制所有不被删除的元素</p><p>不能直接从原始的容器中删除元素，因为容器没有提供类似remove_if的成员函数。</p><p>第二种：可以写一个循环，在遍历过程中删除元素。</p><p>一个直截了当的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(AssocContainer&lt;<span class="hljs-keyword">int</span>&gt;::iterator i =c.begin(); i != c.end(); ++i )<br><br>   <span class="hljs-keyword">if</span>(badValue(*i))<br>       c.erase(i); <br></code></pre></td></tr></table></figure><p>但是这样会导致不确定的行为，当容器中的一个元素被删除时，指向该元素的所有迭代器都变得无效，c.erase(i)之后，i变为无效值。</p><p>为了避免这个问题，要确保在调用erase之前，有一个迭代器指向c中的下一个元素。</p><p>最简单的方法是，对i使用后缀++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(AssocContainer&lt;<span class="hljs-keyword">int</span>&gt;::iterator i =c.begin(); i != c.end(); (什么都不做) )<br>   <span class="hljs-keyword">if</span>(badValue(*i))<br>      c.erase(i++);      <span class="hljs-comment">//这样在执行erase之前已经对i递增为新的值，旧的值删除变为了无效值，但i已经成为新值</span><br>  <span class="hljs-keyword">else</span><br>      ++i;<br></code></pre></td></tr></table></figure><p>问题3：如果我们不仅要删除使badValue返回true的元素，还当元素被删除时向日志文件记录一条信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ofstream logFile;<br><br><span class="hljs-keyword">for</span>(AssocContainer&lt;<span class="hljs-keyword">int</span>&gt;::iterator i =c.begin(); i != c.end(); (什么都不做) )<br>   <span class="hljs-keyword">if</span>(badValue(*i)) &#123;<br>     logFile &lt;&lt; “Eraseing” &lt;&lt; *i &lt;&lt; ‘\n’;  <span class="hljs-comment">//写日志文件</span><br>      c.erase(i++);        <span class="hljs-comment">//关联容器对erase的返回值是void</span><br>      &#125; <br>  <span class="hljs-keyword">else</span><br>       ++i;<br></code></pre></td></tr></table></figure><p>这种方法对vector string  deque无效，会导致不确定行为，因为这种容器调用erase不仅会使指向被删除元素的迭代器无效，也会使被删除元素之后的所有迭代器失效（因为容器位置变了，原来指向的内容已经变了）,++i，–i都会无效。</p><p>所以对于vector string  deque，利用erase的返回值。返回值是我们所需要的，一旦erase完成，它是指向紧随被删除元素的下一个元素的有效迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(SeqContainer&lt;<span class="hljs-keyword">int</span>&gt;::iterator i =c.begin(); i != c.end(); (什么都不做) )<br>   <span class="hljs-keyword">if</span>(badValue(*i)) <br>   &#123;<br>      logFile &lt;&lt; “Eraseing” &lt;&lt; *i &lt;&lt; ‘\n’;  <span class="hljs-comment">//写日志文件</span><br>      i =c.erase(i); <br>   &#125;     <br>  <span class="hljs-keyword">else</span><br>      ++i;<br></code></pre></td></tr></table></figure><p>对于list来说，一般是对list采用和vector string deque相同的方式。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能指针指定Deleter</title>
    <link href="/noob/2021/08/31/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%8C%87%E5%AE%9ADeleter/"/>
    <url>/noob/2021/08/31/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%8C%87%E5%AE%9ADeleter/</url>
    
    <content type="html"><![CDATA[<blockquote><p>unique_ptr、shared_ptr及其数组，通过lambda实现指定Deleter</p></blockquote><span id="more"></span><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Test, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(Test *)&gt;&gt; test(<span class="hljs-keyword">new</span> Test, [](Test* _pointer) &#123;<br>    <span class="hljs-comment">//其他操作</span><br>    <span class="hljs-keyword">delete</span> _pointer;<br>&#125;);<br><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;Test, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(Test *)&gt;&gt;(<span class="hljs-keyword">new</span> Test[<span class="hljs-number">5</span>], <span class="hljs-built_in">std</span>::default_delete&lt;Test[]&gt;());<br></code></pre></td></tr></table></figure><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Test&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test, [](Test* _pointer) &#123;</span></span><br><span class="hljs-function"><span class="hljs-params">     <span class="hljs-comment">//其他操作</span></span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">delete</span> _pointer;</span></span><br><span class="hljs-function"><span class="hljs-params">&#125;)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Test&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test[<span class="hljs-number">5</span>], <span class="hljs-built_in">std</span>::default_delete&lt;Test[]&gt;())</span></span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt处理耗时任务，防止界面假死的两个简单写法</title>
    <link href="/noob/2021/08/06/Qt%E5%A4%84%E7%90%86%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E9%98%B2%E6%AD%A2%E7%95%8C%E9%9D%A2%E5%81%87%E6%AD%BB%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E5%86%99%E6%B3%95/"/>
    <url>/noob/2021/08/06/Qt%E5%A4%84%E7%90%86%E8%80%97%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E9%98%B2%E6%AD%A2%E7%95%8C%E9%9D%A2%E5%81%87%E6%AD%BB%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>借助<code>QtConcurrent</code>和<code>QApplication::processEvents()</code>简化处理耗时任务以防界面假死。</p></blockquote><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有如下需求</p><p>点击<code>开始</code>按钮后，执行耗时操作，该按钮<code>进行中</code>后的<code>.</code>的数量随时间变化</p><p><img src="start.png" alt="start"></p><p><img src="doing.png" alt="doing"></p><p>代码如下</p><p><code>mainwindow.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> MAINWINDOW_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAINWINDOW_H</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCloseEvent&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Ui &#123;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MainWindow</span><span class="hljs-params">(QWidget *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br>    ~MainWindow();<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing0</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toDoOneThing</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _index)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    Ui::MainWindow *ui;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; DOT_VECTOR =<br>&#123;<br><span class="hljs-string">&quot;.&quot;</span>,<br><span class="hljs-string">&quot;..&quot;</span>,<br><span class="hljs-string">&quot;...&quot;</span>,<br><span class="hljs-string">&quot;....&quot;</span>,<br><span class="hljs-string">&quot;.....&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SLEEP_TIME = <span class="hljs-number">20</span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// MAINWINDOW_H</span></span><br></code></pre></td></tr></table></figure><p><code>mainwindow.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ui_mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtConcurrent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QThread&gt;</span></span><br><br>MainWindow::MainWindow(QWidget *parent) :<br>    QMainWindow(parent),<br>    ui(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br>connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [=]() &#123;<br>ui-&gt;pushButton-&gt;setEnabled(<span class="hljs-literal">false</span>);<br><br>doSomeThing0();<br><br>ui-&gt;pushButton-&gt;setText(<span class="hljs-string">u8&quot;开始&quot;</span>);<br>ui-&gt;pushButton-&gt;setEnabled(<span class="hljs-literal">true</span>);<br>&#125;);<br>&#125;<br><br>MainWindow::~MainWindow()<br>&#123;<br>    <span class="hljs-keyword">delete</span> ui;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::doSomeThing0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br>toDoOneThing(i);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::toDoOneThing</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _index)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//变化按钮文字后面&quot;.&quot;的个数</span><br>QString buttonText = <span class="hljs-string">u8&quot;进行中&quot;</span>;<br>buttonText += DOT_VECTOR[_index / <span class="hljs-number">20</span> % DOT_VECTOR.size()];<br>ui-&gt;pushButton-&gt;setText(buttonText);<br><br><span class="hljs-comment">//模拟耗时操作</span><br>QThread::msleep(SLEEP_TIME);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以上代码运行后点击<code>开始</code>，界面假死。</p><p>很多情况下，我们要在界面种处理某些耗时的操作，如果直接调用的话，主界面就会卡死，一般来说通过多线程可以解决该问题，包括最传统的<code>run</code>()和新式的<code>QObject::moveToThread()</code>具体可参考该文章<a href="https://zhuanlan.zhihu.com/p/53270619">Qt 多线程编程之敲开 QThread 类的大门 - 知乎 (zhihu.com)</a></p><p>有时候耗时操作逻辑很简单，代码也没有几行，单独封装一个类有点麻烦，有没有更省事的方法呢？</p><h2 id="单线程方式"><a href="#单线程方式" class="headerlink" title="单线程方式"></a>单线程方式</h2><p>可以单线程借助<code>QApplication::processEvents()</code>实现以上需求：</p><p><code>mainwindow.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing0</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//新增</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toDoOneThing</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _index)</span></span>;<br><br></code></pre></td></tr></table></figure><p><code>mainwindow.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ui_mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtConcurrent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QThread&gt;</span></span><br><br>MainWindow::MainWindow(QWidget *parent) :<br>    QMainWindow(parent),<br>    ui(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br>connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [=]() &#123;<br>ui-&gt;pushButton-&gt;setEnabled(<span class="hljs-literal">false</span>);<br><br>doSomeThing1(); <span class="hljs-comment">//调用doSomeThing1()</span><br><br>ui-&gt;pushButton-&gt;setText(<span class="hljs-string">u8&quot;开始&quot;</span>);<br>ui-&gt;pushButton-&gt;setEnabled(<span class="hljs-literal">true</span>);<br>&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::doSomeThing0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br>toDoOneThing(i);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::doSomeThing1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br>toDoOneThing(i);<br>QApplication::processEvents(); <span class="hljs-comment">//新增</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看出<code>doSomeThing1()</code>比<code>doSomeThing0()</code>只多一行代码。</p><h2 id="多线程方式"><a href="#多线程方式" class="headerlink" title="多线程方式"></a>多线程方式</h2><p>这里使用<code>QtConcurrent::run()</code>函数，实现起来相当简洁：</p><p><code>.pro</code></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">QT +</span>=<span class="hljs-string"> concurrent</span><br></code></pre></td></tr></table></figure><p><code>mainwindow.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing0</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing2</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//新增</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toDoOneThing</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _index)</span></span>;<br><br></code></pre></td></tr></table></figure><p><code>mainwindow.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ui_mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QtConcurrent&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QThread&gt;</span></span><br><br>MainWindow::MainWindow(QWidget *parent) :<br>    QMainWindow(parent),<br>    ui(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br>connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [=]() &#123;<br>ui-&gt;pushButton-&gt;setEnabled(<span class="hljs-literal">false</span>);<br><br>doSomeThing2(); <span class="hljs-comment">//调用doSomeThing2()</span><br><br>ui-&gt;pushButton-&gt;setText(<span class="hljs-string">u8&quot;开始&quot;</span>);<br>ui-&gt;pushButton-&gt;setEnabled(<span class="hljs-literal">true</span>);<br>&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::doSomeThing0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br>toDoOneThing(i);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::doSomeThing2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> <span class="hljs-built_in">future</span> = QtConcurrent::run(<span class="hljs-keyword">this</span>, &amp;MainWindow::doSomeThing0);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">future</span>.isFinished() == <span class="hljs-literal">false</span>)<br>&#123;<br>QApplication::processEvents();<br>QThread::msleep(<span class="hljs-number">20</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Concurrent是并发的意思，QtConcurrent是一个命名空间，提供了一些高级的 API，使得在编写多线程的时候，无需使用低级线程原语，如读写锁，等待条件或信号。使用QtConcurrent编写的程序会根据可用的处理器内核数自动调整使用的线程数。<a href="https://blog.csdn.net/luoyayun361/article/details/80288610">Qt QtConcurrent之 Run 函数用法_luoyayun361的专栏-CSDN博客_qtconcurrent</a></p><p><code>QtConcurrent::run()</code>从第三个参数开始为所调用函数的参数。</p><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p>以上代码执行时会出现点击关闭按钮无法退出的问题，解决方法如下：</p><p><code>mainwindow.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">protected</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">closeEvent</span><span class="hljs-params">(QCloseEvent *event)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">bool</span> isFinished_ = <span class="hljs-literal">false</span>;<br><br></code></pre></td></tr></table></figure><p><code>mainwindow.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::closeEvent</span><span class="hljs-params">(QCloseEvent * event)</span></span><br><span class="hljs-function"></span>&#123;<br>isFinished_ = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> QMainWindow::closeEvent(event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::doSomeThing0</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (isFinished_ == <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">break</span>;<br>toDoOneThing(i);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::doSomeThing1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (isFinished_ == <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">break</span>;<br>toDoOneThing(i);<br><br>QApplication::processEvents();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="示例代码路径"><a href="#示例代码路径" class="headerlink" title="示例代码路径"></a>示例代码路径</h2><p><a href="https://gitee.com/yuque/demo/tree/master/Backgrounder">Backgrounder · yuque/demo - 码云 - 开源中国 (gitee.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt，多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lambda表达式值捕获的一点小疑问</title>
    <link href="/noob/2021/06/03/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC%E6%8D%95%E8%8E%B7%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E7%96%91%E9%97%AE/"/>
    <url>/noob/2021/06/03/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%80%BC%E6%8D%95%E8%8E%B7%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E7%96%91%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<blockquote></blockquote><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>学习C++时，版本是<code>C++03</code>，公司也没有升级编译器，一直没有学习<code>C++11</code>，后来换工作后，新公司提倡使用<code>C++11</code>，特别推荐槽函数直接使用<code>lambda</code>如下所示写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [=]() &#123;<br>&#125;);<br></code></pre></td></tr></table></figure><p>大佬推荐<code>[]</code>中，一般直接捕获<code>=</code>即可。</p><p>后来大体了解了一下捕获：</p><blockquote><p><code>[&amp;]</code>（以引用隐式捕获被使用的自动变量）</p><p><code>[=] </code>（以复制隐式捕获被使用的自动变量）。</p><p><code>[=, &amp;i]</code>     // 以复制捕获，但 i 以引用捕获</p></blockquote><p>但是有点疑问：</p><p><code>dialog.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dialog</span> :</span> <span class="hljs-keyword">public</span> QDialog<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    Dialog(QWidget *parent = <span class="hljs-literal">nullptr</span>);<br>    ~Dialog();<br><br><span class="hljs-keyword">private</span>:<br>    Ui::Dialog *ui;<br><span class="hljs-keyword">int</span> clickedCount_ = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>dialog.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Dialog::Dialog(QWidget *parent)<br>    : QDialog(parent)<br>    , ui(<span class="hljs-keyword">new</span> Ui::Dialog)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br>clickedCount_;<br><br>connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [&amp;]() &#123;<br>clickedCount_++;<br>ui-&gt;label-&gt;setText(QString::number(clickedCount_));<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码实现在按钮点击时，显示点击次数</p><p><img src="image-20210604203216486.png"></p><p>我之前的想法是：由于<code>lambda</code>中以引用隐式自动捕获<code>clickedCount_</code>（<code>[&amp;]</code>），所以当点击按钮时，<code>clickedCount_++</code>能改变被捕获的<code>clickedCount_</code>值，如果换成以复制隐式捕获被使用的自动变量<code>[=]</code>，那么当点击按钮时，将一直显示0。</p><p>测试一下：</p><p><code>dialog.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Dialog::Dialog(QWidget *parent)<br>    : QDialog(parent)<br>    , ui(<span class="hljs-keyword">new</span> Ui::Dialog)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br>clickedCount_;<br><br>connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [=]() &#123;<br>clickedCount_++;<br>ui-&gt;label-&gt;setText(QString::number(clickedCount_));<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="image-20210604203801126.png"></p><p>功能和按引用捕获完全一样，不讲武德啊。。。。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>查看文档得知：</p><blockquote><p>Lambda 捕获</p><p><em>捕获</em> 是零或更多<em>捕获符</em>的逗号分隔列表，可选地以 <em>默认捕获符</em> 开始。仅有的默认捕获符是</p><p><code>&amp;</code>（以引用隐式捕获被使用的自动变量）和</p><p><code>= </code>（以复制隐式捕获被使用的自动变量）。</p><p>当出现任一默认捕获符时，都能隐式捕获当前对象（<code>*this</code>）。当它被隐式捕获时，始终被以引用捕获，即使默认捕获符是 <code>=</code> 也是如此。</p></blockquote><p>原来是因为无论是<code>[=]</code>还是<code>[&amp;]</code>都会默认捕获<code>*this</code>的引用，所以上面的示例得到的结果是一样的。</p><p>找到原因后，心中的疑团终于解决了，值还会捕获引用，总感觉有点怪怪的。</p><p>继续向下看文档：</p><blockquote><p>当默认捕获符为 <code>=</code> 时，<code>*this</code> 的隐式捕获被弃用。 (C++20 起)</p></blockquote><p>那帮老头子们是不是也感觉<code>=</code>捕获引用不妥，<code>c++20</code>给取消了。</p><p>感觉更不讲武德了。。。。</p><h2 id="Effective-Modern-C-建议避免使用默认捕获模式"><a href="#Effective-Modern-C-建议避免使用默认捕获模式" class="headerlink" title="Effective Modern C++建议避免使用默认捕获模式"></a>Effective Modern C++建议避免使用默认捕获模式</h2><p><a href="https://github.com/kelthuzadx/EffectiveModernCppChinese/blob/master/6.LambdaExpressions/item31.md">Effective Modern C++</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>C++11</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>番茄工具rename引起的bug - 建议使用新式Qt connect 写法</title>
    <link href="/noob/2021/06/02/%E7%95%AA%E8%8C%84%E5%B7%A5%E5%85%B7rename%E5%BC%95%E8%B5%B7%E7%9A%84bug-%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%96%B0%E5%BC%8FQt-connect-%E5%86%99%E6%B3%95/"/>
    <url>/noob/2021/06/02/%E7%95%AA%E8%8C%84%E5%B7%A5%E5%85%B7rename%E5%BC%95%E8%B5%B7%E7%9A%84bug-%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E6%96%B0%E5%BC%8FQt-connect-%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>测试《Qt Creator快速入门 第3版》书中代码测试TCP发送数据引起的问题</p></blockquote><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天拿<strong>《Qt Creator快速入门 第3版》</strong>书中代码测试TCP发送数据，代码位于<code>src/18/18-9/tcpclient</code>下，<code>Client</code>类构造函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">Client::Client(QWidget *parent) :<br>    QDialog(parent),<br>    ui(<span class="hljs-keyword">new</span> Ui::Client)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br><br>    payloadSize = <span class="hljs-number">64</span>*<span class="hljs-number">1024</span>; <span class="hljs-comment">// 64KB</span><br>    totalBytes = <span class="hljs-number">0</span>;<br>    bytesWritten = <span class="hljs-number">0</span>;<br>    bytesToWrite = <span class="hljs-number">0</span>;<br>    tcpClient = <span class="hljs-keyword">new</span> QTcpSocket(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">// 当连接服务器成功时，发出connected()信号，开始传送文件</span><br>    connect(tcpClient, SIGNAL(connected()), <span class="hljs-keyword">this</span>, SLOT(startTransfer()));<br>    connect(tcpClient, SIGNAL(bytesWritten(qint64)),<br>            <span class="hljs-keyword">this</span>, SLOT(updateClientProgress(qint64)));<br>    connect(tcpClient, SIGNAL(error(QAbstractSocket::SocketError)),<br>            <span class="hljs-keyword">this</span>, SLOT(displayError(QAbstractSocket::SocketError)));<br>    ui-&gt;sendButton-&gt;setEnabled(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>强迫症驱使将代码用<strong>VassistX工具</strong>将类成员变量改名，改完后的代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">Client::Client(QWidget *parent) :<br>    QDialog(parent),<br>    ui(<span class="hljs-keyword">new</span> Ui::Client)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br><br>    payloadSize_ = <span class="hljs-number">64</span>*<span class="hljs-number">1024</span>; <span class="hljs-comment">// 64KB</span><br>    totalBytes_ = <span class="hljs-number">0</span>;<br>    bytesWritten_ = <span class="hljs-number">0</span>;<br>    bytesToWrite_ = <span class="hljs-number">0</span>;<br>    tcpClient_ = <span class="hljs-keyword">new</span> QTcpSocket(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">// 当连接服务器成功时，发出connected()信号，开始传送文件</span><br>    connect(tcpClient_, SIGNAL(connected()), <span class="hljs-keyword">this</span>, SLOT(startTransfer()));<br>    connect(tcpClient_, SIGNAL(bytesWritten_(qint64)),<br>            <span class="hljs-keyword">this</span>, SLOT(updateClientProgress(qint64)));<br>    connect(tcpClient_, SIGNAL(error(QAbstractSocket::SocketError)),<br>            <span class="hljs-keyword">this</span>, SLOT(displayError(QAbstractSocket::SocketError)));<br>    ui-&gt;sendButton-&gt;setEnabled(<span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译通过，但是却无法发送数据，又是检查网络又是检查数据折腾半天，还是没找到问题。最后发现是我用<strong>VassistX工具</strong>改变量名时，由于变量名和<code>QTcpSocket::bytesWritten</code>信号名相同，导致<code>SIGNAL</code>宏括号中的<code>bytesWritten_(qint64)</code>信号名（就是个字符串）也被改名了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">connect(tcpClient_, SIGNAL(bytesWritten_(qint64)),<br>        <span class="hljs-keyword">this</span>, SLOT(updateClientProgress(qint64)));<br></code></pre></td></tr></table></figure><p>关键是编译时没有任何错误提示，所以强烈推荐在Qt5中使用新式的<code>connect</code>写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">connect(tcpClient_, &amp;QTcpSocket::bytesWritten, <span class="hljs-keyword">this</span>, &amp;Client::updateClientProgress);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">connect(tcpClient_, &amp;QTcpSocket::bytesWritten, [=](qint64 numBytes) &#123;<br>&#125;);<br></code></pre></td></tr></table></figure><ol><li>通过<strong>VassistX工具</strong>改名不会改上面代码中的<code>&amp;QTcpSocket::bytesWritten</code>;</li><li>就算改了，或是不小心自己改了，编译器直接会给出如下错误提示<code>错误    C2039    “bytesWritten_”: 不是“QTcpSocket”的成员</code>。</li><li>不仅是信号名，<code>SIGNAL(bytesWritten(qint64))</code>这种写法，参数类型、顺序写错都不能写错，否则也会出现运行期错误，编译器改错总比运行期去排查错误要简单的多。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>除非要兼容Qt4，否则尽量使用新式的<code>connect</code>写法。</li><li>变量、函数命名尽量不要重复，个人感觉Qt开发变量名更推荐使用<code>bytes_written</code>这种写法，以减少与Qt自带函数、变量重名的概率。</li><li>能在编译器解决的问题，不要拖到运行期。比如：新式枚举<code>enum class</code>传参比直接传<code>int</code>、<code>QString</code>更容易在编译器发现问题。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码中的if…else杂谈3</title>
    <link href="/noob/2021/05/31/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84if%E2%80%A6else%E6%9D%82%E8%B0%883/"/>
    <url>/noob/2021/05/31/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84if%E2%80%A6else%E6%9D%82%E8%B0%883/</url>
    
    <content type="html"><![CDATA[<blockquote><p>if-else链过长的几个解决方法。</p><span id="more"></span></blockquote><h2 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h2><p>老代码中经常见到下面这种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::showInfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString&amp; _animal)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (_animal.isEmpty() == <span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (_animal == <span class="hljs-string">u8&quot;狗&quot;</span>)<br>&#123;<br><span class="hljs-comment">//各种复制粘贴的代码</span><br>ui-&gt;label-&gt;setText(<span class="hljs-string">u8&quot;狗有4条腿&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_animal == <span class="hljs-string">u8&quot;海鸥&quot;</span>)<br>&#123;<br><span class="hljs-comment">//各种复制粘贴的代码</span><br>ui-&gt;label-&gt;setText(<span class="hljs-string">u8&quot;海鸥有2条腿&quot;</span>); <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_animal == <span class="hljs-string">u8&quot;螃蟹&quot;</span>)<br>&#123;<br><span class="hljs-comment">//各种复制粘贴的代码</span><br>ui-&gt;label-&gt;setText(<span class="hljs-string">u8&quot;螃蟹有8条腿&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>这么写代码通常伴随着大量的复制粘贴，如果代码中不存在大量重复代码，这么写也可以接受。</li><li>如果后期经常需要增加<code>else-if</code>，这么写多少有点不妥。</li></ol><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>上述问题可以通过map映射的方式解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Animals</span></span><br><span class="hljs-class">&#123;</span><br>DOG,<br>CRAB,<span class="hljs-comment">//螃蟹</span><br>SEA_MEW <span class="hljs-comment">//海鸥</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimalInfo</span></span><br><span class="hljs-class">&#123;</span><br>AnimalInfo(QString _name, <span class="hljs-keyword">int</span> _legs) :<br>name(_name),<br>legs(_legs) &#123;&#125;<br><br>QString name;<br><span class="hljs-keyword">int</span> legs;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    MainWindow(QWidget *parent = <span class="hljs-literal">nullptr</span>);<br>    ~MainWindow();<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString&amp; _animal)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showInfo2</span><span class="hljs-params">(Animals _animal)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;Animals, AnimalInfo&gt; ANIMAL_MAP =<br>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;Animals, AnimalInfo&gt;(DOG, AnimalInfo(<span class="hljs-string">u8&quot;狗&quot;</span>, <span class="hljs-number">4</span>)),<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;Animals, AnimalInfo&gt;(CRAB, AnimalInfo(<span class="hljs-string">u8&quot;螃蟹&quot;</span>, <span class="hljs-number">8</span>)),<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;Animals, AnimalInfo&gt;(SEA_MEW, AnimalInfo(<span class="hljs-string">u8&quot;海鸥&quot;</span>, <span class="hljs-number">2</span>)),<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::showInfo</span><span class="hljs-params">(Animals _animal)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> it = ANIMAL_MAP.find(_animal);<br><span class="hljs-keyword">if</span> (ANIMAL_MAP.end() == it)<br><span class="hljs-keyword">return</span>;<br><br>QString animalsInfoText = QString(<span class="hljs-string">u8&quot;%1有%2条腿&quot;</span>)<br>.arg(it-&gt;second.name).arg(it-&gt;second.legs);<br><br>ui-&gt;label-&gt;setText(animalsInfoText);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>所有逻辑在最开始就已经写好，后期增加可能只需要修改<code>ANIMAL_MAP</code>，比使用<code>if-else</code>更加一目了然。</li><li>将<code>showInfo</code>的参数由字符串改为枚举，更方便在编译器发现问题。</li></ol><h2 id="界面状态的复杂逻辑"><a href="#界面状态的复杂逻辑" class="headerlink" title="界面状态的复杂逻辑"></a>界面状态的复杂逻辑</h2><p>可以借助<code>QStackedWidget</code>，<code>QButtonGroup</code>与<code>std::vector</code>、<code>std::map</code>配合来处理一些界面上的复杂逻辑。</p><p><img src="image-20210603195502508.png"></p><p>如上图所示，切换第一行的按钮，会改变第二行按钮的可点击状态，点第二个按钮会执行相关操作：</p><p><code>mainwindow.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDialog&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QButtonGroup&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class">&#123;</span><br>SEA_MEW, <span class="hljs-comment">//海鸥</span><br>DOG, <span class="hljs-comment">//小狗</span><br>CRAB <span class="hljs-comment">//螃蟹</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Skill</span></span><br><span class="hljs-class">&#123;</span><br>SWIM,<span class="hljs-comment">//游</span><br>FLY, <span class="hljs-comment">//飞</span><br>RUN, <span class="hljs-comment">//跑</span><br>&#125;;<br><br><span class="hljs-keyword">using</span> SkillSet = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Skill&gt;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimalInfo</span></span><br><span class="hljs-class">&#123;</span><br>AnimalInfo(Animal _animal, QString _name, SkillSet _skills)<br>: animal(_animal)<br>, skills(_skills)<br>, name(_name)&#123;&#125;<br><br>Animal animal;<br>QString name;<br>SkillSet skills;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainWindow</span> :</span> <span class="hljs-keyword">public</span> QDialog<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MainWindow</span><span class="hljs-params">(QWidget *parent = <span class="hljs-literal">nullptr</span>)</span></span>;<br><br>signals:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toDo</span><span class="hljs-params">(Animal, Skill)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initUI</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setConnects</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>QButtonGroup* animalButtonGroup_ = <span class="hljs-literal">nullptr</span>;<br>QButtonGroup* skillButtonGroup_ = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;Skill, QString&gt;&gt;SKILL_VECTOR =<br>&#123;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;Skill, QString&gt;(Skill::SWIM, <span class="hljs-string">u8&quot;游&quot;</span>),<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;Skill, QString&gt;(Skill::FLY, <span class="hljs-string">u8&quot;飞&quot;</span>),<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;Skill, QString&gt;(Skill::RUN, <span class="hljs-string">u8&quot;跑&quot;</span>),<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;AnimalInfo&gt; ANIMAL_INFO_VECTOR = <br>&#123;<br>AnimalInfo(Animal::SEA_MEW, <span class="hljs-string">u8&quot;海鸥&quot;</span>, &#123;<br>Skill::SWIM,<br>Skill::FLY,<br>Skill::RUN,<br>&#125;),<br><br>AnimalInfo(Animal::DOG, <span class="hljs-string">u8&quot;小狗&quot;</span>,&#123;<br>Skill::RUN,<br>&#125;),<br><br>AnimalInfo(Animal::CRAB, <span class="hljs-string">u8&quot;螃蟹&quot;</span>,&#123;<br>Skill::SWIM,<br>Skill::RUN,<br>&#125;),<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>mainwindow.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QPushButton&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMessageBox&gt;</span></span><br><br>MainWindow::MainWindow(QWidget *parent) :<br>QDialog(parent)<br>&#123;<br>initUI();<br>setConnects();<br>animalButtonGroup_-&gt;button(<span class="hljs-number">0</span>)-&gt;click();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::initUI</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>animalButtonGroup_ = <span class="hljs-keyword">new</span> QButtonGroup(<span class="hljs-keyword">this</span>);<br>QHBoxLayout* animalHLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>animalHLayout-&gt;setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>animalHLayout-&gt;setSpacing(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : ANIMAL_INFO_VECTOR)<br>&#123;<br><span class="hljs-keyword">auto</span> button = <span class="hljs-keyword">new</span> QPushButton(it.name, <span class="hljs-keyword">this</span>);<br>button-&gt;setCheckable(<span class="hljs-literal">true</span>);<br>animalHLayout-&gt;addWidget(button);<br>animalButtonGroup_-&gt;addButton(button, animalButtonGroup_-&gt;buttons().size());<br>&#125;<br><br>skillButtonGroup_ = <span class="hljs-keyword">new</span> QButtonGroup(<span class="hljs-keyword">this</span>);<br>QHBoxLayout* skillHLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>skillHLayout-&gt;setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>skillHLayout-&gt;setSpacing(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : SKILL_VECTOR)<br>&#123;<br><span class="hljs-keyword">auto</span> button = <span class="hljs-keyword">new</span> QPushButton(it.second, <span class="hljs-keyword">this</span>);<br>skillHLayout-&gt;addWidget(button);<br>skillButtonGroup_-&gt;addButton(button, skillButtonGroup_-&gt;buttons().size());<br>&#125;<br><br>QVBoxLayout* mainVLayout = <span class="hljs-keyword">new</span> QVBoxLayout;<br>mainVLayout-&gt;setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>mainVLayout-&gt;setSpacing(<span class="hljs-number">20</span>);<br><br>mainVLayout-&gt;addLayout(animalHLayout);<br>mainVLayout-&gt;addLayout(skillHLayout);<br>mainVLayout-&gt;addStretch(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">this</span>-&gt;setLayout(mainVLayout);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::setConnects</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>connect(animalButtonGroup_, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>(QButtonGroup::*)(<span class="hljs-keyword">int</span>)&gt;(&amp;QButtonGroup::buttonClicked),<br>[=](<span class="hljs-keyword">int</span> _id) &#123;<br><span class="hljs-keyword">if</span> (_id &lt; <span class="hljs-number">0</span> || _id &gt;= ANIMAL_INFO_VECTOR.size())<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">auto</span> skills = ANIMAL_INFO_VECTOR[_id].skills;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; SKILL_VECTOR.size(); i++)<br>&#123;<br><span class="hljs-keyword">auto</span> skill = SKILL_VECTOR[i].first;<br><span class="hljs-keyword">auto</span> it = skills.find(skill);<br><span class="hljs-keyword">if</span> (it != skills.end())<br>skillButtonGroup_-&gt;button(i)-&gt;setEnabled(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">else</span><br>skillButtonGroup_-&gt;button(i)-&gt;setEnabled(<span class="hljs-literal">false</span>);<br>&#125;<br>&#125;);<br><br>connect(skillButtonGroup_, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>(QButtonGroup::*)(QAbstractButton *)&gt;(&amp;QButtonGroup::buttonClicked),<br>[=](QAbstractButton *button) &#123; <br><span class="hljs-keyword">if</span> (button == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">auto</span> animalID = animalButtonGroup_-&gt;checkedId();<br>QString animalName = ANIMAL_INFO_VECTOR[animalID].name;<br>QString contentToShow = QString(<span class="hljs-string">u8&quot;%1会%2&quot;</span>).arg(animalName).arg(button-&gt;text());<br>QMessageBox::information(<span class="hljs-keyword">this</span>, <span class="hljs-string">u8&quot;提示&quot;</span>, contentToShow);<br>&#125;);<br><br><span class="hljs-comment">//connect(skillButtonGroup_, static_cast&lt;void(QButtonGroup::*)(int)&gt;(&amp;QButtonGroup::buttonClicked),</span><br><span class="hljs-comment">//[=](int _id) &#123;</span><br><span class="hljs-comment">//if (_id &lt; 0 || _id &gt;= SKILL_VECTOR.size())</span><br><span class="hljs-comment">//return;</span><br><br><span class="hljs-comment">//auto animalID = animalButtonGroup_-&gt;checkedId();</span><br><span class="hljs-comment">//auto animal = ANIMAL_INFO_VECTOR[animalID].animal;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//emit toDo(animal, SKILL_VECTOR[_id].first);</span><br><span class="hljs-comment">//&#125;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如图所示：</p><p><img src="image-20210603200048781.png"></p><ol><li>配合<code>animalButtonGroup_</code>和<code>skillButtonGroup_</code>两个<code>QButtonGroup</code>，界面从创建到交互所需信息都包含到了<code>SKILL_VECTOR</code>、<code>ANIMAL_INFO_VECTOR</code>中。</li><li>第二行按钮的置灰逻辑只有12行代码，逻辑清晰且不受按钮个数增加的影响。</li><li>注释部分代码更像是日常使用（其上方代码只是为了演示），配合Qt反射实现的简单工厂模式（参见<code>简单工厂模式与Qt类反射2</code>）能使代码更加符合开-闭原则。</li></ol><h2 id="职责链"><a href="#职责链" class="headerlink" title="职责链"></a>职责链</h2><p>职责链模式有时也能减少该类<code>if-else</code>的出现。</p><h2 id="多态、工厂模式"><a href="#多态、工厂模式" class="headerlink" title="多态、工厂模式"></a>多态、工厂模式</h2><p>多态、工厂模式也是解决该类问题的有效方法，具体可参见<code>简单工厂模式与Qt类反射2</code>。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>编码规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码中的if…else杂谈2</title>
    <link href="/noob/2021/05/30/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84if%E2%80%A6else%E6%9D%82%E8%B0%882/"/>
    <url>/noob/2021/05/30/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84if%E2%80%A6else%E6%9D%82%E8%B0%882/</url>
    
    <content type="html"><![CDATA[<blockquote><p>if-else嵌套过深的几个解决方法-重载&lt;为主要例子。</p><span id="more"></span></blockquote><p><code>std::map</code>是我们常用的容器，虽然<code>c++11</code>后引入<code>std::unordered_map</code>减少了其“出镜率”，但是在<code>key</code>有序或对内存使用有严格要求时，<code>std::map</code>仍有其用武之地；<code>std::map</code>的内部实现是<code>红黑树</code>，<code>std::unordered_map</code>的实现方式是<code>哈希表</code>（也称<code>散列表</code>）</p><blockquote><p>std::map 是有序键值对容器，它的元素的键是唯一的。用比较函数 Compare 排序键。搜索、移除和插入操作拥有对数复杂度。 map 通常实现为红黑树。</p><p>在每个标准库使用比较 (Compare) 概念的位置，以等价关系检验唯一性。不精确而言，若二个对象 a 与 b 互相比较不小于对方 ： !comp(a, b) &amp;&amp; !comp(b, a) ，则认为它们等价（非唯一）。</p><p>unordered_map 是关联容器，含有带唯一键的键-值 pair 。搜索、插入和元素移除拥有平均常数时间复杂度。</p><p>元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于其键的哈希。这允许对单独元素的快速访问，因为一旦计算哈希，则它准确指代元素所放进的桶。</p><p>–引自<a href="https://zh.cppreference.com/w/cpp/container/map">std::map - cppreference.com</a>和<a href="https://zh.cppreference.com/w/cpp/container/unordered_map">std::unordered_map - cppreference.com</a></p></blockquote><p>由上文总结可得：</p><table><thead><tr><th>名称</th><th>std::map</th><th>std::unordered_map</th></tr></thead><tbody><tr><td>有序性</td><td><strong>有序</strong></td><td>无序</td></tr><tr><td>内部实现</td><td>红黑树</td><td>哈希表</td></tr><tr><td>平均时间复杂度</td><td>O(logN)</td><td><strong>O(1)</strong></td></tr><tr><td>内存占用</td><td></td><td>高，类似于vector,需要提前申请内存，用以存储哈希表</td></tr><tr><td>要求</td><td>实现 &lt;</td><td>有哈希函数</td></tr></tbody></table><h2 id="重载-lt"><a href="#重载-lt" class="headerlink" title="重载 &lt;"></a>重载 &lt;</h2><p>有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point3D</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br><span class="hljs-keyword">int</span> z;<br>&#125;;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;Point3D, <span class="hljs-keyword">double</span>&gt; pointMap;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QCoreApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>Point3D point1;<br>point1.x = <span class="hljs-number">1</span>;<br>point1.y = <span class="hljs-number">2</span>;<br>point1.z = <span class="hljs-number">3</span>;<br>pointMap.insert(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;Point3D, <span class="hljs-keyword">double</span>&gt;(point1, <span class="hljs-number">1.0</span>));<br><br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br></code></pre></td></tr></table></figure><p>无法通过编译，在<code>VS2017 X64</code>下提示如下错误：</p><blockquote><p>错误    C2678    二进制“&lt;”: 没有找到接受“const _Ty”类型的左操作数的运算符(或没有可接受的转换)</p></blockquote><p>很显然，<code>Point3D</code>需要重载<code>&lt;</code>。</p><h3 id="第一次重载-lt"><a href="#第一次重载-lt" class="headerlink" title="第一次重载  &lt;"></a>第一次重载  &lt;</h3><p>记得第一次遇到这问题时，系统某个数据结构是个<strong>三段式</strong>，第一次写出了类似这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point3D</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br><span class="hljs-keyword">int</span> z;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Point3D&amp; rhs) <span class="hljs-keyword">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (x &lt;= rhs.x)<br>&#123;<br><span class="hljs-keyword">if</span> (x &lt; rhs.x)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//相等</span><br>&#123;<br><span class="hljs-keyword">if</span> (y &lt;= rhs.y)<br>&#123;<br><span class="hljs-keyword">if</span> (y &lt; rhs.y)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//相等</span><br>&#123;<br><span class="hljs-keyword">return</span> z &lt;= rhs.z;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>工程中全文搜索<code>operator &lt;</code>-复制-粘贴老代码-修改，一气呵成。</p><h3 id="方法1：提前return"><a href="#方法1：提前return" class="headerlink" title="方法1：提前return"></a>方法1：提前return</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point3D</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br><span class="hljs-keyword">int</span> z;<br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Point3D&amp; rhs) <span class="hljs-keyword">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (x &gt; rhs.x)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (x &lt; rhs.x)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span> (y &gt; rhs.y)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">if</span> (y &lt; rhs.y)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">return</span> z &lt; rhs.z;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该方法降低了嵌套层数。</p><p>对于某些条件不符合需要立即返回的应立即返回，比如判断指针为<code>nullptr</code>、<code>ComboBox</code>的<code>index == -1</code>，<code>std::vector::empty()</code>等。</p><p>提交代码-颇费~</p><p>没想到C++11后，该方法又有点跟不上时代了</p><h3 id="方法2：C-11方法"><a href="#方法2：C-11方法" class="headerlink" title="方法2：C++11方法"></a>方法2：C++11方法</h3><p>C++引入了<code>std::tuple</code> ,有时<em>cppreference中文版</em>真是难懂，这里贴出来其英文版上关于<code>std::tuple</code>的介绍</p><blockquote><p>Class template <code>std::tuple</code> is a fixed-size collection of heterogeneous values. It is a generalization of <a href="https://en.cppreference.com/w/cpp/utility/pair">std::pair</a>.</p></blockquote><p><code>std::tuple</code>已经重载了如下操作符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">operator</span>==<br><span class="hljs-keyword">operator</span>!=<br><span class="hljs-keyword">operator</span>&lt;<br><span class="hljs-keyword">operator</span>&lt;=<br><span class="hljs-keyword">operator</span>&gt;<br><span class="hljs-keyword">operator</span>&gt;=<br><span class="hljs-keyword">operator</span>&lt;=&gt;(C++<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>关于 <code>&lt;</code> 有如下介绍：</p><blockquote><p>Compares <code>lhs</code> and <code>rhs</code> lexicographically by operator&lt;, that is, compares the first elements, if they are equivalent, compares the second elements, if those are equivalent, compares the third elements, and so on.</p><p>For non-empty tuples, (3) is equivalent to</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(lhs) &lt; <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(rhs)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(rhs) &lt; <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">0</span>&gt;(lhs)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(lhs) &lt; <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(rhs)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(rhs) &lt; <span class="hljs-built_in">std</span>::get&lt;<span class="hljs-number">1</span>&gt;(lhs)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>...<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::get&lt;N - <span class="hljs-number">1</span>&gt;(lhs) &lt; <span class="hljs-built_in">std</span>::get&lt;N - <span class="hljs-number">1</span>&gt;(rhs);<br></code></pre></td></tr></table></figure></blockquote><p>可有看得出，他也是通过提前return实现的。</p><p>所以我们可以借助<code>std::tie</code>,创造两个临时的<code>std::tuple</code> ，让<code>std::tuple</code>们自己去比较大小。</p><blockquote><p><code>std::tie</code>：Creates a tuple of lvalue references to its arguments or instances of <a href="https://en.cppreference.com/w/cpp/utility/tuple/ignore">std::ignore</a>.</p></blockquote><p>所以在<code>c++11</code> -<code>c++17</code>版本中，<code>struct</code>重载<code>&lt;</code>，可以最终简化为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point3D</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x;<br><span class="hljs-keyword">int</span> y;<br><span class="hljs-keyword">int</span> z;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> Point3D&amp; rhs) <span class="hljs-keyword">const</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::tie(x, y, z) &lt; <span class="hljs-built_in">std</span>::tie(rhs.x, rhs.y, rhs.z);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从<code>C++20</code>起，可以使用新操作符<code>&lt;=&gt;</code>代替被废弃的<code>&lt;</code></p><blockquote><p>The <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, and <code>!=</code> operators are <a href="https://en.cppreference.com/w/cpp/language/operators#Relational_operators">synthesized</a> from <code>operator&lt;=&gt;</code> and <code>operator==</code> respectively. (since C++20)</p></blockquote><h3 id="防止嵌套过程其他方法：合并条件"><a href="#防止嵌套过程其他方法：合并条件" class="headerlink" title="防止嵌套过程其他方法：合并条件"></a>防止嵌套过程其他方法：合并条件</h3><p>对于可以合并的条件应该将其合并，这样能减少路径，降低阅读、维护、单元测试难度。特别是某些只有if没有else的语句，合并后不仅能减少路径，甚至还能减少嵌套层数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (point1.x == <span class="hljs-number">3</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (point1.y == <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (point1.z == <span class="hljs-number">5</span>)<br>&#123;<br>...<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以合并为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (point1.x == <span class="hljs-number">3</span> &amp;&amp; point1.y == <span class="hljs-number">4</span> &amp;&amp; point1.z == <span class="hljs-number">5</span>)<br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.cppreference.com/w/cpp/container/map">cppreference-map</a></p><p><a href="https://zh.cppreference.com/w/cpp/container/unordered_map">cppreference-unordered_map</a></p><p><a href="https://en.cppreference.com/w/cpp/utility/tuple">cppreference-tuple</a></p><p><a href="https://en.cppreference.com/w/cpp/utility/tuple/tie">cppreference-tie</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>编码规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码中的if…else杂谈1</title>
    <link href="/noob/2021/05/29/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84if%E2%80%A6else%E6%9D%82%E8%B0%881/"/>
    <url>/noob/2021/05/29/%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84if%E2%80%A6else%E6%9D%82%E8%B0%881/</url>
    
    <content type="html"><![CDATA[<blockquote><p>if-else过多的部分问题分析。</p></blockquote><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="if_image.jpg"></p><p>很多编码规范/设计模式/重构方面的书、很多公司的编码规范都提到过if-else嵌套过深/if-else过多这些个“坏味道”，公司的或从学校出来的”屎山代码”或多或少有这些味道，形如：</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(...)<br>&#123;<br>    <span class="hljs-keyword">if</span>(...)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(...)<br>        &#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(...)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(...)<br>        &#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种类型的if-else应该是最应该避免的，因为这么写的问题最多：</p><ol><li>维护困难：当嵌套层数太深后，想搞明白整段代码相当困难；</li><li>单元测试困难：需要的测试用例太多，很难覆盖所有情况；</li><li>误导“后浪”：坏的习惯会传染人，特别是当新人维护这段代码时很容易就把这种不好的习惯学走；就算是老人维护，在时间紧张或怕无法理清楚整体逻辑时，只能继续嵌套更多if-else，让代码“莫名其妙的”正确运行起来。</li><li>影响预读和cache命中：两年前面试时被问到了这个问题，当时只提到了前面几点，后来才想起来面试官最想要这个答案，愧对我的导师兼《微机原理》课老师。CPU都是多级流水线架构运行，如果分支预测成功，很多指令都提前进入流水线流程中，则流水线中指令运行的非常顺畅，而如果分支预测失败，则需要清空流水线中的那些预测出来的指令，重新加载正确的指令到流水线中执行，然而现代CPU的流水线级数非常长，分支预测失败会损失10-20个左右的<a href="http://www.hqchip.com/app/1045">时钟</a>周期，因此对于复杂的流水线，好的分支预测方法非常重要。（引自<a href="http://www.elecfans.com/d/1491355.html">if-else的效率有多低你知道吗？-电子发烧友网 (elecfans.com)</a>;</li></ol><p>又如：</p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(...)<br>&#123;<br>    ...<span class="hljs-comment">//重复一堆</span><br>    type = <span class="hljs-string">u8&quot;狗&quot;</span>;<br>    ...<span class="hljs-comment">//重复一堆</span><br>    legs = <span class="hljs-number">4</span>;<br>    run(type, legs);<br>    ...<span class="hljs-comment">//其他重复一堆</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(...)<br>&#123;<br>    ...<span class="hljs-comment">//重复一堆</span><br>    type = <span class="hljs-string">u8&quot;海鸥&quot;</span>;<br>    ...<span class="hljs-comment">//重复一堆</span><br>    legs = <span class="hljs-number">2</span>;<br>    run(type, legs);<br>    ...<span class="hljs-comment">//其他重复一堆</span><br>&#125;<br><br>...<br>    <br><span class="hljs-keyword">else</span><br>&#123;<br>    ...<span class="hljs-comment">//重复一堆</span><br>    type = <span class="hljs-string">u8&quot;螃蟹&quot;</span>;<br>    ...<span class="hljs-comment">//重复一堆</span><br>    legs = <span class="hljs-number">8</span>;<br>    run(type, legs);<br>    ...<span class="hljs-comment">//其他重复一堆</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>个人感觉这种链式的if-else可以接受；</li><li>但是这种写法经常会伴随着大量的复制-粘贴，这就有“坏味道”了。</li><li><code>switch-case</code>也有同样的问题。</li></ol><p>更有甚者：</p><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> b1; <span class="hljs-comment">//(就不初始化 (¬､¬))</span><br><span class="hljs-keyword">bool</span> b2;<br><span class="hljs-keyword">bool</span> b3;<br><span class="hljs-keyword">bool</span> b4;<br><span class="hljs-keyword">bool</span> b5;<br>... <span class="hljs-comment">//省略同一函数中1024条代码</span><br>b1 = <span class="hljs-literal">true</span>;<br>...<br>b2 = <span class="hljs-literal">false</span>;<br>b3 = <span class="hljs-literal">true</span>;<br>... <span class="hljs-comment">//省略同一函数中又1024条代码</span><br>b4 = <span class="hljs-literal">false</span>;<br>b5 = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span>(b1 &amp;&amp; b2 || !b3 &amp;&amp; b4 || b5)<br>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!b1 || b2 &amp;&amp; !b3 &amp;&amp; b4 || b5)<br>&#123;<br>    <br>&#125;<br>...<span class="hljs-comment">//省略10086种情况</span><br><span class="hljs-keyword">else</span><br>&#123;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>学校出来的代码不少这么写的，丝毫没有夸张成分。这已经不仅仅是if-else多的问题了，还有个滥用标志位的问题：</p><ol><li>标志位不初始化；</li><li><code>RadioButton</code>的按下状态需要标志位记录；</li><li><code>vector::empty()</code>是否为<code>true</code>需要标志位记录；</li><li><code>ComboBox</code>是否选择第一行需要标志位记录；</li><li>……</li></ol><p>类大、函数长</p><blockquote><p>（假如我的一个函数能实现5个功能，一个类有50个这种函数，那么我这个类就可以实现250个功能， 我真是个小机灵鬼(¬､¬)）</p></blockquote><p>标志位多、if-else一长串，维护起来相当困难。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人感觉<code>if-else</code>既不是洪水猛兽，也不能放任发展。不能要求每个人都会<code>设计模式</code>，况且大佬们对是否应该使用<code>设计模式</code>都意见不一。日常编码中注意最常见的问题即可，没必要反<code>if-else</code>反到“洁癖”。。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="http://www.elecfans.com/d/1491355.html">电子发烧友网</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>编码规范</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式与信号中心3</title>
    <link href="/noob/2021/05/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E4%B8%AD%E5%BF%833/"/>
    <url>/noob/2021/05/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E4%B8%AD%E5%BF%833/</url>
    
    <content type="html"><![CDATA[<blockquote><p>信号中心的实现及其注意事项。</p></blockquote><span id="more"></span><h2 id="信号中心"><a href="#信号中心" class="headerlink" title="信号中心"></a>信号中心</h2><p>信号中心用来转发<strong>单例模式与信号中心1-开头问题</strong>中的信号，可大大减少信号的传递次数和函数调用的层数，其实现方式如下所示：</p><p><code>signalcenter.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QObject&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SignalCenter</span> :</span> <span class="hljs-keyword">public</span> QObject<br>&#123;<br>Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>SignalCenter(<span class="hljs-keyword">const</span> SignalCenter&amp;) = <span class="hljs-keyword">delete</span>;<br>SignalCenter(SignalCenter&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>SignalCenter&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> SignalCenter&amp;) = <span class="hljs-keyword">delete</span>;<br>SignalCenter&amp; <span class="hljs-keyword">operator</span>=(SignalCenter&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> SignalCenter&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">static</span> SignalCenter instance;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>SignalCenter() = <span class="hljs-keyword">default</span>;<br><br>signals:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">senderButtonClicked</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>该类需继承自<code>QObject</code>;</li><li>使用<code>Q_OBJECT</code>宏并定义相关信号。</li></ol><p><code>senderframe.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;senderframe.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;signalcenter.h&quot;</span></span><br><br>SenderFrame::SenderFrame(QWidget *parent) :<br>    QFrame(parent)<br>&#123;<br>init();<br>&#125;<br><br>SenderFrame::~SenderFrame()<br>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SenderFrame::init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>button_ = <span class="hljs-keyword">new</span> QPushButton(<span class="hljs-string">u8&quot;发送&quot;</span>,<span class="hljs-keyword">this</span>);<br><br>QHBoxLayout* hLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>hLayout-&gt;addWidget(button_);<br><br><span class="hljs-keyword">this</span>-&gt;setLayout(hLayout);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;background:blue;&quot;</span>);<br><br><span class="hljs-comment">//为了演示简单，将connect写在了类里面，这样会导致该类所有的实例都会connect</span><br>connect(button_, &amp;QPushButton::clicked, <br>&amp;SignalCenter::getInstance(), &amp;SignalCenter::senderButtonClicked);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>receiverframe.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;receiverframe.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;signalcenter.h&quot;</span></span><br><br>ReceiverFrame::ReceiverFrame(QWidget *parent) :<br>    QFrame(parent)<br>&#123;<br>init();<br>&#125;<br><br>ReceiverFrame::~ReceiverFrame()<br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReceiverFrame::init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>label_ = <span class="hljs-keyword">new</span> QLabel(<span class="hljs-keyword">this</span>);<br><br>QHBoxLayout* hLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>hLayout-&gt;addWidget(label_);<br><br><span class="hljs-keyword">this</span>-&gt;setLayout(hLayout);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;background:green;&quot;</span>);<br><br><span class="hljs-comment">//为了演示简单，将connect写在在类里面，这样会导致该类所有的实例都会connect</span><br>connect(&amp;SignalCenter::getInstance(), &amp;SignalCenter::senderButtonClicked, [=]() &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>label_-&gt;setText(QString(<span class="hljs-string">u8&quot;第%1次点击&quot;</span>).arg(++i));<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>senderframe.cpp</code>、<code>receiverframe.cpp</code>中各自与<code>SignalCenter</code>单例类<code>connect</code>，借助于<code>SignalCenter</code>单例类完成了信号的转发；</li><li>如注释所言，为了演示简单，该例将<code>connect</code>写在了类里面，这样会导致该类所有的实例都会<code>connect</code>,比如<code>ReceiverFrame</code>类公用，被实例化了两个实例，这样会导致点击一次按钮，两个实例都改变文字。所以将与<code>SignalCenter</code>单例类的<code>connect</code>，放到其父控件中更合适。</li></ol><p><code>mainwindow.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;receiverframe.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;senderframe.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QHBoxLayout&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QDateTime&gt;</span></span><br><br>MainWindow::MainWindow(QWidget *parent)<br>    : QDialog(parent)<br>&#123;<br>init();<br>&#125;<br><br>MainWindow::~MainWindow()<br>&#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> senderFrame = <span class="hljs-keyword">new</span> SenderFrame(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">auto</span> receiverFrame = <span class="hljs-keyword">new</span> ReceiverFrame(<span class="hljs-keyword">this</span>);<br><br>QHBoxLayout* hLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>hLayout-&gt;setContentsMargins(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>hLayout-&gt;setSpacing(<span class="hljs-number">20</span>);<br><br>hLayout-&gt;addWidget(senderFrame);<br>hLayout-&gt;addWidget(receiverFrame);<br><br><span class="hljs-keyword">this</span>-&gt;setLayout(hLayout);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;background:yellow;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setFixedSize(<span class="hljs-number">600</span>, <span class="hljs-number">400</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，在<code>mainwindow.cpp</code>中只是实例化了<code>SenderFrame</code>和<code>ReceiverFrame</code>类，并没有<code>connect</code>二者，但是信号正常的由<code>SenderFrame</code>发送到了<code>ReceiverFrame</code>类。运行结果如下：</p><p><img src="image-20210528201626561.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式与Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式与信号中心2</title>
    <link href="/noob/2021/05/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E4%B8%AD%E5%BF%832/"/>
    <url>/noob/2021/05/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E4%B8%AD%E5%BF%832/</url>
    
    <content type="html"><![CDATA[<blockquote><p>单例模式懒汉式实现的几种实现方式及其优缺点、最推荐的单例模式。</p></blockquote><span id="more"></span><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式：默认不会实例化，当需要的时候才会实例化。特点是延迟加载。</p><h4 id="最常规的实现"><a href="#最常规的实现" class="headerlink" title="最常规的实现"></a>最常规的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">//省略上文中的注释1和注释2</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> Singleton * <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>)<br>instance = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">static</span> Singleton *instance;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>只有当第一次调用<code>getInstance()</code>方法时，才会实例化该单例类；</li><li>该实现方式只适用于单线程环境下，如果多个线程同时第一次执行<code>if (instance == nullptr)</code>判断<code>instance </code>是否为空，此时所有的线程都会去实例化该单例，导致单例不再”单”；</li></ol><p><strong>该实现方法只可应用于单线程环境中。</strong></p><h4 id="加锁实现"><a href="#加锁实现" class="headerlink" title="加锁实现"></a>加锁实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//省略上文中的注释1和注释2</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> Singleton * <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mutex)</span></span>;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>)<br>instance = <span class="hljs-keyword">new</span> Singleton();<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">static</span> Singleton *instance;<br><span class="hljs-keyword">static</span> QMutex mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>同上1；</li><li>由于锁的存在，该实现方法可以应用于多线程环境中，不会出现上2的问题；</li><li>每次调用<code>getInstance()</code>函数都要进入临界区，消耗略大。</li></ol><h4 id="双检锁实现"><a href="#双检锁实现" class="headerlink" title="双检锁实现"></a>双检锁实现</h4><p>能不能只在没有实例化单例类时加锁呢？双检锁实现就是这种思路。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//省略上文中的注释1和注释2</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> Singleton * <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//①只有在instance为空时才需要加锁-构造-解锁</span><br>&#123;<br><span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mutex)</span></span>;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>)<br>instance = <span class="hljs-keyword">new</span> Singleton(); <span class="hljs-comment">//②</span><br>&#125;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">static</span> Singleton *instance;<br><span class="hljs-keyword">static</span> QMutex mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>只比<strong>加锁实现</strong>多了一行代码，就大大提高了效率。</li><li>该实现方法存在着一个严重的问题：构造过程不是原子操作，好巧不巧，在某些平台上会出现A线程正在②处执行构造，B线程来到①处判空，如果此时构造不完全，但是<code>instance</code>指针已被赋值，那么B线程会拿着一个未构造完全的实例使用。</li></ol><p><strong>遗憾的是C++11以前的版本对此无能为力。</strong></p><p>《Head First 设计模式》中有提到在<code>java</code>语言中，可以通过在声明变量时加<code>volatile</code>关键词解决这个问题，其他地方类似于C++双检锁实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;<br></code></pre></td></tr></table></figure><p>该书注释中提到，在1.4及更早版本的<code>java</code>中，许多<code>JVM</code>对于<code>volatile</code>关键字的实现会导致双检锁的失效。</p><p>网上搜了以下，这是一个非常远古的版本。。。。。而我们的C++一直到C++11才解决该问题，orz。这难能可贵的重大更新，赶快”早买早享受”啊。</p><h4 id="C-11实现"><a href="#C-11实现" class="headerlink" title="C++11实现"></a>C++11实现</h4><p>在C++11标准中，新增对于局部静态变量初始化具有线程安全性的要求。</p><blockquote><p>Variables declared at block scope with the specifier <code>static</code> or <code>thread_local</code> (since C++11) have static or thread (since C++11) storage duration but are initialized the first time control passes through their declaration (unless their initialization is <a href="https://en.cppreference.com/w/cpp/language/zero_initialization">zero-</a> or <a href="https://en.cppreference.com/w/cpp/language/constant_initialization">constant-initialization</a>, which can be performed before the block is first entered). On all further calls, the declaration is skipped.</p><p>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with <a href="https://en.cppreference.com/w/cpp/thread/call_once">std::call_once</a>).</p><p>Note: usual implementations of this feature use variants of the double-checked locking pattern, which reduces runtime overhead for already-initialized local statics to a single non-atomic boolean comparison.</p></blockquote><p>所以可以借助该特性，采用如下的方式实现单例类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//省略上文中的注释1和注释2</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> Singleton &amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">static</span> Singleton instance;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>只有当第一次调用<code>getInstance()</code>方法时，才会实例化该单例类</li><li>如果多个线程试图同时初始化同一静态局部变量，则初始化严格发生一次，所以该实现是线程安全的，颇费~</li></ol><p>其他实现可以围观这位大佬的博客，真是大开眼界<a href="https://www.cnblogs.com/zxh1210603696/p/4157294.html">C++程序员们，快来写最简洁的单例模式吧 - 老司机 - 博客园 (cnblogs.com)</a>，也侧面反映了C++的难度。。。。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/zxh1210603696/p/4157294.html">博客园</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://en.cppreference.com/w/cpp/language/storage_duration#.E9.9D.99.E6.80.81.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F">cppreference</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.cnblogs.com/sunchaothu/p/10389842.html">博客园</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>设计模式与Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式与信号中心1</title>
    <link href="/noob/2021/05/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E4%B8%AD%E5%BF%831/"/>
    <url>/noob/2021/05/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%A1%E5%8F%B7%E4%B8%AD%E5%BF%831/</url>
    
    <content type="html"><![CDATA[<blockquote><p>信号中心的作用、单例模式介绍、饿汉式方式实现。</p></blockquote><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如下为一较为复杂的界面布局图，假设, A1/A11/A2/A21/分别为独立的控件类，<code>A111</code>为一<code>Button</code>，<code>A211</code>为一<code>Label</code>。<br>需求：当点击<code>Button</code>A111时，<code>Label</code>A211做相应逻辑联动，比如<code>Label</code>显示<code>Button</code>的点击总次数。</p><p><img src="1.png"></p><p>通常的做法是当<code>A111</code>点击时，</p><p><code>A111</code>—-<code>connect</code>—–&gt;<code>A11控件</code>—-<code>connect</code>—–&gt;<code>A1控件</code>—-<code>connect</code>—–&gt;<code>A控件</code>—-<code>connect并set</code>—–&gt;</p><p><code>A2控件</code>—-<code>set</code>—–&gt;<code>A21控件</code>—-<code>set</code>—–&gt;<code>A211控件</code>———-&gt;<code>显示点击总次数</code></p><p>整个流程走下来信号转信号，接口调接口，相当繁琐。</p><p>通常下应该避免出现这种问题，万一有这种需求，可以：</p><ol><li>减少小类封装，以适当减少封装层数；</li><li>提刀去见产品经理；</li><li>信号中心转发信号。</li></ol><p>信号中心通常设计为单例模式。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式（Singleton Pattern）是 <del>Java</del> （也是C++)中最<del>简单</del>(划掉)的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><blockquote><ol><li>单例类只能有一个实例（应该禁止赋值和拷贝）</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol></blockquote><p>引自<a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式 | 菜鸟教程 (runoob.com)</a></p><p>通常的单例模式形式如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Singleton(<span class="hljs-keyword">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">//注释1（下文省略该处）：以下四行对应1禁止赋值和拷贝；</span><br>Singleton(Singleton&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>Singleton&amp; <span class="hljs-keyword">operator</span>=(Singleton&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-function"><span class="hljs-keyword">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> <span class="hljs-comment">//注释3：对应3使用 static 类成员函数`getInstance()`返回唯一实例。</span></span><br><span class="hljs-function"></span>&#123;<br>XXXXXX <span class="hljs-comment">//以下内容专门讨论该处</span><br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Singleton() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">//注释2（下文省略该处）：对应2禁止用户自己声明并定义实例；</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>禁止赋值和拷贝；</li><li>禁止用户自己声明并定义实例；</li><li>使用 static 类成员函数<code>getInstance()</code>返回唯一实例。</li></ol><p>常见的单例模式实现方法分为饿汉式和懒汉式。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式：类加载的时候就实例化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">//省略上文中的注释1和注释2</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> instance;<br>&#125;;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">static</span> Singleton* instance;<br>&#125;;<br><br>Singleton* Singleton::instance = <span class="hljs-keyword">new</span> Singleton;<br><br></code></pre></td></tr></table></figure><p>至此，我们可以说单例模式毕竟是是最简单的设计模式，连实现起来都这么简单，不用理会懒汉式这么多痛苦。颇费~</p><p>但是饿汉式也有不足，就是程序加载时就实例化；</p><ol><li>如果该类实例化需要较长时间，可能会拖慢系统启动时间。</li><li>如果单例类是个不常用的类，并不是每次运行都需要加载，这还会浪费空间。</li></ol><p><strong>即使在不支持C++11的编译器版本，也可将该实现方法应用于多线程环境中。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">runoob.com</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>设计模式与Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂模式与Qt类反射2</title>
    <link href="/noob/2021/05/18/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E7%B1%BB%E5%8F%8D%E5%B0%842/"/>
    <url>/noob/2021/05/18/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E7%B1%BB%E5%8F%8D%E5%B0%842/</url>
    
    <content type="html"><![CDATA[<blockquote><p>反射实现简单工厂模式。</p></blockquote><span id="more"></span><p>前文《简单工厂模式与Qt类反射1》中简单工厂模式缺点3说：<strong>这不就是<code>LanguageShow()</code>函数把违反开闭原则的锅甩给了<code>Factory::CreateObject()</code>函数吗？</strong>，本文通过反射解决该问题。</p><p>之前写过一段时间WPF，受WPF大佬NaBian的控件库 <a href="https://handyorg.github.io/handycontrol/">HandyControl | HandyOrg</a>   <a href="https://github.com/nabian/handycontrol">github.com</a> 启发，知道了C#语言可以通过反射机制实现简单工厂模式。</p><p>但是C++语言本身没有反射机制，只好借用Qt的反射来实现。</p><h2 id="反射实现简单工厂"><a href="#反射实现简单工厂" class="headerlink" title="反射实现简单工厂"></a>反射实现简单工厂</h2><p><code>language.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QObject&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QMetaEnum&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetaEnums</span> :</span> <span class="hljs-keyword">public</span> QObject<br>&#123;<br>Q_OBJECT<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MetaEnums</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span> : <span class="hljs-title">QObject</span><span class="hljs-params">(parent)</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LanguageType</span></span><br><span class="hljs-class">&#123;</span><br>C,<br>CPP,<br>Python<br>&#125;;<br><br>Q_ENUM(LanguageType)<br><br><span class="hljs-function">QString <span class="hljs-title">LanguageTypeToString</span><span class="hljs-params">(LanguageType type)</span></span><br><span class="hljs-function"></span>&#123;<br>QMetaEnum metaEnum = QMetaEnum::fromType&lt;LanguageType&gt;();<br><span class="hljs-keyword">return</span> QString(metaEnum.valueToKey(type)) + <span class="hljs-string">&quot;Language&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LanguageBase</span> :</span> <span class="hljs-keyword">public</span> QObject<br>&#123;<br>Q_OBJECT<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">LanguageBase</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span> : <span class="hljs-title">QObject</span><span class="hljs-params">(parent)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br>Q_OBJECT<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">Q_INVOKABLE <span class="hljs-keyword">explicit</span> <span class="hljs-title">CLanguage</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span> : <span class="hljs-title">LanguageBase</span><span class="hljs-params">(parent)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m C&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPPLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br>Q_OBJECT<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">Q_INVOKABLE <span class="hljs-keyword">explicit</span> <span class="hljs-title">CPPLanguage</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span> : <span class="hljs-title">LanguageBase</span><span class="hljs-params">(parent)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m CPP&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br>Q_OBJECT<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">Q_INVOKABLE <span class="hljs-keyword">explicit</span> <span class="hljs-title">PythonLanguage</span><span class="hljs-params">(QObject *parent = <span class="hljs-literal">nullptr</span>)</span> : <span class="hljs-title">LanguageBase</span><span class="hljs-params">(parent)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m Python&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> cTypeId = qRegisterMetaType&lt;CLanguage*&gt;();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> cppTypeId = qRegisterMetaType&lt;CPPLanguage*&gt;();<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> pythonTypeId = qRegisterMetaType&lt;PythonLanguage*&gt;();<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">LanguageBase* <span class="hljs-title">CreateObject</span><span class="hljs-params">(MetaEnums::LanguageType type)</span></span><br><span class="hljs-function"></span>&#123;<br>MetaEnums metaEnums;<br><span class="hljs-keyword">auto</span> className = metaEnums.LanguageTypeToString(type) + <span class="hljs-string">&quot;*&quot;</span>;<br><br><span class="hljs-keyword">int</span> classTypeID = QMetaType::type(className.toLocal8Bit().data());<br><span class="hljs-keyword">const</span> QMetaObject *theMetaObject = QMetaType::metaObjectForType(classTypeID);<br><span class="hljs-keyword">if</span> (theMetaObject == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>QObject *obj = theMetaObject-&gt;newInstance(Q_ARG(QObject*, <span class="hljs-literal">nullptr</span>));<br>LanguageBase *languageBase = qobject_cast&lt;LanguageBase*&gt;(obj);<br><span class="hljs-keyword">return</span> languageBase;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其他函数同上。</p><p><code>Factory::CreateObject()</code>函数终于不用背违反开闭原则的锅了。</p><p>需要有几个注意事项，否则可能一直Create不出Object。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>需要有<code>LanguageTypeToString()</code>函数将枚举转换为字符串，而且枚举不能用c++11新特性<code>enum class</code>,只能用<code>enum</code>;</p><p>这里如果用<code>switch-case</code>或<code>if-else</code>得到类名，那还不如直接用普通的简单工厂方式；</p></li><li><p>类需要继承自<code>QObject</code>, 且构造函数前面需要加<code>Q_INVOKABLE</code>宏；</p></li><li><p>需要使用<code>qRegisterMetaType</code>函数注册类；</p></li><li><p>注意<code>QMetaObject::newInstance</code>函数传参时<code>Q_ARG</code>的用法。</p></li></ol><p>C++语言没有反射机制的，虽然借助Qt实现了但是实现起来并没有C#优雅、简单，从注意事项可以看出，用起来还是很麻烦的，<del>期待后期</del>通过反射+模板，更简单的实现，参见<a href="https://www.cryfeifei.cn/2020/06/27/qt-yuan-dui-xiang-meta-object-xi-tong/">Qt元对象Meta−Object系统</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式与Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂模式与Qt类反射1</title>
    <link href="/noob/2021/05/18/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E7%B1%BB%E5%8F%8D%E5%B0%841/"/>
    <url>/noob/2021/05/18/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E7%B1%BB%E5%8F%8D%E5%B0%841/</url>
    
    <content type="html"><![CDATA[<blockquote><p>简单工厂模式介绍、实现、优缺点。</p></blockquote><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>平时代码中，经常见到如下的代码，更有甚者，连<code>LanguageShow()</code>函数都没有，直接在<code>main()</code>中写完所有的逻辑，有多少种情况就复制粘贴多少份。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCoreApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LanguageType</span></span><br><span class="hljs-class">&#123;</span><br>C,<br>CPP,<br>Python<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LanguageBase</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//virtual void Do() = 0;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m C&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPPLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m CPP&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m Python&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LanguageShow</span><span class="hljs-params">(LanguageType type)</span></span><br><span class="hljs-function"></span>&#123;<br>LanguageBase* Language = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">switch</span> (type)<br>&#123;<br><span class="hljs-keyword">case</span> LanguageType::C:<br>Language = <span class="hljs-keyword">new</span> CLanguage();<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> LanguageType::CPP:<br>Language = <span class="hljs-keyword">new</span> CPPLanguage();<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> LanguageType::Python:<br>Language = <span class="hljs-keyword">new</span> PythonLanguage();<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>Language = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>Language-&gt;Show();<br><span class="hljs-keyword">delete</span> Language;<br>Language = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QCoreApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>LanguageShow(LanguageType::C);<br>LanguageShow(LanguageType::CPP);<br>LanguageShow(LanguageType::Python);<br><br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这种写法有几个问题：</p><ol><li> <code>LanguageShow()</code>函数违反了开闭原则 -  应该对于扩展是开放，对修改是关闭：假如增加新语言<code>JavaScript</code>，该函数免不了被修改;</li><li>责任不清， 函数应该只做一件事：<code>LanguageShow()</code>函数目前看来是做了两件事，一是根据条件产生 <code>LanguageBase</code>实例，二是<code>show()</code>；</li><li>封装不好：假如<code>LanguageBase</code>还能做其他事<code>Do()</code>, 当<code>LanguageBase</code>再做其他事<code>Do()</code>时，需要再封装一个<code>LanguageDo()</code>函数，并将<code>switch-case</code>那一段代码复制、粘贴到新函数中。</li></ol><h2 id="简单工厂的实现"><a href="#简单工厂的实现" class="headerlink" title="简单工厂的实现"></a>简单工厂的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCoreApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LanguageType</span></span><br><span class="hljs-class">&#123;</span><br>C,<br>CPP,<br>Python<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LanguageBase</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//virtual void Do() = 0;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m C&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPPLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m CPP&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PythonLanguage</span> :</span> <span class="hljs-keyword">public</span> LanguageBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I&#x27;m Python&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">LanguageBase* <span class="hljs-title">CreateObject</span><span class="hljs-params">(LanguageType type)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span> (type)<br>&#123;<br><span class="hljs-keyword">case</span> LanguageType::C:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CLanguage();<br><br><span class="hljs-keyword">case</span> LanguageType::CPP:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CPPLanguage();<br><br><span class="hljs-keyword">case</span> LanguageType::Python:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PythonLanguage();<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LanguageShow</span><span class="hljs-params">(LanguageType type)</span></span><br><span class="hljs-function"></span>&#123;<br>Factory factory;<br>LanguageBase *language = factory.CreateObject(type);<br><span class="hljs-keyword">if</span> (language != <span class="hljs-literal">nullptr</span>)<br>language-&gt;Show();<br><br><span class="hljs-keyword">delete</span> language;<br>language = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QCoreApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;LanguageType&gt; languages =<br>&#123;<br>LanguageType::C,<br>LanguageType::CPP,<br>LanguageType::Python,<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : languages)<br>&#123;<br>LanguageShow(it);<br>&#125;<br><br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述写法将 <code>LanguageShow()</code>函数分成了两部分，一部分被封装到<code>Factory::CreateObject()</code>中。</p><ol><li><code>LanguageShow()</code>对修改关闭，无论再增加多少中语言，都不会再修改该函数；</li><li>再增加<code>LanguageDo()</code>函数也无需再复制粘贴代码，可共用<code>Factory::CreateObject()</code>函数，</li></ol><p>简单工厂其实不是一个设计模式，反而比较像是一种编程习惯（《Head First 设计模式》）。</p><h2 id="简单工厂的优点"><a href="#简单工厂的优点" class="headerlink" title="简单工厂的优点"></a>简单工厂的优点</h2><ol><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ol><h2 id="简单工厂的缺点"><a href="#简单工厂的缺点" class="headerlink" title="简单工厂的缺点"></a>简单工厂的缺点</h2><ol><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li><strong>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，同样破坏了“开闭原则”；在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</strong></li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构（<strong>本例没有使用静态工厂方法</strong>）。</li></ol><p>引自 <a href="https://www.jianshu.com/p/5cb52d84bd6d">工厂模式–简单工厂模式 - 简书 (jianshu.com)</a> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.jianshu.com/p/5cb52d84bd6d">简书</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>设计模式与Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt字符串转时间</title>
    <link href="/noob/2021/05/15/Qt%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%97%B6%E9%97%B4/"/>
    <url>/noob/2021/05/15/Qt%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Qt字符串转时间本地语言问题</p></blockquote><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最近写了个解析git日志生成周报的“小”程序，需要解析git时间。</p><p>由于对git命令不太熟，决定采用<code>QDateTime :: fromString() </code>转时间，但是该函数返回了空值。</p><p>百度了半天也没找到答案，我想可能大家是没我这么粗心吧。。。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>QString gitCmd = <span class="hljs-string">&quot;git log master&quot;</span>; <span class="hljs-comment">//过滤条件未写</span><br><span class="hljs-function">QProcess <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>p.start(<span class="hljs-string">&quot;cmd&quot;</span>, QStringList() &lt;&lt; <span class="hljs-string">&quot;/c&quot;</span> &lt;&lt; gitCmd);<br>p.waitForStarted();<br>p.waitForFinished();<br>QString result = p.readAllStandardOutput();<br><br></code></pre></td></tr></table></figure><p><code>result</code>中的时间格式为<code>Sun May 9 17:19:49 2021 +0800</code></p><p>只考虑<code>+0800</code>前面的部分<code>Sun May 9 17:19:49 2021</code></p><p>查阅Qt assistant,发现可以采用如下代码将其转为QDateTime</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QString <span class="hljs-title">timeString</span><span class="hljs-params">(<span class="hljs-string">&quot;Sun May 9 17:19:49 2021&quot;</span>)</span></span>;<br>QDateTime time = QDateTime::fromString(timeString, <span class="hljs-string">&quot;ddd MMM d hh:mm:ss yyyy&quot;</span>);<br>qDebug() &lt;&lt; time.toString(<span class="hljs-string">&quot;yyyyMMdd&quot;</span>);<br></code></pre></td></tr></table></figure><p>发现qDebug()输出为空。</p><p>仔细查看Qt assistant, 发现QDateTime::fromString有如下的Note:</p><blockquote><p>Note: Unlike the other version of this function, day and month names must be given in the user’s local language. It is only possible to use the English names if the user’s language is English.</p></blockquote><p>原来是要使用本地语言才可以得到正确结果，所以需要形如<code>周日 5月 23 20:17:39 2021</code>的字符串才可以。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="使用QLocale-toDateTime"><a href="#使用QLocale-toDateTime" class="headerlink" title="使用QLocale::toDateTime()"></a>使用QLocale::toDateTime()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QString <span class="hljs-title">timeString</span><span class="hljs-params">(<span class="hljs-string">&quot;Sun May 9 17:19:49 2021&quot;</span>)</span></span>;<br><span class="hljs-function">QLocale <span class="hljs-title">loc</span><span class="hljs-params">(QLocale::English)</span></span>;<br>QDateTime dateTime = loc.toDateTime(timeString, <span class="hljs-string">&quot;ddd MMM d hh:mm:ss yyyy&quot;</span>);<br>qDebug() &lt;&lt; dateTime.toString(<span class="hljs-string">&quot;yyyyMMdd&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="使用git命令格式化时间字符串"><a href="#使用git命令格式化时间字符串" class="headerlink" title="使用git命令格式化时间字符串"></a>使用git命令格式化时间字符串</h2><p>由于对git命令不熟，git官网<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">Git - 查看提交历史 (git-scm.com)</a>也没有详细介绍如果格式化时间字符串， 而且加上时间格式化语句还出现了其他过滤条件不起作用的问题，所以开始时一心想着用代码去解决该问题，后来发现还是直接用命令格式化最简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">QString gitCmd = <span class="hljs-string">&quot;git log master&quot;</span>; <span class="hljs-comment">//过滤条件未写</span><br><span class="hljs-keyword">const</span> QString logDateFormat = <span class="hljs-string">&quot; --date=format:%Y-%m-%d-%H-%M-%S &quot;</span>;<br>gitCmd += logDateFormat;<br></code></pre></td></tr></table></figure><p>如果还有其他过滤条件，应该将其放到<code>logDateFormat</code>前，否则可能导致过滤条件不起作用的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Qt最好的资料还是 Qt assistant, 百度半天不如耐心看文档。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[stackoverflow](<a href="https://stackoverflow.com/questions/50149481/change-the-specified-string-to-qdatetime">qt - Change the specified string to QDateTime - Stack Overflow</a>)<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QDateTime</category>
      
    </categories>
    
    
    <tags>
      
      <tag>QDateTime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qt自定义控件组合效果（按钮为例）</title>
    <link href="/noob/2021/04/24/qt%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E7%BB%84%E5%90%88%E6%95%88%E6%9E%9C%EF%BC%88%E6%8C%89%E9%92%AE%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
    <url>/noob/2021/04/24/qt%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E7%BB%84%E5%90%88%E6%95%88%E6%9E%9C%EF%BC%88%E6%8C%89%E9%92%AE%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Qt组合控件通过QSS实现统一效果</p></blockquote><span id="more"></span><h2 id="cpp布局代码如下"><a href="#cpp布局代码如下" class="headerlink" title="cpp布局代码如下"></a>cpp布局代码如下</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">textLabel = <span class="hljs-keyword">new</span> <span class="hljs-constructor">QLabel(<span class="hljs-params">text</span>, <span class="hljs-params">this</span>)</span>;<br>textLabel-&gt;set<span class="hljs-constructor">ObjectName(<span class="hljs-string">&quot;textLabel&quot;</span>)</span>;<br>textLabel-&gt;set<span class="hljs-constructor">Alignment(Qt::AlignCenter)</span>;<br><br>imageLabel = <span class="hljs-keyword">new</span> <span class="hljs-constructor">QLabel(<span class="hljs-params">this</span>)</span>;<br>imageLabel-&gt;set<span class="hljs-constructor">ObjectName(<span class="hljs-string">&quot;imageLabel&quot;</span>)</span>;<br><br>QHBoxLayout* hLayout = <span class="hljs-keyword">new</span> QHBoxLayout;<br>hLayout-&gt;set<span class="hljs-constructor">Spacing(SPACING)</span>;<br>hLayout-&gt;set<span class="hljs-constructor">ContentsMargins(0, 0, 0, 0)</span>;<br><br>hLayout-&gt;add<span class="hljs-constructor">Widget(<span class="hljs-params">textLabel</span>, 0, Qt::AlignVCenter)</span>;<br>hLayout-&gt;add<span class="hljs-constructor">Widget(<span class="hljs-params">imageLabel</span>, 0, Qt::AlignVCenter)</span>;<br><br>this-&gt;set<span class="hljs-constructor">Layout(<span class="hljs-params">hLayout</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="cpp核心代码如下"><a href="#cpp核心代码如下" class="headerlink" title="cpp核心代码如下"></a>cpp核心代码如下</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">bool</span> Button::event(QEvent* e)<br>&#123;<br><span class="hljs-keyword">switch</span> (e-&gt;type())<br>&#123;<br><span class="hljs-keyword">case</span> QEvent::MouseButtonRelease:<br>setCheckedStage(isChecked());<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> QEvent::Enter:<br>textLabel-&gt;setProperty(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-string">&quot;hover&quot;</span>);<br>imageLabel-&gt;setProperty(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-string">&quot;hover&quot;</span>);<br>repolish(textLabel);<br>repolish(imageLabel);<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> QEvent::Leave:<br>setCheckedStage(isChecked());<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> QPushButton::event(e);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xl">void Button::repolish(QWidget* widget)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">widget</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">style</span>()-&gt;</span>unpolish(widget);<br><span class="hljs-function"><span class="hljs-title">widget</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">style</span>()-&gt;</span>polish(widget);<br>&#125;<br><br>void Button::setCheckedStage(bool isCheck)<br>&#123;<br><span class="hljs-keyword">if</span> (isCheck == <span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-function"><span class="hljs-title">textLabel</span>-&gt;</span>setProperty(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-string">&quot;checked&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">imageLabel</span>-&gt;</span>setProperty(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-string">&quot;checked&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-function"><span class="hljs-title">textLabel</span>-&gt;</span>setProperty(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-string">&quot;normal&quot;</span>);<br><span class="hljs-function"><span class="hljs-title">imageLabel</span>-&gt;</span>setProperty(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-string">&quot;normal&quot;</span>);<br>&#125;<br>repolish(textLabel);<br>repolish(imageLabel);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">connect(<span class="hljs-name">this</span>, <span class="hljs-symbol">&amp;Button</span>:<span class="hljs-symbol">:toggled</span>, [=](<span class="hljs-name">bool</span> _isChecked) &#123;<br>setCheckedStage(<span class="hljs-name">isChecked</span>())<span class="hljs-comment">;</span><br>&#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="QSS如下"><a href="#QSS如下" class="headerlink" title="QSS如下"></a>QSS如下</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.Button</span><br>&#123;<br>    <span class="hljs-attribute">background</span>: transparent;<br>&#125;<br><br><span class="hljs-selector-class">.Button</span> <span class="hljs-selector-tag">QLabel</span><span class="hljs-selector-id">#textLabel</span><span class="hljs-selector-attr">[state = <span class="hljs-string">&#x27;hover&#x27;</span>]</span>, <span class="hljs-selector-class">.Button</span> <span class="hljs-selector-tag">QLabel</span><span class="hljs-selector-id">#textLabel</span><span class="hljs-selector-attr">[state = <span class="hljs-string">&#x27;checked&#x27;</span>]</span>,<br> <span class="hljs-selector-class">.Button</span> <span class="hljs-selector-tag">QLabel</span><span class="hljs-selector-id">#imageLabel</span><span class="hljs-selector-attr">[state = <span class="hljs-string">&#x27;hover&#x27;</span>]</span>, <span class="hljs-selector-class">.Button</span> <span class="hljs-selector-tag">QLabel</span><span class="hljs-selector-id">#imageLabel</span><span class="hljs-selector-attr">[state = <span class="hljs-string">&#x27;checked&#x27;</span>]</span><br>&#123;<br>    <span class="hljs-attribute">background</span>:red;<br>    <span class="hljs-attribute">color</span>: white;<br>&#125;<br><br><span class="hljs-selector-class">.Button</span> <span class="hljs-selector-tag">QLabel</span><span class="hljs-selector-id">#textLabel</span><span class="hljs-selector-attr">[state = <span class="hljs-string">&#x27;normal&#x27;</span>]</span>, <span class="hljs-selector-class">.Button</span> <span class="hljs-selector-tag">QLabel</span><span class="hljs-selector-id">#imageLabel</span><span class="hljs-selector-attr">[state = <span class="hljs-string">&#x27;normal&#x27;</span>]</span><br>&#123;<br>    <span class="hljs-attribute">background</span>:blue;<br>&#125;<br><br><span class="hljs-selector-class">.Button</span><span class="hljs-selector-id">#Temperature</span> <span class="hljs-selector-tag">QLabel</span><span class="hljs-selector-id">#imageLabel</span><br>&#123;<br>    <span class="hljs-attribute">border-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;:/image/test.png&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>通过事件及<code>Button::toggled</code>信号控制自定义Property，并通过QWidget的style()重新加载其样式；</li><li>QSS中判断子控件的自定义Property值来设定相应样式；</li></ol>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>样式表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QSS背景图片</title>
    <link href="/noob/2021/01/27/QSS%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/"/>
    <url>/noob/2021/01/27/QSS%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>background-image 和 border-image的区别。</p></blockquote><span id="more"></span><h2 id="拉伸与重复"><a href="#拉伸与重复" class="headerlink" title="拉伸与重复"></a>拉伸与重复</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">QFrame *frame = new QFrame;<br><span class="hljs-comment">//不会自动适应图片，background-image图片尺寸不变，</span><br><span class="hljs-comment">//会重复或空出一块区域，取决于 background-repeat属性的设置</span><br><span class="hljs-function"><span class="hljs-title">frame</span>-&gt;</span>setStyleSheet(<span class="hljs-string">&quot;background-image:url(:/image/test.jpg)&quot;</span>);<br><span class="hljs-comment">//图片可以自动居中显示，控件大小改变时会自动拉伸，但是设置边框属性无效</span><br><span class="hljs-function"><span class="hljs-title">frame</span>-&gt;</span>setStyleSheet(<span class="hljs-string">&quot;border-image:url(:/image/test.jpg)&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>border-image：<ul><li>图片可以自动居中显示；</li><li>控件大小改变时会自动拉伸；</li><li>但是设置边框属性无效；</li><li>当控件大小需要改变或图片需要拉伸时使用。</li></ul></li><li>background-iamge：<ul><li>图片不会自动居中显示；</li><li>可以设置其background-position:属性，使其居中显示，甚至可以利用该属性，灵活控制QPushButton中图标和文字的位置</li><li>可以设置边框（border）的属性。</li></ul></li><li>如果同时指定border-image和background-iamge，那么border-image在上</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/guorong520/article/details/100707577">博客园</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>样式表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QCustomplot背景色透明</title>
    <link href="/noob/2020/12/30/QCustomplot%E8%83%8C%E6%99%AF%E8%89%B2%E9%80%8F%E6%98%8E/"/>
    <url>/noob/2020/12/30/QCustomplot%E8%83%8C%E6%99%AF%E8%89%B2%E9%80%8F%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>QCustomplot 设置背景色透明，会出现穿透父控件背景色的问题，找了好久才解决的问题，最终找到两个方法，记录一下。</p></blockquote><span id="more"></span><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">customplot</span>-&gt;</span>setBackground(Qt::transparent);<br><span class="hljs-function"><span class="hljs-title">customplot</span>-&gt;</span>setStyleSheet(<span class="hljs-string">&quot;background: transparent;&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">customplot-&gt;setBackground(Qt::transparent);<br>customplot-&gt;-&gt;setAttribute(Qt::WA_OpaquePaintEvent, <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.cnblogs.com/leocc325/p/13194495.html">博客园</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.qcustomplot.com/index.php/support/forum/2055">QCustomplot Support Forum</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>QCustomplot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图表</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
