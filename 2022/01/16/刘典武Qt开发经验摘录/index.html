

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/melody-favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="l">
  <meta name="keywords" content="">
  <title>刘典武Qt开发经验摘录 - noob</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"noobplusplus.github.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"82365797a7f92a0aa6495822ee0829a4","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>noob就是菜鸡</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="刘典武Qt开发经验摘录">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-16 20:12" pubdate>
        2022年1月16日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      23.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      297
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">刘典武Qt开发经验摘录</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>刘典武经验中个人感觉后期可能会用到的，或之前用过容易遗忘的，分类摘录，方便后期查阅，侵删。<br>项目地址<br><a target="_blank" rel="noopener" href="https://gitee.com/feiyangqingyun/qtkaifajingyan">飞扬青云/Qt开发经验</a></p>
<span id="more"></span>
</blockquote>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><h3 id="6-可以在pro文件中写上标记版本号-ico图标（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件"><a href="#6-可以在pro文件中写上标记版本号-ico图标（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件" class="headerlink" title="6.可以在pro文件中写上标记版本号+ico图标（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件"></a>6.可以在pro文件中写上标记版本号+ico图标（Qt5才支持），其实在windows上就是qmake的时候会自动将此信息转换成rc文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">VERSION  = <span class="hljs-number">2025.10</span><span class="hljs-number">.01</span><br>RC_ICONS = main.ico<br><br></code></pre></td></tr></table></figure>

<h3 id="9-绘制平铺背景QPainter-drawTiledPixmap-绘制圆角矩形QPainter-drawRoundedRect-而不是QPainter-drawRoundRect"><a href="#9-绘制平铺背景QPainter-drawTiledPixmap-绘制圆角矩形QPainter-drawRoundedRect-而不是QPainter-drawRoundRect" class="headerlink" title="9. 绘制平铺背景QPainter::drawTiledPixmap,绘制圆角矩形QPainter::drawRoundedRect(),而不是QPainter::drawRoundRect()"></a>9. 绘制平铺背景QPainter::drawTiledPixmap,绘制圆角矩形QPainter::drawRoundedRect(),而不是QPainter::drawRoundRect()</h3><h3 id="10-移除旧的样式"><a href="#10-移除旧的样式" class="headerlink" title="10. 移除旧的样式"></a>10. 移除旧的样式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//移除原有样式</span><br>style()-&gt;unpolish(ui-&gt;btn);<br><span class="hljs-comment">//必须要有下面这行不然还是不会卸载</span><br>ui-&gt;btn-&gt;setStyleSheet(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//重新设置新的该控件的样式。</span><br>style()-&gt;polish(ui-&gt;btn);<br><br></code></pre></td></tr></table></figure>

<h3 id="15-可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可"><a href="#15-可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可" class="headerlink" title="15. 可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可"></a>15. 可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>QPushButton *btn = <span class="hljs-keyword">new</span> QPushButton;<br><br>btn-&gt;resize(<span class="hljs-number">30</span>, ui-&gt;lineEdit-&gt;height());<br><br>QHBoxLayout *layout = <span class="hljs-keyword">new</span> QHBoxLayout(ui-&gt;lineEdit);<br><br>layout-&gt;setMargin(<span class="hljs-number">0</span>);<br><br>layout-&gt;addStretch();<br><br>layout-&gt;addWidget(btn);<br><br></code></pre></td></tr></table></figure>

<h3 id="16-对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果"><a href="#16-对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果" class="headerlink" title="16. 对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果"></a>16. 对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat，不然你会发现没效果</h3><h3 id="21-如果出现Z-order-assignment-is-not-a-valid-widget-错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可"><a href="#21-如果出现Z-order-assignment-is-not-a-valid-widget-错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可" class="headerlink" title="21. 如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到为空的地方，删除即可"></a>21. 如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到<zorder></zorder>为空的地方，删除即可</h3><h3 id="26-可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置"><a href="#26-可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置" class="headerlink" title="26. 可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置"></a>26. 可以对整体的指示器设置样式，而不需要单独对每个控件的指示器设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*::down-arrow&#123;&#125;<br>*::menu-indicator&#123;&#125;<br>*::up-arrow:disabled&#123;&#125;<br>*::up-arrow:off&#123;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="27-可以指定位置设置背景图片（本人注：可以调整button中图标的位置）"><a href="#27-可以指定位置设置背景图片（本人注：可以调整button中图标的位置）" class="headerlink" title="27. 可以指定位置设置背景图片（本人注：可以调整button中图标的位置）"></a>27. 可以指定位置设置背景图片（本人注：可以调整button中图标的位置）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QMainWindow &gt; .QWidget &#123;<br>    background-color: gainsboro;<br>    background-image: url(:/images/pagefold.png);<br>    background-position: top right;<br>    background-repeat: no-repeat<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="33-Qt最小化后恢复界面假死冻结，加上代码"><a href="#33-Qt最小化后恢复界面假死冻结，加上代码" class="headerlink" title="33. Qt最小化后恢复界面假死冻结，加上代码"></a>33. Qt最小化后恢复界面假死冻结，加上代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showEvent</span><span class="hljs-params">(QShowEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    setAttribute(Qt::WA_Mapped);<br>    QWidget::showEvent(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="34-获取标题栏高度：style-gt-pixelMetric-QStyle-PM-TitleBarHeight-PM-TitleBarHeight点进去你会发现新大陆"><a href="#34-获取标题栏高度：style-gt-pixelMetric-QStyle-PM-TitleBarHeight-PM-TitleBarHeight点进去你会发现新大陆" class="headerlink" title="34. 获取标题栏高度：style()-&gt;pixelMetric(QStyle::PM_TitleBarHeight); PM_TitleBarHeight点进去你会发现新大陆"></a>34. 获取标题栏高度：style()-&gt;pixelMetric(QStyle::PM_TitleBarHeight); PM_TitleBarHeight点进去你会发现新大陆</h3><h3 id="35-设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication-a-argc-argv-的前面"><a href="#35-设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication-a-argc-argv-的前面" class="headerlink" title="35. 设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication a(argc, argv);的前面"></a>35. 设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication a(argc, argv);的前面</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))</span><br>    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="38-qml播放视频在linux需要安装-sudo-apt-get-install-libpulse-dev"><a href="#38-qml播放视频在linux需要安装-sudo-apt-get-install-libpulse-dev" class="headerlink" title="38. qml播放视频在linux需要安装 sudo apt-get install libpulse-dev"></a>38. qml播放视频在linux需要安装 sudo apt-get install libpulse-dev</h3><h3 id="40-Qt5以后提供了类QScroller直接将控件滚动"><a href="#40-Qt5以后提供了类QScroller直接将控件滚动" class="headerlink" title="40. Qt5以后提供了类QScroller直接将控件滚动"></a>40. Qt5以后提供了类QScroller直接将控件滚动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//禁用横向滚动条</span><br>ui-&gt;listWidget-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);<br><span class="hljs-comment">//禁用纵向滚动条</span><br>ui-&gt;listWidget-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);<br><span class="hljs-comment">//设置横向按照像素值为单位滚动</span><br>ui-&gt;listWidget-&gt;setHorizontalScrollMode(QListWidget::ScrollPerPixel);<br><span class="hljs-comment">//设置纵向按照像素值为单位滚动</span><br>ui-&gt;listWidget-&gt;setVerticalScrollMode(QListWidget::ScrollPerPixel);<br><span class="hljs-comment">//设置滚动对象以及滚动方式为鼠标左键拉动滚动</span><br>QScroller::grabGesture(ui-&gt;listWidget, QScroller::LeftMouseButtonGesture);<br><span class="hljs-comment">//还有个QScrollerProperties可以设置滚动的一些参数</span><br></code></pre></td></tr></table></figure>

<h3 id="50-如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用-setWindowFlags-Qt-CustomizeWindowHint"><a href="#50-如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用-setWindowFlags-Qt-CustomizeWindowHint" class="headerlink" title="50. 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)"></a>50. 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint)</h3><h3 id="53-Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一"><a href="#53-Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一" class="headerlink" title="53. Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一"></a>53. Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一</h3><ul>
<li>方法一：设置属性 this-&gt;setAttribute(Qt::WA_StyledBackground, true);</li>
<li>方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。</li>
<li>方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    QStyleOption option;<br>    option.initFrom(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;option, &amp;painter, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="54-有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的"><a href="#54-有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的" class="headerlink" title="54. 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的"></a>54. 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的</h3><h3 id="58-非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理"><a href="#58-非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理" class="headerlink" title="58. 非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理"></a>58. 非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理</h3><h3 id="68-很多控件都带有viewport，比如QTextEdit-QTableWidget-QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport-设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-gt-viewport-gt-setStyleSheet-“background-color-transparent-”-而不是scrollArea-gt-setStyleSheet-“QScrollArea-background-color-transparent-”"><a href="#68-很多控件都带有viewport，比如QTextEdit-QTableWidget-QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport-设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-gt-viewport-gt-setStyleSheet-“background-color-transparent-”-而不是scrollArea-gt-setStyleSheet-“QScrollArea-background-color-transparent-”" class="headerlink" title="68. 很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-&gt;viewport()-&gt;setStyleSheet(“background-color:transparent;”);而不是scrollArea-&gt;setStyleSheet(“QScrollArea{background-color:transparent;}”)"></a>68. 很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-&gt;viewport()-&gt;setStyleSheet(“background-color:transparent;”);而不是scrollArea-&gt;setStyleSheet(“QScrollArea{background-color:transparent;}”)</h3><h3 id="69-有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置-setAttribute-Qt-WA-Hover-true"><a href="#69-有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置-setAttribute-Qt-WA-Hover-true" class="headerlink" title="69. 有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true)"></a>69. 有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true)</h3><h3 id="72-如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息"><a href="#72-如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息" class="headerlink" title="72. 如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息"></a>72. 如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QDialog dialog;<br>dialog.setWindowModality(Qt::WindowModal);<br>dialog.exec();<br></code></pre></td></tr></table></figure>

<h3 id="74-在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制"><a href="#74-在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制" class="headerlink" title="74. 在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制"></a>74. 在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制</h3><h3 id="75-将-QApplication-style-对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication-style-gt-drawControl-的第4个参数如果不设置，则绘制出来的控件不会应用样式表"><a href="#75-将-QApplication-style-对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication-style-gt-drawControl-的第4个参数如果不设置，则绘制出来的控件不会应用样式表" class="headerlink" title="75. 将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-&gt;drawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表"></a>75. 将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-&gt;drawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表</h3><h3 id="79-对QTableView或者QTableWidget禁用列拖动"><a href="#79-对QTableView或者QTableWidget禁用列拖动" class="headerlink" title="79. 对QTableView或者QTableWidget禁用列拖动"></a>79. 对QTableView或者QTableWidget禁用列拖动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &lt;= QT_VERSION_CHECK(5,0,0))</span><br>    ui-&gt;tableView-&gt;horizontalHeader()-&gt;setResizeMode(<span class="hljs-number">0</span>, QHeaderView::Fixed);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    ui-&gt;tableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(<span class="hljs-number">0</span>, QHeaderView::Fixed);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="90-在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取"><a href="#90-在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取" class="headerlink" title="90. 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取"></a>90. 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取</h3><h3 id="103-Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget"><a href="#103-Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget" class="headerlink" title="103. Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget"></a>103. Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QUIHelper::initTableView</span><span class="hljs-params">(QTableView *tableView, <span class="hljs-keyword">int</span> rowHeight, <span class="hljs-keyword">bool</span> headVisible, <span class="hljs-keyword">bool</span> edit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//奇数偶数行颜色交替</span><br>    tableView-&gt;setAlternatingRowColors(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//垂直表头是否可见</span><br>    tableView-&gt;verticalHeader()-&gt;setVisible(headVisible);<br>    <span class="hljs-comment">//选中一行表头是否加粗</span><br>    tableView-&gt;horizontalHeader()-&gt;setHighlightSections(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">//最后一行拉伸填充</span><br>    tableView-&gt;horizontalHeader()-&gt;setStretchLastSection(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//行标题最小宽度尺寸</span><br>    tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//行标题最大高度</span><br>    tableView-&gt;horizontalHeader()-&gt;setMaximumHeight(rowHeight);<br>    <span class="hljs-comment">//默认行高</span><br>    tableView-&gt;verticalHeader()-&gt;setDefaultSectionSize(rowHeight);<br>    <span class="hljs-comment">//选中时一行整体选中</span><br>    tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);<br>    <span class="hljs-comment">//只允许选择单个</span><br>    tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection);<br><br>    <span class="hljs-comment">//表头不可单击</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span><br>    tableView-&gt;horizontalHeader()-&gt;setSectionsClickable(<span class="hljs-literal">false</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    tableView-&gt;horizontalHeader()-&gt;setClickable(<span class="hljs-literal">false</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">//鼠标按下即进入编辑模式</span><br>    <span class="hljs-keyword">if</span> (edit) &#123;<br>        tableView-&gt;setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="106-很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置"><a href="#106-很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置" class="headerlink" title="106. 很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置"></a>106. 很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QDialog dialog;<br>dialog.setWindowModality(Qt::WindowModal);<br></code></pre></td></tr></table></figure>

<h3 id="108-在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行"><a href="#108-在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行" class="headerlink" title="108. 在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行"></a>108. 在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这种方式设置的无边框窗体在嵌入式设备上无法产生焦点</span><br>setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);<br><br><span class="hljs-comment">//需要在show以后主动激活窗体</span><br>w-&gt;show();<br>w-&gt;activateWindow();<br></code></pre></td></tr></table></figure>

<h3 id="110-QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所"><a href="#110-QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所" class="headerlink" title="110. QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所"></a>110. QGraphicsEffect类的相关效果很炫，可以实现很多效果比如透明、渐变、阴影等，但是该类很耗CPU，如果不是特别需要一般不建议用，就算用也是要用在该部件后期不会发生频繁绘制的场景，不然会让你哭晕在厕所</h3><h3 id="119-QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用"><a href="#119-QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用" class="headerlink" title="119. QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用"></a>119. QGraphicsEffect相关类很耗CPU，甚至在绘制的时候和某些地方有冲突干扰，基本上不建议使用，情非得已只建议少量使用和非频繁触发绘制的地方使用</h3><h3 id="121-QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途"><a href="#121-QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途" class="headerlink" title="121. QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途"></a>121. QLineEdit除了单纯的文本框以外，还可以做很多特殊的处理用途</h3><ul>
<li>限制输入只能输入IP地址。</li>
<li>限制输入范围，强烈推荐使用 QRegExpValidator 正则表达式来处理。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//正在表达式限制输入</span><br>QString str = <span class="hljs-string">&quot;\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&quot;</span>;<br>ui-&gt;lineEdit-&gt;setValidator(<span class="hljs-keyword">new</span> QRegExpValidator(QRegExp(str)));<br><span class="hljs-comment">//用于占位</span><br>ui-&gt;lineEdit-&gt;setInputMask(<span class="hljs-string">&quot;000.000.000.000&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span><br><span class="hljs-comment">//下面代码设置浮点数范围限制失败</span><br>ui-&gt;lineEdit-&gt;setValidator(<span class="hljs-keyword">new</span> QDoubleValidator(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-comment">//下面代码设置浮点数范围限制成功</span><br>QDoubleValidator *validator = <span class="hljs-keyword">new</span> QDoubleValidator(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>);<br>validator-&gt;setNotation(QDoubleValidator::StandardNotation);<br>ui-&gt;lineEdit-&gt;setValidator(validator);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">//下面代码设置整数范围限制成功</span><br>ui-&gt;lineEdit-&gt;setValidator(<span class="hljs-keyword">new</span> QIntValidator(<span class="hljs-number">10</span>, <span class="hljs-number">120</span>));<br><br><span class="hljs-comment">//其实上面的代码缺陷很多，只能限制只输入小数，无法设定数值范围，很操蛋</span><br><span class="hljs-comment">//需要来个万能的牛逼的 QRegExpValidator</span><br><br><span class="hljs-comment">//限制浮点数输入范围为[-180,180]</span><br><span class="hljs-function">QRegExp <span class="hljs-title">regexp</span><span class="hljs-params">(<span class="hljs-string">&quot;^-?(180|1?[0-7]?\\d(\\.\\d+)?)$&quot;</span>)</span></span>;<br><span class="hljs-comment">//限制浮点数输入范围为[-90,90]并限定为小数位后4位</span><br><span class="hljs-function">QRegExp <span class="hljs-title">regexp</span><span class="hljs-params">(<span class="hljs-string">&quot;^-?(90|[1-8]?\\d(\\.\\d&#123;1,4&#125;)?)$&quot;</span>)</span></span>;<br>QRegExpValidator *validator = <span class="hljs-keyword">new</span> QRegExpValidator(regexp, <span class="hljs-keyword">this</span>);<br>ui-&gt;lineEdit-&gt;setValidator(validator);<br></code></pre></td></tr></table></figure>

<h3 id="122-在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5-14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串-rtmp-58-200-131-2-1935-livetv-cctv1，会显示成-rtmp-…-，而在旧版本的Qt中会显示成-rtmp-58-200-131…-，很多时候我们并不想看到烦人的省略号，可以设置取消"><a href="#122-在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5-14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串-rtmp-58-200-131-2-1935-livetv-cctv1，会显示成-rtmp-…-，而在旧版本的Qt中会显示成-rtmp-58-200-131…-，很多时候我们并不想看到烦人的省略号，可以设置取消" class="headerlink" title="122. 在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://…  ，而在旧版本的Qt中会显示成 rtmp://58.200.131… ，很多时候我们并不想看到烦人的省略号，可以设置取消"></a>122. 在继承自QAbstractItemView的控件中，比如QTableView、QTableWidget，如果文本超过对应item的宽度，则会自动省略号显示，想要快速显示完整的文本，可以在该列和下一列分割线中间双击即可，会自动自适应显示最大宽度，如果是Qt5.14或者更高版本，你会发现显示省略号的计算规则变了，如果是rtsp、http之类的开头的英文字符串，同样的列宽下，会提前就显示省略号，比如字符串 rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://…  ，而在旧版本的Qt中会显示成 rtmp://58.200.131… ，很多时候我们并不想看到烦人的省略号，可以设置取消</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//取消自动换行</span><br>tableView-&gt;setWordWrap(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//超出文本不显示省略号</span><br>tableView-&gt;setTextElideMode(Qt::ElideNone);<br></code></pre></td></tr></table></figure>

<h3 id="在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致"><a href="#在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致" class="headerlink" title="在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致"></a>在主QWidget窗体如果直接qss设置背景图片的话，预览是可见的，运行并没有效果，你需要在这个主widget上再放个widget，在新的widget上设置qss图片就行，而如果是Dialog或者QMainWindow窗体是支持直接设置qss背景图的，预览和运行效果一致</h3><h3 id="138-对高分屏不同缩放比例的自适应处理方法"><a href="#138-对高分屏不同缩放比例的自适应处理方法" class="headerlink" title="138. 对高分屏不同缩放比例的自适应处理方法"></a>138. 对高分屏不同缩放比例的自适应处理方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1：在main函数的最前面加上下面这句 5.6版本才开始有这个函数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))</span><br>    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);<br>    <span class="hljs-comment">//开启高缩放支持以后图片可能发虚还要开启下面这个属性</span><br>    QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//方法2：在可执行文件同目录下新建文件 qt.conf 填入下面内容</span><br>[Platforms]<br>WindowsArguments = dpiawareness=<span class="hljs-number">0</span><br><span class="hljs-comment">//下面这行用来解决Qt高DPI下文字显示有锯齿的问题</span><br>WindowsArguments = fontengine=freetype<br><br><span class="hljs-comment">//方法3：在main函数最前面设置Qt内部的环境变量</span><br>qputenv(<span class="hljs-string">&quot;QT_AUTO_SCREEN_SCALE_FACTOR&quot;</span>, <span class="hljs-string">&quot;1.5&quot;</span>);<br><br><span class="hljs-comment">//方法4：新版本的Qt比如Qt5.14修正了对高分屏的处理支持不是整数的缩放</span><br>qputenv(<span class="hljs-string">&quot;QT_ENABLE_HIGHDPI_SCALING&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);<br><br><span class="hljs-comment">//禁用缩放</span><br><span class="hljs-comment">//测试发现AA_Use96Dpi属性在Qt5.9以上版本完全正常，以下版本比如5.7有部分控件在175%缩放不正常比如QTextEdit，需要外层套个widget才行。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    QApplication::setAttribute(Qt::AA_Use96Dpi);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,14,0))</span><br>    QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="139-QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮"><a href="#139-QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮" class="headerlink" title="139. QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮"></a>139. QTabWidget选项卡有个自动生成按钮切换选项卡的机制，有时候不想看到这个烦人的切换按钮，可以设置usesScrollButtons为假，其实QTabWidget的usesScrollButtons属性最终是应用到QTabWidget的QTabBar对象上，所以只要设置全局的QTabBar的这个属性关闭即可。为啥要设置全局的呢，因为如果只是对QTabWidget设置了该属性，而在QMainWindow窗体中QDockWidget合并自动形成的选项卡只有QTabBar对象导致依然是有切换按钮</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对tabWidget设置无切换按钮</span><br>ui-&gt;tabWidget-&gt;setUsesScrollButtons(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//对tabBar设置无切换按钮</span><br>ui-&gt;tabWidget-&gt;tabBar()-&gt;setUsesScrollButtons(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//对整个系统的选项卡设置无切换按钮</span><br>QTabBar&#123;qproperty-usesScrollButtons:<span class="hljs-literal">false</span>;&#125;<br><span class="hljs-comment">//设置选项卡自动拉伸 这玩意居然之前自动计算来设置原来内置了哇咔咔</span><br>QTabBar&#123;qproperty-expanding:<span class="hljs-literal">false</span>;&#125;<br><span class="hljs-comment">//设置选项卡关闭按钮可见</span><br>QTabBar&#123;qproperty-tabsClosable:<span class="hljs-literal">true</span>;&#125;<br><span class="hljs-comment">//还有其他属性参见QTabBar头文件有惊喜</span><br><span class="hljs-comment">//依旧是万能大法所有可视化类的 Q_PROPERTY 包含的属性都可以这样设置</span><br></code></pre></td></tr></table></figure>

<h3 id="140-QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容"><a href="#140-QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容" class="headerlink" title="140. QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容"></a>140. QMainWindow的分割线默认尺寸比较大，有时候想设置小一点或者不想要，最开始的时候以为是QSplitter，打印所有子元素找遍了也没找到影子，最后发现样式表中有对应设置的内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//真的是做梦也没想到要这样设置</span><br>QMainWindow::separator&#123;width:<span class="hljs-number">1</span>px;height:<span class="hljs-number">1</span>px;margin:<span class="hljs-number">1</span>px;padding:<span class="hljs-number">1</span>px;background:#FF0000;&#125;<br></code></pre></td></tr></table></figure>

<h3 id="142-在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文"><a href="#142-在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文" class="headerlink" title="142. 在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文"></a>142. 在停靠窗体QDockWidget和QOpenGLWidget同时使用的时候，从嵌入状态切换到浮动状态或者浮动状态切换到嵌入状态，QOpenGLWidget的上下文会被打乱导致白屏失效，需要在main函数中开头位置设置下共享OpenGL上下文</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//需要设置共享上下文不然停靠窗体从正常到浮动后QOpenGLWidget窗体会失效</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span><br>    QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="143-关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99-以上的Qt版本的乱码问题"><a href="#143-关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99-以上的Qt版本的乱码问题" class="headerlink" title="143. 关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题"></a>143. 关于Qt中文乱码的问题，个人也稍微总结了一点，应该可以解决99%以上的Qt版本的乱码问题</h3><ul>
<li>第一步：代码文件选择用utf8编码带bom。</li>
<li>第二步：在有中文汉字的代码文件顶部加一行（一般是cpp文件） #pragma execution_character_set(“utf-8”) 可以考虑放在head.h中，然后需要的地方就引入head头文件就行，而不是这行代码写的到处都是；这行代码是为了告诉msvc编译器当前代码文件用utf8去编译。</li>
<li>第三步：main函数中加入设置编码的代码，以便兼容Qt4，如果没有Qt4的场景可以不用，从Qt5开始默认就是utf8编码。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QUIHelper::setCode</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &lt;= QT_VERSION_CHECK(5,0,0))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER</span><br>    QTextCodec *codec = QTextCodec::codecForName(<span class="hljs-string">&quot;gbk&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    QTextCodec *codec = QTextCodec::codecForName(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    QTextCodec::setCodecForLocale(codec);<br>    QTextCodec::setCodecForCStrings(codec);<br>    QTextCodec::setCodecForTr(codec);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    QTextCodec *codec = QTextCodec::codecForName(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>    QTextCodec::setCodecForLocale(codec);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="145-通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4-7到5-15任意版本，通过查看对应函数的源码可以看到内部会检查是否是-‘file-‘-开头，是的话则自动读取样式表文件进行设置，无需手动读取"><a href="#145-通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4-7到5-15任意版本，通过查看对应函数的源码可以看到内部会检查是否是-‘file-‘-开头，是的话则自动读取样式表文件进行设置，无需手动读取" class="headerlink" title="145. 通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 ‘file:///‘ 开头，是的话则自动读取样式表文件进行设置，无需手动读取"></a>145. 通过酷码大哥（Qt开发者交流群）的指点，到今天才知道，Qt设置样式表支持直接传入样式表文件路径，亲测4.7到5.15任意版本，通过查看对应函数的源码可以看到内部会检查是否是 ‘file:///‘ 开头，是的话则自动读取样式表文件进行设置，无需手动读取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以前都是下面的方法</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;:/qss/psblack.css&quot;</span>)</span></span>;<br><span class="hljs-keyword">if</span> (file.open(QFile::ReadOnly)) &#123;<br>    QString qss = QLatin1String(file.readAll());<br>    qApp-&gt;setStyleSheet(qss);<br>    file.close();<br>&#125;<br><br><span class="hljs-comment">//其实一行代码就行</span><br>qApp-&gt;setStyleSheet(<span class="hljs-string">&quot;file:///:/qss/psblack.css&quot;</span>);<br><span class="hljs-comment">//特别说明，只支持qApp-&gt;setStyleSheet 不支持其他比如widget-&gt;setStyleSheet</span><br></code></pre></td></tr></table></figure>

<h3 id="146-Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板-QCalendarWidget-就是-QToolButton-QSpinBox-QTableView-等组成，妙用-findChildren-可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等"><a href="#146-Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板-QCalendarWidget-就是-QToolButton-QSpinBox-QTableView-等组成，妙用-findChildren-可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等" class="headerlink" title="146. Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等"></a>146. Qt中自带的很多控件，其实都是由一堆基础控件（QLabel、QPushButton等）组成的，比如日历面板 QCalendarWidget 就是 QToolButton+QSpinBox+QTableView 等组成，妙用 findChildren 可以拿到父类对应的子控件集合，可以直接对封装的控件中的子控件进行样式的设置，其他参数的设置比如设置中文文本（默认可能是英文）等</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//打印子类类名集合</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printObjectChild</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QObject *obj, <span class="hljs-keyword">int</span> spaceCount)</span></span><br><span class="hljs-function"></span>&#123;<br>    qDebug() &lt;&lt; QString(<span class="hljs-string">&quot;%1%2 : %3&quot;</span>)<br>             .arg(<span class="hljs-string">&quot;&quot;</span>, spaceCount)<br>             .arg(obj-&gt;metaObject()-&gt;className())<br>             .arg(obj-&gt;objectName());<br><br>    QObjectList childs = obj-&gt;children();<br>    foreach (QObject *child, childs) &#123;<br>        printObjectChild(child, spaceCount + <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//拿到对话框进行设置和美化</span><br>QFileDialog *fileDialog = <span class="hljs-keyword">new</span> QFileDialog(<span class="hljs-keyword">this</span>);<br>fileDialog-&gt;setOption(QFileDialog::DontUseNativeDialog, <span class="hljs-literal">true</span>);<br>QLabel *lookinLabel = fileDialog-&gt;findChild&lt;QLabel*&gt;(<span class="hljs-string">&quot;lookInLabel&quot;</span>);<br>lookinLabel-&gt;setText(QString::fromLocal8Bit(<span class="hljs-string">&quot;文件目录：&quot;</span>));<br>lookinLabel-&gt;setStyleSheet(<span class="hljs-string">&quot;color:red;&quot;</span>);<br><br><span class="hljs-comment">//设置日期框默认值为空</span><br>QLineEdit *edit = ui-&gt;dateEdit-&gt;findChild&lt;QLineEdit *&gt;(<span class="hljs-string">&quot;qt_spinbox_lineedit&quot;</span>);<br><span class="hljs-keyword">if</span> (!edit-&gt;text().isEmpty()) &#123;<br>    edit-&gt;clear();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="147-Qt内置了各种对话框，比如文件对话框-QFileDialog-，颜色对话框-QColorDialog-，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理"><a href="#147-Qt内置了各种对话框，比如文件对话框-QFileDialog-，颜色对话框-QColorDialog-，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理" class="headerlink" title="147. Qt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理"></a>147. Qt内置了各种对话框，比如文件对话框-QFileDialog ，颜色对话框-QColorDialog ，默认都会采用系统的对话框风格样式，这样可以保持和系统一致，如果不需要的话可以取消该特性，取消以后会采用Qt自身的对话框，这样才能进行美化和其他处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QFileDialog *fileDialog = <span class="hljs-keyword">new</span> QFileDialog(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//不设置此属性根本查找不到任何子元素,因为默认采用的系统对话框</span><br>fileDialog-&gt;setOption(QFileDialog::DontUseNativeDialog, <span class="hljs-literal">true</span>);<br>qDebug() &lt;&lt; fileDialog-&gt;findChildren&lt;QLabel *&gt;();<br><span class="hljs-comment">//打印输出 QLabel(0x17e2ff68, name=&quot;lookInLabel&quot;), QLabel(0x17e35f88, name=&quot;fileNameLabel&quot;), QLabel(0x17e35e68, name=&quot;fileTypeLabel&quot;)</span><br></code></pre></td></tr></table></figure>

<h3 id="150-Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件"><a href="#150-Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件" class="headerlink" title="150. Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件"></a>150. Qt样式表有多种运行机制，主要是考虑到各种需求场景，继承自QWidget的类和qApp类都支持setStyleSheet方法，还可以统一将样式表放在文件，或者将样式文件加入到资源文件</h3><ul>
<li>斗气：qss内容写得到处都是，哪里需要就写在哪里，各种控件调用 setStyleSheet方法传入样式表内容，或者直接对应控件鼠标右键弹出菜单选择改变样式表填入内容；</li>
<li>斗者：qss内容放在文件，读取文件内容设置样式表，程序发布的时候带上qss文件；</li>
<li>斗师：qss文件作为资源文件放到qrc文件，直接编译到可执行文件中，防止篡改；</li>
<li>斗灵：在qss文件中自定义一些标志充当变量使用，读取以后替换对应的变量为颜色值，类似动态换肤；</li>
<li>斗王：放在文件容易被篡改，集成到可执行文件不够灵活，一旦样式表更新需要重新编译文件，如何做到既能只更新样式表文件，又不需要重新编译可执行文件，又能防止被篡改：采用rcc命令将资源文件编译生成二进制，只需要替换该二进制文件即可；</li>
<li>斗皇：继承qstyle类自己实现完成所有样式接口，统一整体风格，大名鼎鼎的UOS系统默认规则就是如此，不允许用样式表，全部painter绘制；</li>
</ul>
<h3 id="151-当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载"><a href="#151-当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载" class="headerlink" title="151. 当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载"></a>151. 当Qt中编译资源文件太大时，效率很低，或者需要修改资源文件中的文件比如图片、样式表等，需要重新编译可执行文件，这样很不友好，当然Qt都给我们考虑好了策略，此时可以将资源文件转化为二进制的rcc文件，这样就将资源文件单独出来了，可在需要的时候动态加载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Qt中使用二进制资源文件方法如下</span><br><span class="hljs-comment">//将qrc编译为二进制文件rcc，在控制台执行下列命令 </span><br>rcc -binary main.qrc -o main.rcc<br><span class="hljs-comment">//在应用程序中注册资源，一般在main函数启动后就注册</span><br>QResource::registerResource(qApp-&gt;applicationDirPath() + <span class="hljs-string">&quot;/main.rcc&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="152-关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有"><a href="#152-关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有" class="headerlink" title="152. 关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有"></a>152. 关于设置字体，大概都会经历一个误区，本来是打算设置整个窗体包括子控件的字体大小的，结果发现只有主窗体自己应用了字体而子控件没有</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假设窗体中有子控件，默认字体12px，父类类型是QWidget，父类类名是Widget</span><br><br><span class="hljs-comment">//下面几种方法只会设置主窗体的字体，子控件不会应用，需要按个调用setFont</span><br>QFont font;<br>font.setPixelSize(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">this</span>-&gt;setFont(font);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;&#123;font:26px;&#125;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;QWidget&#123;font:26px;&#125;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;Widget&#123;font:26px;&#125;&quot;</span>);<br><br><span class="hljs-comment">//下面才是通过样式表设置整个控件+子控件的字体</span><br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;font:26px;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;*&#123;font:26px;&#125;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;QWidget&gt;*&#123;font:26px;&#125;&quot;</span>);<br><span class="hljs-keyword">this</span>-&gt;setStyleSheet(<span class="hljs-string">&quot;Widget&gt;*&#123;font:26px;&#125;&quot;</span>);<br><br><span class="hljs-comment">//下面设置全局字体</span><br>qApp-&gt;setFont(font);<br></code></pre></td></tr></table></figure>

<h3 id="156-Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下"><a href="#156-Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下" class="headerlink" title="156. Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下"></a>156. Qt的UI界面在resize以后有个BUG，悬停样式没有取消掉，需要主动模拟鼠标动一下</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmMain::on_btnMenu_Max_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ......<br><br>    <span class="hljs-comment">//最大化以后有个BUG,悬停样式没有取消掉,需要主动模拟鼠标动一下    </span><br>    <span class="hljs-function">QEvent <span class="hljs-title">event</span><span class="hljs-params">(QEvent::Leave)</span></span>;<br>    QApplication::sendEvent(ui-&gt;btnMenu_Max, &amp;event);    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="158-Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多"><a href="#158-Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多" class="headerlink" title="158. Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多"></a>158. Qt的文本控件比如QTextEdit默认加载大文本比如10MB的文本，很容易卡死甚至崩溃，那是因为默认一个属性开启了，需要屏蔽掉就好很多</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ui-&gt;textEdit-&gt;setUndoRedoEnabled(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<h3 id="160-QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充"><a href="#160-QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充" class="headerlink" title="160. QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充"></a>160. QTabWidget选项卡控件，生成的tabbar选项卡宽度是按照文本自动设置的，文本越长选项卡的宽度越大，很多时候，我们需要的是一样的宽度或者等分填充</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1：字符串空格填充</span><br>ui-&gt;tabWidget-&gt;addTab(httpClient1, <span class="hljs-string">&quot;测    试&quot;</span>);<br>ui-&gt;tabWidget-&gt;addTab(httpClient1, <span class="hljs-string">&quot;人员管理&quot;</span>);<br>ui-&gt;tabWidget-&gt;addTab(httpClient1, <span class="hljs-string">&quot;系统设置&quot;</span>);<br><br><span class="hljs-comment">//方法2：识别尺寸改变事件自动设置最小宽度</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::resizeEvent</span><span class="hljs-params">(QResizeEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> count = ui-&gt;tabWidget-&gt;tabBar()-&gt;count();<br>    <span class="hljs-keyword">int</span> width = <span class="hljs-keyword">this</span>-&gt;width() - <span class="hljs-number">30</span>;<br>    QString qss = QString(<span class="hljs-string">&quot;QTabBar::tab&#123;min-width:%1px;&#125;&quot;</span>).arg(width / count);<br>    <span class="hljs-keyword">this</span>-&gt;setStyleSheet(qss);<br>&#125;<br><br><span class="hljs-comment">//方法3：设置全局样式，不同选项卡个数的设置不同的宽度</span><br>QStringList <span class="hljs-built_in">list</span>;<br><span class="hljs-built_in">list</span> &lt;&lt; QString(&quot;QTabWidget[tabCount=\&quot;2\&quot;]&gt;QTabBar::tab&#123;min-width:%<span class="hljs-number">1</span>px;&#125;<span class="hljs-string">&quot;).arg(100);</span><br><span class="hljs-string">list &lt;&lt; QString(&quot;</span>QTabWidget[tabCount=\<span class="hljs-string">&quot;3\&quot;]&gt;QTabBar::tab&#123;min-width:%1px;&#125;&quot;</span>).arg(<span class="hljs-number">70</span>);<br>qApp-&gt;setStyleSheet(<span class="hljs-built_in">list</span>.join(<span class="hljs-string">&quot;&quot;</span>));<br><span class="hljs-comment">//设置了tabCount弱属性自动去找对应的宽度设置</span><br>ui-&gt;tabWidget-&gt;setProperty(<span class="hljs-string">&quot;tabCount&quot;</span>, <span class="hljs-number">2</span>);<br>ui-&gt;tabWidget-&gt;setProperty(<span class="hljs-string">&quot;tabCount&quot;</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//方法4：强烈推荐-》使用内置的方法 setExpanding setDocumentMode 两个属性都必须设置</span><br><span class="hljs-comment">//Qt4的tabBar()是propected的，所以建议还是通过样式表设置</span><br>ui-&gt;tabWidget-&gt;tabBar()-&gt;setDocumentMode(<span class="hljs-literal">true</span>);<br>ui-&gt;tabWidget-&gt;tabBar()-&gt;setExpanding(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//样式表一步到位不用每个都单独设置</span><br>QString(<span class="hljs-string">&quot;QTabBar&#123;qproperty-usesScrollButtons:false;qproperty-documentMode:true;qproperty-expanding:true;&#125;&quot;</span>);<br><span class="hljs-comment">//在5.9以前开启这个设置后，貌似选项卡个数按照真实个数+1计算宽度，也就是永远会留空一个tab的占位。</span><br><span class="hljs-comment">//5.9以后貌似修复了这个BUG，按照理想中的拉伸填充等分设置tab的宽度。</span><br></code></pre></td></tr></table></figure>

<h3 id="163-如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸"><a href="#163-如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸" class="headerlink" title="163. 如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸"></a>163. 如果对窗体设置了固定尺寸，窗体会变得大小不可拉伸，如果需要重新还原可拉伸，必须重新设置最小尺寸和最大尺寸</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">setMinimumSize(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);<br></code></pre></td></tr></table></figure>

<h3 id="166-有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用-blockSignals-方法"><a href="#166-有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用-blockSignals-方法" class="headerlink" title="166. 有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法"></a>166. 有时候需要暂时停止某个控件发射信号（比如下拉框combobox添加数据的时候会触发当前元素改变信号），有多种处理，推荐用 blockSignals 方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1：先 disconnect 掉信号，处理好以后再 connect 信号，缺点很明显，很傻，如果信号很多，每个型号都要这么来一次。</span><br>disconnect(ui-&gt;cbox, SIGNAL(currentIndexChanged(<span class="hljs-keyword">int</span>)), <span class="hljs-keyword">this</span>, SLOT(on_cbox_currentIndexChanged(<span class="hljs-keyword">int</span>)));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>    ui-&gt;cbox-&gt;addItem(QString::number(i));<br>&#125;<br>connect(ui-&gt;cbox, SIGNAL(currentIndexChanged(<span class="hljs-keyword">int</span>)), <span class="hljs-keyword">this</span>, SLOT(on_cbox_currentIndexChanged(<span class="hljs-keyword">int</span>)));<br><br><span class="hljs-comment">//方法2：先调用 blockSignals(true) 阻塞信号，处理号以后再调用 blockSignals(false) 恢复所有信号。</span><br><span class="hljs-comment">//如果需要指定某个信号进行断开那就只能用 disconnect 来处理。</span><br>ui-&gt;cbox-&gt;blockSignals(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>    ui-&gt;cbox-&gt;addItem(QString::number(i));<br>&#125;<br>ui-&gt;cbox-&gt;blockSignals(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<h3 id="177-很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用"><a href="#177-很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用" class="headerlink" title="177. 很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用"></a>177. 很多时候需要在窗体首次显示的时候加载一些东西，而且只加载一次，当窗体再次显示的时候不加载。为什么不是在构造函数呢？因为很多玩意都是要在显示后才能确定，比如控件的尺寸，部分样式表的应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Widget::showEvent</span><span class="hljs-params">(QShowEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> isLoad = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!isLoad) &#123;<br>        isLoad = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//执行对应的处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="189-对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行"><a href="#189-对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行" class="headerlink" title="189. 对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行"></a>189. 对于QListView（QListWidget）、QTreeView（QTreeWidget）、QTableView（QTableWidget）这种类型的控件，可以通过setChecked来让对应的item产生复选框效果，很多人（包括曾经的自己）误以为这就是复选框控件，其实不是的，他是对应控件的indicator指示器，所以想要更换样式，不能说设置了QCheckBox的样式就有效果，而要单独对齐indicator指示器设置样式才行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QCheckBox::indicator,QGroupBox::indicator,QTreeWidget::indicator,QListWidget::indicator&#123;<br>width:<span class="hljs-number">13</span>px;<br>height:<span class="hljs-number">13</span>px;<br>&#125;<br><br>QCheckBox::indicator:unchecked,QGroupBox::indicator:unchecked,QTreeWidget::indicator:unchecked,QListWidget::indicator:unchecked&#123;<br>image:url(:/qss/flatwhite/checkbox_unchecked.png);<br>&#125;<br><br>QCheckBox::indicator:unchecked:disabled,QGroupBox::indicator:unchecked:disabled,QTreeWidget::indicator:unchecked:disabled,QListWidget::indicator:disabled&#123;<br>image:url(:/qss/flatwhite/checkbox_unchecked_disable.png);<br>&#125;<br><br>QCheckBox::indicator:checked,QGroupBox::indicator:checked,QTreeWidget::indicator:checked,QListWidget::indicator:checked&#123;<br>image:url(:/qss/flatwhite/checkbox_checked.png);<br>&#125;<br><br>QCheckBox::indicator:checked:disabled,QGroupBox::indicator:checked:disabled,QTreeWidget::indicator:checked:disabled,QListWidget::indicator:checked:disabled&#123;<br>image:url(:/qss/flatwhite/checkbox_checked_disable.png);<br>&#125;<br><br>QCheckBox::indicator:indeterminate,QGroupBox::indicator:indeterminate,QTreeWidget::indicator:indeterminate,QListWidget::indicator:indeterminate&#123;<br>image:url(:/qss/flatwhite/checkbox_parcial.png);<br>&#125;<br><br>QCheckBox::indicator:indeterminate:disabled,QGroupBox::indicator:indeterminate:disabled,QTreeWidget::indicator:indeterminate:disabled,QListWidget::indicator:indeterminate:disabled&#123;<br>image:url(:/qss/flatwhite/checkbox_parcial_disable.png);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="190-关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列"><a href="#190-关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列" class="headerlink" title="190. 关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列"></a>190. 关于QTableView（采用model数据源）、QTableWidget列名列宽设置，有时候发现没有起作用，原来是对代码设置的顺序有要求，比如setColumnWidth前必须先setColumnCount，不然列数都没有，哪来的列宽，包括setHorizontalHeaderLabels设置列标题集合也是，前提都要先有列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmSimple::initForm</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//实例化数据模型</span><br>    model = <span class="hljs-keyword">new</span> QStandardItemModel(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">//设置行数列数</span><br>    row = <span class="hljs-number">100</span>;<br>    column = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//设置列名列宽</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; column; ++i) &#123;<br>        columnNames &lt;&lt; QString(<span class="hljs-string">&quot;列%1&quot;</span>).arg(i + <span class="hljs-number">1</span>);<br>        columnWidths &lt;&lt; <span class="hljs-number">60</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmSimple::on_btnLoad1_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//先设置数据模型,否则 setColumnWidth 不起作用</span><br>    ui-&gt;tableView-&gt;setModel(model);<br><br>    <span class="hljs-comment">//设置列数及列标题和列宽</span><br>    model-&gt;setColumnCount(column);<br>    <span class="hljs-comment">//简便方法设置列标题集合</span><br>    model-&gt;setHorizontalHeaderLabels(columnNames);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; column; ++i) &#123;<br>        ui-&gt;tableView-&gt;setColumnWidth(i, columnWidths.at(i));<br>    &#125;<br><br>    <span class="hljs-comment">//循环添加行数据</span><br>    QDateTime now = QDateTime::currentDateTime();<br>    model-&gt;setRowCount(row);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; ++j) &#123;<br>            QStandardItem *item = <span class="hljs-keyword">new</span> QStandardItem;<br>            <span class="hljs-comment">//最后一列显示时间区别开来</span><br>            <span class="hljs-keyword">if</span> (j == column - <span class="hljs-number">1</span>) &#123;<br>                item-&gt;setText(now.addSecs(i).toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                item-&gt;setText(QString(<span class="hljs-string">&quot;%1_%2&quot;</span>).arg(i + <span class="hljs-number">1</span>).arg(j + <span class="hljs-number">1</span>));<br>            &#125;<br>            model-&gt;setItem(i, j, item);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmSimple::on_btnLoad2_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置列标题和列数及列宽</span><br>    ui-&gt;tableWidget-&gt;setColumnCount(column);<br>    <span class="hljs-comment">//简便方法设置列标题集合</span><br>    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(columnNames);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; column; ++i) &#123;<br>        ui-&gt;tableWidget-&gt;setColumnWidth(i, columnWidths.at(i));<br>    &#125;<br><br>    <span class="hljs-comment">//添加数据</span><br>    QDateTime now = QDateTime::currentDateTime();<br>    ui-&gt;tableWidget-&gt;setRowCount(row);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; ++j) &#123;<br>            QTableWidgetItem *item = <span class="hljs-keyword">new</span> QTableWidgetItem;<br>            <span class="hljs-comment">//最后一列显示时间区别开来</span><br>            <span class="hljs-keyword">if</span> (j == column - <span class="hljs-number">1</span>) &#123;<br>                item-&gt;setText(now.addSecs(i).toString(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                item-&gt;setText(QString(<span class="hljs-string">&quot;%1_%2&quot;</span>).arg(i + <span class="hljs-number">1</span>).arg(j + <span class="hljs-number">1</span>));<br>            &#125;<br>            ui-&gt;tableWidget-&gt;setItem(i, j, item);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="193-Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值"><a href="#193-Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值" class="headerlink" title="193. Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值"></a>193. Qt的布局的边距间隔，如果在没有改动过的情况下，是会根据系统分辨率以及缩放比来决定对应的默认值，是变化的，比如在1080P分辨率是9px，在2K分辨率又变成了11px，所有你会发现你在1080P电脑编译的程序，明明看到的是6px、9px，怎么到2K、4K分辨率下间隔和边距就变得好大，如果要保持无论何种分辨率都一样，你需要手动重新设置这些值，这里有个坑，比如默认是是9，你想其他分辨率也是9，你必须先把9改成其他值比如10，然后再改成9，这样才表示真的改动，你直接9改成9是不会变化的，在属性设计器中右侧有个小箭头恢复值的，也是灰色，只有加深显示，并且出现了恢复默认值箭头，才表示你确实是改过了值</h3><h3 id="194-Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5-6开始提供了-AA-EnableHighDpiScaling-的属性设置开启高分屏，到了5-14以后还可以指定缩放的策略-HighDpiScaleFactorRoundingPolicy-比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了-AA-EnableHighDpiScaling-属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放"><a href="#194-Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5-6开始提供了-AA-EnableHighDpiScaling-的属性设置开启高分屏，到了5-14以后还可以指定缩放的策略-HighDpiScaleFactorRoundingPolicy-比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了-AA-EnableHighDpiScaling-属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放" class="headerlink" title="194. Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放"></a>194. Qt对高分屏以及dpi缩放的支持越来越成熟，在Qt4时代默认的策略就是跟随系统的缩放，从Qt5.6开始提供了 AA_EnableHighDpiScaling 的属性设置开启高分屏，到了5.14以后还可以指定缩放的策略 HighDpiScaleFactorRoundingPolicy 比如支持浮点数的缩放比而不是之前的整数倍，从Qt6开始默认永远开启了 AA_EnableHighDpiScaling 属性，没法取消。很多时候我们需要两种模式，一种就是永远不应用高分屏及缩放，一种就是自动应用高分屏及缩放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//永远不应用高分屏及缩放</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    QApplication::setAttribute(Qt::AA_Use96Dpi);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,14,0))</span><br>    QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    ....<br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br><br><span class="hljs-comment">//自动应用高分屏及缩放</span><br><span class="hljs-comment">//方法很多，综合对比下来还是采用配置文件指定缩放策略最适中。</span><br><span class="hljs-comment">//新建qt.conf文件放到可执行文件同一目录</span><br>[Platforms]<br>WindowsArguments = dpiawareness=<span class="hljs-number">0</span><br><br><span class="hljs-comment">//有时候想让用户去选择何种策略，需要开启高分屏的之后只需要将qt.conf文件放到可执行文件同一目录即可，就算代码中设置了不应用高分屏及缩放，也无效，也是优先取qt.conf文件的策略。</span><br></code></pre></td></tr></table></figure>

<h3 id="195-关于QSS要注意的坑"><a href="#195-关于QSS要注意的坑" class="headerlink" title="195. 关于QSS要注意的坑"></a>195. 关于QSS要注意的坑</h3><ul>
<li>qss源自css，相当于css的一个子集，主要支持的是css2标准，很多网上的css3的标准的写法在qss这里是不生效的，所以不要大惊小怪。</li>
<li>qss也不是完全支持所有的css2，比如text-align官方文档就有说明，只支持 QPushButton and QProgressBar，务必看清楚。</li>
<li>有时候偷懒直接来一句 *{xxx}，你会发现大部分是应用了，也有小部分或者极个别没有应用，你可能需要在对应的窗体中 this-&gt;setStyleSheet() 来设置。</li>
<li>qss的执行是有优先级的，如果没有指定父对象，则对所有的应用，比如在窗体widget中 {color:#ff0000;} 这样会对widget以及widget的所有子对象应用该样式，这种问题各大Qt群每周都在上演，你会发现各种奇奇怪怪的异样不正常，怎么办呢，你需要指定类名或者对象名，比如 #widget{color:#ff0000;} 这样就只会对widget对象应用该样式，另一种写法 QWidget#widget{color:#ff0000;}，只想对窗体本身而不是子控件按钮标签等 .QWidget{color:#ff0000;} ，具体详细规则参见官方说明。</li>
<li>qss整体来说还是可以的，尽管有着有那的BUG，怀着包容的心对待它。</li>
</ul>
<h2 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h2><h3 id="65-在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致"><a href="#65-在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致" class="headerlink" title="65. 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致"></a>65. 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QRect <span class="hljs-title">rect</span><span class="hljs-params">(-radius, -radius, radius * <span class="hljs-number">2</span>, radius * <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-comment">//以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形</span><br>painter-&gt;drawArc(rect, <span class="hljs-number">0</span>, <span class="hljs-number">360</span> * <span class="hljs-number">16</span>);<br>painter-&gt;drawEllipse(rect);<br></code></pre></td></tr></table></figure>

<h3 id="78-很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色"><a href="#78-很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色" class="headerlink" title="78. 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色"></a>78. 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//根据背景色自动计算合适的前景色</span><br><span class="hljs-keyword">double</span> gray = (<span class="hljs-number">0.299</span> * color.red() + <span class="hljs-number">0.587</span> * color.green() + <span class="hljs-number">0.114</span> * color.blue()) / <span class="hljs-number">255</span>;<br>QColor textColor = gray &gt; <span class="hljs-number">0.5</span> ? Qt::black : Qt::white;<br></code></pre></td></tr></table></figure>

<h3 id="100-setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU"><a href="#100-setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU" class="headerlink" title="100. setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU"></a>100. setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU</h3><h3 id="101-如果需要在尺寸改变的时候不重绘窗体，则设置属性即可-this-gt-setAttribute-Qt-WA-StaticContents-true-这样可以避免可以避免对已经显示区域的重新绘制"><a href="#101-如果需要在尺寸改变的时候不重绘窗体，则设置属性即可-this-gt-setAttribute-Qt-WA-StaticContents-true-这样可以避免可以避免对已经显示区域的重新绘制" class="headerlink" title="101. 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-&gt;setAttribute(Qt::WA_StaticContents, true); 这样可以避免可以避免对已经显示区域的重新绘制"></a>101. 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-&gt;setAttribute(Qt::WA_StaticContents, true); 这样可以避免可以避免对已经显示区域的重新绘制</h3><h3 id="153-Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format-ARGB32或者Format-RGBA8888"><a href="#153-Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format-ARGB32或者Format-RGBA8888" class="headerlink" title="153. Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888"></a>153. Qt中封装的QImage异常的强大，提供了各种图片格式的转换，还可以对每个像素的颜色值进行替换，有时候我们需要将单色的图片换成另外一种颜色，要注意的是如果带有透明值的颜色需要进行格式转化，比如转成Format_ARGB32或者Format_RGBA8888</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//pixel      函数获取像素点的颜色 setPixel      函数设置像素点的颜色 此函数任意Qt版本都有</span><br><span class="hljs-comment">//pixelColor 函数获取像素点的颜色 setPixelColor 函数设置像素点的颜色 此函数Qt5.6以后才有</span><br><span class="hljs-comment">//pixel函数取出来的是QRgb格式需要用 qRed qGreen qBlue qAlpha 进行转换</span><br><span class="hljs-function">QImage <span class="hljs-title">image</span><span class="hljs-params">(<span class="hljs-string">&quot;1.png&quot;</span>)</span></span>;<br>image = image.convertToFormat(QImage::Format_ARGB32);<br><span class="hljs-keyword">int</span> width = image.width();<br><span class="hljs-keyword">int</span> height = image.height();<br><span class="hljs-comment">//遍历图像的每一个像素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; width; ++x) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; height; ++y) &#123;<br>        QString name = image.pixelColor(x, y).name();<br>        <span class="hljs-comment">//将白色以外的颜色全部替换成红色</span><br>        <span class="hljs-keyword">if</span> (name != <span class="hljs-string">&quot;#ffffff&quot;</span>) &#123;<br>            image.setPixelColor(x, y, Qt::red);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//保存文件</span><br>image.save(<span class="hljs-string">&quot;2.png&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="161-经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条"><a href="#161-经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条" class="headerlink" title="161. 经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条"></a>161. 经常有人说Qt垃圾，说用Qt在1毫秒绘制几千个数据点卡成屎。其实显示器最高刷新频率一般才60帧，1毫秒就绘制一次有意义吗？不仅显示器没刷新过来，人肉眼也看不过来（有人可能又要抬杠说这是老板要求的，显示归显示，至于人看不看那是另外一回事，我想说的是显示不就是给人看的吗？给程序看可以直接后台绘制图片让程序识别啊没必要显示的），程序中要做的应该是尽量降低程序的绘制刷新频率到显示器的频率（其实一秒钟30帧都足够），一次搞多一点的数据一次性绘制（数据量很大还可以考虑重采样，比如平均值法等，毕竟要考虑显示器的分辨率就那么大，搞个几十万的数据点挤一块没啥意思，可以将一整块区域内的数据点换成一个点），而不是绘制多次，尽管两种办法都可以将收到的数据绘制完成，但是效率相差的不是一点点，信号也是如此，不建议太频繁的发送信号，Qt内部1秒钟处理信号的个数也是有限制的，太频繁高并发的信号，很可能会丢失或者合并一部分，比如网络请求接收到的学生信息表，应该是在该应答数据内的所有学生信息解析完一次性发送，而不是解析一条发送一条</h3><h2 id="QtCore"><a href="#QtCore" class="headerlink" title="QtCore"></a>QtCore</h2><h3 id="46-巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行"><a href="#46-巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行" class="headerlink" title="46. 巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行"></a>46. 巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。查看源码得知，原来QEventLoop内部新建了线程执行</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QEventLoop loop;<br>connect(reply, SIGNAL(finished()), &amp;loop, SLOT(quit()));<br>loop.exec();<br></code></pre></td></tr></table></figure>

<h3 id="70-Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等"><a href="#70-Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等" class="headerlink" title="70. Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等"></a>70. Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QDateTime dateTime;<br>QString dateTime_str = dateTime.currentDateTime().toString(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<br><span class="hljs-comment">//从字符串转换为毫秒（需完整的年月日时分秒）</span><br>datetime.fromString(<span class="hljs-string">&quot;2011-09-10 12:07:50:541&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>).toMSecsSinceEpoch();<br><span class="hljs-comment">//从字符串转换为秒（需完整的年月日时分秒）</span><br>datetime.fromString(<span class="hljs-string">&quot;2011-09-10 12:07:50:541&quot;</span>, <span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>).toTime_t();<br><span class="hljs-comment">//从毫秒转换到年月日时分秒</span><br>datetime.fromMSecsSinceEpoch(<span class="hljs-number">1315193829218</span>).toString(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss:zzz&quot;</span>);<br><span class="hljs-comment">//从秒转换到年月日时分秒（若有zzz，则为000）</span><br>datetime.fromTime_t(<span class="hljs-number">1315193829</span>).toString(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss[:zzz]&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="71-在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用-at-取值而不是-操作符，在官方书籍《C-GUI-Qt-4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用-at-与使用-操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用-at-函数而不用-操作符，因为Qt的容器类不能辨别-操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而-at-函数则不被允许出现在一个赋值的左边"><a href="#71-在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用-at-取值而不是-操作符，在官方书籍《C-GUI-Qt-4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用-at-与使用-操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用-at-函数而不用-操作符，因为Qt的容器类不能辨别-操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而-at-函数则不被允许出现在一个赋值的左边" class="headerlink" title="71. 在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边"></a>71. 在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边</h3><h3 id="73-安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如-qDeleteAll-btns"><a href="#73-安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如-qDeleteAll-btns" class="headerlink" title="73. 安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns)"></a>73. 安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns)</h3><p>主要是记录后半句</p>
<h3 id="82-QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法"><a href="#82-QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法" class="headerlink" title="82. QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法"></a>82. QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (variant.typeName() == <span class="hljs-string">&quot;QColor&quot;</span>) &#123;<br>    QColor color = variant.value&lt;QColor&gt;();<br>    QFont font = variant.value&lt;QFont&gt;();<br>    QString nodeValue = color.name(QColor::HexArgb);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="83-Qt中的QString和const-char-之间转换，最好用toStdString-c-str-而不是toLocal8Bit-constData-，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常"><a href="#83-Qt中的QString和const-char-之间转换，最好用toStdString-c-str-而不是toLocal8Bit-constData-，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常" class="headerlink" title="83. Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常"></a>83. Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常</h3><h3 id="85-QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets-qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突"><a href="#85-QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets-qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突" class="headerlink" title="85. QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突"></a>85. QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突</h3><h3 id="87-在Qt5-10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-gt-tableView-gt-horizontalHeader-gt-setMinimumSectionSize-0"><a href="#87-在Qt5-10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-gt-tableView-gt-horizontalHeader-gt-setMinimumSectionSize-0" class="headerlink" title="87. 在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-&gt;tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0)"></a>87. 在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-&gt;tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0)</h3><h3 id="95-QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值"><a href="#95-QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值" class="headerlink" title="95. QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值"></a>95. QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QStyle::sliderValueFromPosition(minimum(), maximum(), event-&gt;x(), width());<br></code></pre></td></tr></table></figure>

<h3 id="97-用QFile-readAll-读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果"><a href="#97-用QFile-readAll-读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果" class="headerlink" title="97. 用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果"></a>97. 用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">frmMain::initStyle</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//加载样式表</span><br>    QString qss;<br>    <span class="hljs-comment">//QFile file(&quot;:/qss/psblack.css&quot;);</span><br>    <span class="hljs-comment">//QFile file(&quot;:/qss/flatwhite.css&quot;);</span><br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;:/qss/lightblue.css&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (file.open(QFile::ReadOnly)) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 1</span><br>        <span class="hljs-comment">//用QTextStream读取样式文件不用区分文件编码 带bom也行</span><br>        QStringList <span class="hljs-built_in">list</span>;<br>        <span class="hljs-function">QTextStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br>        <span class="hljs-comment">//in.setCodec(&quot;utf-8&quot;);</span><br>        <span class="hljs-keyword">while</span> (!in.atEnd()) &#123;<br>            QString line;<br>            in &gt;&gt; line;<br>            <span class="hljs-built_in">list</span> &lt;&lt; line;<br>        &#125;<br><br>        qss = <span class="hljs-built_in">list</span>.join(&quot;\n&quot;);<br>#<span class="hljs-keyword">else</span><br>        //用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开<br>        qss = QLatin1String(file.readAll());<br>#endif<br>        QString paletteColor = qss.mid(20, 7);<br>        qApp-&gt;setPalette(QPalette(QColor(paletteColor)));<br>        qApp-&gt;setStyleSheet(qss);<br>        file.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="98-QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用-qSetRealNumberPrecision-函数设置精确度位数即可"><a href="#98-QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用-qSetRealNumberPrecision-函数设置精确度位数即可" class="headerlink" title="98. QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可"></a>98. QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString s1, s2;<br>s1 = <span class="hljs-string">&quot;666.5567124&quot;</span>;<br>s2.setNum(<span class="hljs-number">888.5632123</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">7</span>);<br>qDebug() &lt;&lt; qSetRealNumberPrecision(<span class="hljs-number">10</span>) &lt;&lt; s1.toDouble() &lt;&lt; s2.toDouble();<br></code></pre></td></tr></table></figure>

<h3 id="118-Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置-setTimerType-Qt-PreciseTimer-。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用-startTimer-interval-Qt-PreciseTimer"><a href="#118-Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置-setTimerType-Qt-PreciseTimer-。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用-startTimer-interval-Qt-PreciseTimer" class="headerlink" title="118. Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer)"></a>118. Qt的默认定时器精度不够高（比如应用场景是1分钟保存一条记录或者文件，当你用默认的定时器的时候你会发现有些时候是60秒而有些是59秒随机的，如果客户有要求这就需要设置精度了。当然我们所做的绝大部分项目也不需要精度非常高的定时器，毕竟精度越高，占用的系统资源可能越大），如果需要设置更高的精度可以设置 setTimerType(Qt::PreciseTimer)。Qt有两种定时器处理，一种是QTimer类，还有一种是QObject类就内置的timeevent事件，如果是QObject类的定时器要设置的话调用 startTimer(interval, Qt::PreciseTimer)</h3><ul>
<li>Qt::PreciseTimer 精确的定时器，尽量保持毫秒精度。</li>
<li>Qt::CoarseTimer 粗略的定时器，尽量保持精度在所需的时间间隔5%范围内。</li>
<li>Qt::VeryCoarseTimer 很粗略的定时器，只保留完整的第二精度。</li>
<li>精度再高，也依赖对应的操作系统中断，假设中断需要 5ms，则定时器精度不可能高于5毫秒。</li>
</ul>
<h3 id="155-Qt5-10以后提供了新的类-QRandomGenerator-QRandomGenerator64-管理随机数，使用更方便，尤其是取某个区间的随机数"><a href="#155-Qt5-10以后提供了新的类-QRandomGenerator-QRandomGenerator64-管理随机数，使用更方便，尤其是取某个区间的随机数" class="headerlink" title="155. Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数"></a>155. Qt5.10以后提供了新的类 QRandomGenerator QRandomGenerator64 管理随机数，使用更方便，尤其是取某个区间的随机数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//早期处理办法 先初始化随机数种子然后取随机数</span><br>qsrand(QTime::currentTime().msec());<br><span class="hljs-comment">//取 0-10 之间的随机数</span><br>qrand() % <span class="hljs-number">10</span>;<br><span class="hljs-comment">//取 0-1 之间的浮点数</span><br>qrand() / <span class="hljs-keyword">double</span>(RAND_MAX);<br><br><span class="hljs-comment">//新版处理办法 支持5.10以后的所有版本包括qt6</span><br>QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">10</span>);      <span class="hljs-comment">//生成一个0和10之间的整数</span><br>QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">10.123</span>);  <span class="hljs-comment">//生成一个0和10.123之间的浮点数</span><br>QRandomGenerator::global()-&gt;bounded(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">//生成一个10和15之间的整数</span><br><br><span class="hljs-comment">//兼容qt4-qt6及以后所有版本的方法 就是用标准c++的随机数函数</span><br>srand(QTime::currentTime().msec());<br>rand() % <span class="hljs-number">10</span>;<br>rand() / <span class="hljs-keyword">double</span>(RAND_MAX);<br><br><span class="hljs-comment">//通用公式 a是起始值,n是整数的范围</span><br><span class="hljs-keyword">int</span> value = a + rand() % n;<br><span class="hljs-comment">//(min, max)的随机数</span><br><span class="hljs-keyword">int</span> value = min + <span class="hljs-number">1</span> + (rand() % (max - min - <span class="hljs-number">1</span>));<br><span class="hljs-comment">//(min, max]的随机数</span><br><span class="hljs-keyword">int</span> value = min + <span class="hljs-number">1</span> + (rand() % (max - min + <span class="hljs-number">0</span>));<br><span class="hljs-comment">//[min, max)的随机数</span><br><span class="hljs-keyword">int</span> value = min + <span class="hljs-number">0</span> + (rand() % (max - min + <span class="hljs-number">0</span>));<br><span class="hljs-comment">//[min, max]的随机数</span><br><span class="hljs-keyword">int</span> value = min + <span class="hljs-number">0</span> + (rand() % (max - min + <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//如果在线程中取随机数，线程启动的时间几乎一样，很可能出现取到的随机数一样的问题，就算设置随机数为当前时间啥的也没用，电脑太快很可能还是一样的时间，同一个毫秒。</span><br><span class="hljs-comment">//取巧办法就是在run函数之前最前面将当前线程的id作为种子设置。时间不可靠，线程的id才是唯一的。</span><br><span class="hljs-comment">//切记 void * 转换到数值必须用 long long，在32位是可以int但是在64位必须long，确保万一直接用quint64最大</span><br>srand((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)currentThreadId());<br>qrand((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)currentThreadId());<br></code></pre></td></tr></table></figure>

<h3 id="164-Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-gt-mouseButtons-，全局的鼠标坐标可以用QCursor-pos"><a href="#164-Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-gt-mouseButtons-，全局的鼠标坐标可以用QCursor-pos" class="headerlink" title="164. Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-&gt;mouseButtons()，全局的鼠标坐标可以用QCursor::pos()"></a>164. Qt内置了很多全局的对象参数可以直接获取，这样在使用的时候方便的不要不要的，比如判断当前鼠标左键还是右键可以直接用qApp-&gt;mouseButtons()，全局的鼠标坐标可以用QCursor::pos()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在鼠标右键的地方弹出菜单，如果菜单是QMenu而不是QAction则只能通过下面的方式弹出</span><br><span class="hljs-keyword">if</span> (qApp-&gt;mouseButtons() == Qt::RightButton) &#123;<br>    videoMenu-&gt;exec(QCursor::pos());<br>&#125;<br><br><span class="hljs-comment">//全局剪切板</span><br>qApp-&gt;clipboard();<br><span class="hljs-comment">//顶层控件对象集合</span><br>qApp-&gt;topLevelWidgets()<br><span class="hljs-comment">//当前焦点所在控件</span><br>qApp-&gt;focusWidget()<br><span class="hljs-comment">//当前平台名称</span><br>qApp-&gt;platformName()<br><span class="hljs-comment">//调用系统蜂鸣器</span><br>qApp-&gt;beep()<br><span class="hljs-comment">//打印当前Qt版本信息</span><br>qApp-&gt;aboutQt()<br><span class="hljs-comment">//设置全局的鼠标样式</span><br>qApp-&gt;setOverrideCursor()<br><span class="hljs-comment">//不使用系统的标准颜色字体等</span><br>QGuiApplication::setDesktopSettingsAware(<span class="hljs-keyword">bool</span> on);<br><span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br><span class="hljs-comment">//更多的全局对象属性等可以查阅 qguiapplication.h 头文件，你会发现新大陆。</span><br></code></pre></td></tr></table></figure>

<h3 id="171-在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen-s函数，比如fmod中也是这个情况。这个时候就需要转码处理"><a href="#171-在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen-s函数，比如fmod中也是这个情况。这个时候就需要转码处理" class="headerlink" title="171. 在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理"></a>171. 在Qt编程中经常会遇到编码的问题，由于跨平台的考虑兼容各种系统，而windows系统默认是gbk或者gb2312编码，当然后期可能msvc编译器都支持utf8编码，所以在部分程序中传入中文目录文件名称的时候会发现失败，因为可能对应的接口用了早期的fopen函数而不是fopen_s函数，比如fmod中也是这个情况。这个时候就需要转码处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString fileName = <span class="hljs-string">&quot;c:/测试目录/1.txt&quot;</span>;<br><span class="hljs-comment">//如果应用程序main函数中没有设置编码则默认采用系统的编码，可以直接通过toLocal8Bit转成正确的数据</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = fileName.toLocal8Bit().constData();<br><br><span class="hljs-comment">//如果设置过了下面两句则需要主动转码</span><br>QTextCodec *codec = QTextCodec::codecForName(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>QTextCodec::setCodecForLocale(codec);<br><br>QTextCodec *code = QTextCodec::codecForName(<span class="hljs-string">&quot;gbk&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = code-&gt;fromUnicode(fileName).constData();<br><br><span class="hljs-comment">//推荐方式2以防万一保证绝对的正确，哪怕是设置过主程序的编码</span><br><span class="hljs-comment">//切记一旦设置过QTextCodec::setCodecForLocale会影响toLocal8Bit</span><br><br><span class="hljs-comment">//有时候可能还有下面这种情况</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1400)</span><br>    QTextCodec *code = QTextCodec::codecForName(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    QTextCodec *code = QTextCodec::codecForName(<span class="hljs-string">&quot;gbk&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = code-&gt;fromUnicode(fileName).constData();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = fileName.toUtf8().constData();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="175-Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick-qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。"><a href="#175-Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick-qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。" class="headerlink" title="175. Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。"></a>175. Qt中基本上有三大类型的项目，控制台项目对应QCoreApplication、传统QWidget界面程序对应QApplication、quick/qml项目程序对应QGuiApplication。有很多属性的开启需要在main函数的最前面执行才有效果，比如开启高分屏支持、设置opengl模式等。不同类型的项目需要对应的QApplication。</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果是控制台程序则下面的QApplication换成QCoreApplication</span><br><span class="hljs-comment">//如果是quick/qml程序则下面的QApplication换成QGuiApplication</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//可以用下面这行测试Qt自带的输入法 qtvirtualkeyboard</span><br>    qputenv(<span class="hljs-string">&quot;QT_IM_MODULE&quot;</span>, QByteArray(<span class="hljs-string">&quot;qtvirtualkeyboard&quot;</span>));<br>    <br>    <span class="hljs-comment">//设置不应用操作系统设置比如字体</span><br>    QApplication::setDesktopSettingsAware(<span class="hljs-literal">false</span>);<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span><br>    <span class="hljs-comment">//设置高分屏缩放舍入策略</span><br>    QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0))</span><br>    <span class="hljs-comment">//设置启用高分屏缩放支持</span><br>    <span class="hljs-comment">//要注意开启后计算到的控件或界面宽度高度可能都不对,全部需要用缩放比例运算下</span><br>    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);<br>    <span class="hljs-comment">//设置启用高分屏图片支持</span><br>    QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span><br>    <span class="hljs-comment">//设置opengl模式 AA_UseDesktopOpenGL(默认) AA_UseOpenGLES AA_UseSoftwareOpenGL</span><br>    <span class="hljs-comment">//在一些很旧的设备上或者对opengl支持很低的设备上需要使用AA_UseOpenGLES表示禁用硬件加速</span><br>    <span class="hljs-comment">//如果开启的是AA_UseOpenGLES则无法使用硬件加速比如ffmpeg的dxva2</span><br>    <span class="hljs-comment">//QApplication::setAttribute(Qt::AA_UseOpenGLES);</span><br>    <span class="hljs-comment">//设置opengl共享上下文</span><br>    QApplication::setAttribute(Qt::AA_ShareOpenGLContexts);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    QWidget w;<br>    w.show();<br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="178-Qt获取当前所用的Qt版本、编译器、位数等信息"><a href="#178-Qt获取当前所用的Qt版本、编译器、位数等信息" class="headerlink" title="178. Qt获取当前所用的Qt版本、编译器、位数等信息"></a>178. Qt获取当前所用的Qt版本、编译器、位数等信息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//详细的Qt版本+编译器+位数</span><br>QString compilerString = <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>;<br>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(Q_CC_CLANG)</span><br>    QString isAppleString;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__apple_build_version__)</span><br>    isAppleString = QLatin1String(<span class="hljs-string">&quot; (Apple)&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    compilerString = QLatin1String(<span class="hljs-string">&quot;Clang &quot;</span>) + QString::number(__clang_major__) + QLatin1Char(<span class="hljs-string">&#x27;.&#x27;</span>) + QString::number(__clang_minor__) + isAppleString;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(Q_CC_GNU)</span><br>    compilerString = QLatin1String(<span class="hljs-string">&quot;GCC &quot;</span>) + QLatin1String(__VERSION__);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> defined(Q_CC_MSVC)</span><br>    <span class="hljs-keyword">if</span> (_MSC_VER &gt; <span class="hljs-number">1999</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC &lt;unknown&gt;&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1920</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2019&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1910</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2017&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1900</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2015&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1800</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2013&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1700</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2012&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_MSC_VER &gt;= <span class="hljs-number">1600</span>) &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC 2010&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        compilerString = QLatin1String(<span class="hljs-string">&quot;MSVC &lt;old&gt;&quot;</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">//拓展知识 查看 QSysInfo 类下面有很多好东西</span><br><span class="hljs-comment">// qVersion() = QT_VERSION_STR</span><br>QString version = QString(<span class="hljs-string">&quot;%1 %2 %3&quot;</span>).arg(qVersion()).arg(compilerString).arg(QString::number(QSysInfo::WordSize));<br></code></pre></td></tr></table></figure>

<h3 id="179-QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如-ddd-周二-Tue-dddd-星期二-Tuesday-，此时如果只想永远是中文就需要用到QLocale进行转换"><a href="#179-QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如-ddd-周二-Tue-dddd-星期二-Tuesday-，此时如果只想永远是中文就需要用到QLocale进行转换" class="headerlink" title="179. QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如 ddd = 周二 Tue  dddd = 星期二 Tuesday ，此时如果只想永远是中文就需要用到QLocale进行转换"></a>179. QDateTime可以直接格式化输出星期几周几，Qt6默认按照英文输出比如 ddd = 周二 Tue  dddd = 星期二 Tuesday ，此时如果只想永远是中文就需要用到QLocale进行转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//格式化输出受到本地操作系统语言的影响</span><br><br><span class="hljs-comment">//英文操作系统</span><br><span class="hljs-comment">//这样获取到的是Mon到Sun，英文星期的3个字母的缩写。</span><br>QDateTime::currentDateTime().toString(<span class="hljs-string">&quot;ddd&quot;</span>);<br><span class="hljs-comment">//这样获取到的是Monday到Sunday，英文星期完整单词。</span><br>QDateTime::currentDateTime().toString(<span class="hljs-string">&quot;dddd&quot;</span>);<br><br><span class="hljs-comment">//中文操作系统</span><br><span class="hljs-comment">//这样获取到的是周一到周日。</span><br>QDateTime::currentDateTime().toString(<span class="hljs-string">&quot;ddd&quot;</span>);<br><span class="hljs-comment">//这样获取到的是星期一到星期日。</span><br>QDateTime::currentDateTime().toString(<span class="hljs-string">&quot;dddd&quot;</span>);<br><br><span class="hljs-comment">//主动指定语言转换</span><br><span class="hljs-comment">//如果没有指定本地语言则默认采用系统的语言环境。</span><br>QLocale locale;<br><span class="hljs-comment">//QLocale locale = QLocale::Chinese;</span><br><span class="hljs-comment">//QLocale locale = QLocale::English;</span><br><span class="hljs-comment">//QLocale locale = QLocale::Japanese;</span><br><br><span class="hljs-comment">//下面永远输出中文的周一到周日</span><br>locale.toString(QDateTime::currentDateTime(), <span class="hljs-string">&quot;ddd&quot;</span>);<br><span class="hljs-comment">//下面永远输出中文的星期一到星期日</span><br>locale.toString(QDateTime::currentDateTime(), <span class="hljs-string">&quot;dddd&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="182-Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等"><a href="#182-Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等" class="headerlink" title="182. Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等"></a>182. Qt自带的日志重定向机制非常简单好用，自从用了以后再也不用什么断点调试啥的了，在需要的地方支持qdebug输出对应的信息，而且发布程序以后也可以开启调试日志将其输出查看等</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Qt5开始提供了日志上下文信息输出，比如输出当前打印消息所在的代码文件、行号、函数名等。</span><br><span class="hljs-comment">//如果是release还需要在pro中加上 DEFINES += QT_MESSAGELOGCONTEXT 才能输出上下文，默认release关闭的。</span><br><span class="hljs-comment">//切记不要在日志钩子函数中再写qdebug之类的，那样就死循环了。</span><br><span class="hljs-comment">//日志重定向一般就三种处理</span><br><span class="hljs-comment">//1: 输出到日志文件比如txt文本文件。</span><br><span class="hljs-comment">//2: 存储到数据库，可以分类存储，以便相关人员查询分析。</span><br><span class="hljs-comment">//3: 重定向到网络，对方用小工具连接程序后，所有打印信息通过tcp发过去。</span><br><br><span class="hljs-comment">//日志重定向</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(QtMsgType type, <span class="hljs-keyword">const</span> QMessageLogContext &amp;context, <span class="hljs-keyword">const</span> QString &amp;msg)</span></span><br><span class="hljs-function"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(QtMsgType type, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg)</span></span><br><span class="hljs-function"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//加锁,防止多线程中qdebug太频繁导致崩溃</span><br>    <span class="hljs-keyword">static</span> QMutex mutex;<br>    <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mutex)</span></span>;<br>    QString content;<br><br>    <span class="hljs-comment">//这里可以根据不同的类型加上不同的头部用于区分</span><br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> QtDebugMsg:<br>            content = QString(<span class="hljs-string">&quot;%1&quot;</span>).arg(msg);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> QtWarningMsg:<br>            content = QString(<span class="hljs-string">&quot;%1&quot;</span>).arg(msg);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> QtCriticalMsg:<br>            content = QString(<span class="hljs-string">&quot;%1&quot;</span>).arg(msg);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> QtFatalMsg:<br>            content = QString(<span class="hljs-string">&quot;%1&quot;</span>).arg(msg);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//加上打印代码所在代码文件、行号、函数名</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    <span class="hljs-keyword">if</span> (SaveLog::Instance()-&gt;getUseContext()) &#123;<br>        <span class="hljs-keyword">int</span> line = context.line;<br>        QString file = context.file;<br>        QString function = context.function;<br>        <span class="hljs-keyword">if</span> (line &gt; <span class="hljs-number">0</span>) &#123;<br>            content = QString(<span class="hljs-string">&quot;行号: %1  文件: %2  函数: %3\n%4&quot;</span>).arg(line).arg(file).arg(function).arg(content);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">//将内容传给函数进行处理</span><br>    SaveLog::Instance()-&gt;save(content);<br>&#125;<br><br><span class="hljs-comment">//安装日志钩子,输出调试信息到文件,便于调试</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveLog::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    qInstallMessageHandler(Log);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    qInstallMsgHandler(Log);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">//卸载日志钩子</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveLog::stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    qInstallMessageHandler(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    qInstallMsgHandler(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="184-由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4-Qt5-Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用-QT-VERSION-CHECK-需要先引入-include-“qglobal-h”不然编译失败，因为-QT-VERSION-CHECK-这个函数在-qglobal-h-头文件中"><a href="#184-由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4-Qt5-Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用-QT-VERSION-CHECK-需要先引入-include-“qglobal-h”不然编译失败，因为-QT-VERSION-CHECK-这个函数在-qglobal-h-头文件中" class="headerlink" title="184. 由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4/Qt5/Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用 QT_VERSION_CHECK 需要先引入#include “qglobal.h”不然编译失败，因为 QT_VERSION_CHECK 这个函数在 qglobal.h 头文件中"></a>184. 由于Qt版本众多，有时候为了兼容多个版本甚至跨度Qt4/Qt5/Qt6的兼容，有些头文件或者类名等变了或者新增了，需要用到Qt版本的判断。需要注意的是如果在头文件中使用 QT_VERSION_CHECK 需要先引入#include “qglobal.h”不然编译失败，因为 QT_VERSION_CHECK 这个函数在 qglobal.h 头文件中</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//至少要包含 qglobal.h，理论上Qt所有的类都包含了这个头文件，所以你引入Qt的其他头文件也行比如 qobject.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;qglobal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;qscreen.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;qdesktopwidget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="185-在使用QString转换到char-或者const-char-的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对"><a href="#185-在使用QString转换到char-或者const-char-的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对" class="headerlink" title="185. 在使用QString转换到char *或者const char *的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对"></a>185. 在使用QString转换到char *或者const char *的时候，务必记得分两步来完成，血的教训，在一个场景中，就因为没有分两步走，现象是msvc的debug异常release正常，mingw和gcc的debug和release都正常，这就很无语了，找问题找半天，对比法排除法按道理要么都有问题才对</h3><ul>
<li>转换前QString的内容无关中文还是英文，要出问题都一样。</li>
<li>转换中QByteArray无关具体类型，toUtf8、toLatin1、toLocal8Bit、toStdString等方法，要出问题都一样。</li>
<li>转换后无关char *还是const char *，要出问题都一样。</li>
<li>出问题的随机性的，概率出现，理论上debug的概率更大。</li>
<li>根据酷码大佬分析可能的原因(不确定)是msvc为了方便调试，debug会在内存释放后做填充，release则不会。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString text = <span class="hljs-string">&quot;xxxxx&quot;</span>;<br><span class="hljs-comment">//下面这样转换很可能会有问题</span><br><span class="hljs-keyword">char</span> *data = text.toUtf8().data();<br><span class="hljs-comment">//分两步转换肯定不会有问题</span><br>QByteArray buffer = text.toUtf8();<br><span class="hljs-keyword">char</span> *data = buffer.data();<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data = buffer.constData();<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="192-Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型"><a href="#192-Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型" class="headerlink" title="192. Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型"></a>192. Qt内置了一些QList、QMap、QHash相关的类型，可以直接用，不用自己写个长长的类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//qwindowdefs.h</span><br><span class="hljs-keyword">typedef</span> QList&lt;QWidget *&gt; QWidgetList;<br><span class="hljs-keyword">typedef</span> QList&lt;QWindow *&gt; QWindowList;<br><span class="hljs-keyword">typedef</span> QHash&lt;WId, QWidget *&gt; QWidgetMapper;<br><span class="hljs-keyword">typedef</span> QSet&lt;QWidget *&gt; QWidgetSet;<br><br><span class="hljs-comment">//qmetatype.h</span><br><span class="hljs-keyword">typedef</span> QList&lt;QVariant&gt; QVariantList;<br><span class="hljs-keyword">typedef</span> QMap&lt;QString, QVariant&gt; QVariantMap;<br><span class="hljs-keyword">typedef</span> QHash&lt;QString, QVariant&gt; QVariantHash;<br><span class="hljs-keyword">typedef</span> QList&lt;QByteArray&gt; QByteArrayList;<br></code></pre></td></tr></table></figure>

<h3 id="196-关于Qt延时的几种方法"><a href="#196-关于Qt延时的几种方法" class="headerlink" title="196. 关于Qt延时的几种方法"></a>196. 关于Qt延时的几种方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QUIHelperCore::sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> msec)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (msec &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 1</span><br>    <span class="hljs-comment">//非阻塞方式延时,现在很多人推荐的方法</span><br>    QEventLoop loop;<br>    QTimer::singleShot(msec, &amp;loop, SLOT(quit()));<br>    loop.exec();<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span><br>    <span class="hljs-comment">//阻塞方式延时,如果在主线程会卡住主界面</span><br>    QThread::msleep(msec);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-comment">//非阻塞方式延时,不会卡住主界面,据说可能有问题</span><br>    QTime endTime = QTime::currentTime().addMSecs(msec);<br>    <span class="hljs-keyword">while</span> (QTime::currentTime() &lt; endTime) &#123;<br>        QCoreApplication::processEvents(QEventLoop::AllEvents, <span class="hljs-number">100</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="pro"><a href="#pro" class="headerlink" title="pro"></a>pro</h2><h3 id="7-管理员运行程序，限定在MSVC编译器"><a href="#7-管理员运行程序，限定在MSVC编译器" class="headerlink" title="7.管理员运行程序，限定在MSVC编译器"></a>7.<code>管理员运行程序</code>，限定在MSVC编译器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QMAKE_LFLAGS += /MANIFESTUAC:<span class="hljs-string">&quot;level=&#x27;requireAdministrator&#x27; uiAccess=&#x27;false&#x27;&quot;</span> #以管理员运行<br>QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,<span class="hljs-string">&quot;5.01&quot;</span> #VS2013 在XP运行<br></code></pre></td></tr></table></figure>

<h3 id="8-运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上这个，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的"><a href="#8-运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上这个，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的" class="headerlink" title="8. 运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上这个，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，一般没法正常运行的程序都会打印一些提示信息缺啥之类的"></a>8. 运行文件附带调试输出窗口，这个非常有用，很多时候当我们发布程序阶段，我们会遇到程序双击无法运行也不报错提示（开发机器上一切正常），都不知道发生了什么，甚至任务管理器可以看到运行了但是没有界面弹出来，此时就需要在项目的pro文件中加上这个，带界面的程序也会自动弹出调试窗口打印输出信息，方便找问题，<code>一般没法正常运行的程序都会打印一些提示信息缺啥之类的</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">CONFIG      += console<br></code></pre></td></tr></table></figure>

<h3 id="13-根据操作系统位数判断加载"><a href="#13-根据操作系统位数判断加载" class="headerlink" title="13. 根据操作系统位数判断加载"></a>13. 根据操作系统位数判断加载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>win32 &#123;<br><br>​    contains(DEFINES, WIN64) &#123;<br><br>​        DESTDIR = $$PWD/../bin64<br><br>​    &#125; <span class="hljs-keyword">else</span> &#123; <br><br>​        DESTDIR = $$PWD/../bin32<br><br>​    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="31-判断编译器类型、编译器版本、操作系统"><a href="#31-判断编译器类型、编译器版本、操作系统" class="headerlink" title="31. 判断编译器类型、编译器版本、操作系统"></a>31. 判断编译器类型、编译器版本、操作系统</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//GCC编译器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __GNUC__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> __GNUC__ &gt;= 3   <span class="hljs-comment">// GCC3.0  以上</span></span><br><br><span class="hljs-comment">//MSVC编译器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _MSC_VER</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1000 <span class="hljs-comment">// VC++4.0 以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1100 <span class="hljs-comment">// VC++5.0 以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1200 <span class="hljs-comment">// VC++6.0 以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1300 <span class="hljs-comment">// VC2003  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1400 <span class="hljs-comment">// VC2005  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1500 <span class="hljs-comment">// VC2008  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1600 <span class="hljs-comment">// VC2010  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1700 <span class="hljs-comment">// VC2012  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1800 <span class="hljs-comment">// VC2013  以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> _MSC_VER &gt;=1900 <span class="hljs-comment">// VC2015  以上</span></span><br><br><span class="hljs-comment">//Borland C++</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __BORLANDC__</span><br><br><span class="hljs-comment">//Cygwin</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CYGWIN__</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __CYGWIN32__</span><br><br><span class="hljs-comment">//mingw</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span><br><br><span class="hljs-comment">//windows</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32           <span class="hljs-comment">//32bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64           <span class="hljs-comment">//64bit</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WINDOWS         <span class="hljs-comment">//图形界面程序</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _CONSOLE         <span class="hljs-comment">//控制台程序</span></span><br><br><span class="hljs-comment">//Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x030a)  <span class="hljs-comment">// Windows 3.1以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0400)  <span class="hljs-comment">// Windows 95/NT4.0以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0410)  <span class="hljs-comment">// Windows 98以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0500)  <span class="hljs-comment">// Windows Me/2000以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0501)  <span class="hljs-comment">// Windows XP以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (WINVER &gt;= 0x0600)  <span class="hljs-comment">// Windows Vista以上</span></span><br><br><span class="hljs-comment">//_WIN32_WINNT 内核版本</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (_WIN32_WINNT &gt;= 0x0500) <span class="hljs-comment">// Windows 2000以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (_WIN32_WINNT &gt;= 0x0501) <span class="hljs-comment">// Windows XP以上</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (_WIN32_WINNT &gt;= 0x0600) <span class="hljs-comment">// Windows Vista以上</span></span><br><br></code></pre></td></tr></table></figure>

<h3 id="32-在pro中判断Qt版本及构建套件位数"><a href="#32-在pro中判断Qt版本及构建套件位数" class="headerlink" title="32. 在pro中判断Qt版本及构建套件位数"></a>32. 在pro中判断Qt版本及构建套件位数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#打印版本信息<br>message(qt version: $$QT_VERSION)<br>#判断当前qt版本号<br>QT_VERSION = $$[QT_VERSION]<br>QT_VERSION = $$split(QT_VERSION, <span class="hljs-string">&quot;.&quot;</span>)<br>QT_VER_MAJ = $$member(QT_VERSION, <span class="hljs-number">0</span>)<br>QT_VER_MIN = $$member(QT_VERSION, <span class="hljs-number">1</span>)<br>#下面是表示 Qt5<span class="hljs-number">.5</span>及以上版本<br>greaterThan(QT_VER_MAJ, <span class="hljs-number">4</span>) &#123;<br>greaterThan(QT_VER_MIN, <span class="hljs-number">4</span>) &#123;<br>#自己根据需要做一些处理<br>&#125;&#125;<br><br>#QT_ARCH是Qt5新增的,在Qt4上没效果<br>#打印当前Qt构建套件的信息<br>message($$QT_ARCH)<br>#表示arm平台构建套件<br>contains(QT_ARCH, arm) &#123;&#125;<br>#表示<span class="hljs-number">32</span>位的构建套件<br>contains(QT_ARCH, i386) &#123;&#125;<br>#表示<span class="hljs-number">64</span>位的构建套件<br>contains(QT_ARCH, x86_64) &#123;&#125;<br><br>#其实Qt内置了主版本号和子版本号变量<br>#判断当前qt版本号<br>message($$QT_ARCH : $$QT_VERSION -&gt; $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION)<br><br>#下面的含义是如果版本 &lt; <span class="hljs-number">4.8</span><br>lessThan(QT_MAJOR_VERSION, <span class="hljs-number">5</span>) &#123;<br>lessThan(QT_MINOR_VERSION, <span class="hljs-number">8</span>) &#123;<br>#这里放要做的处理<br>&#125;&#125;<br><br>#下面的含义是如果版本 &lt; <span class="hljs-number">5.12</span><span class="hljs-number">.0</span><br>REQ_QT_MAJOR = <span class="hljs-number">5</span><br>REQ_QT_MINOR = <span class="hljs-number">12</span><br>REQ_QT_PATCH = <span class="hljs-number">0</span><br>lessThan(QT_MAJOR_VERSION, $$REQ_QT_MAJOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_MINOR)|lessThan(QT_MINOR_VERSION, $$REQ_QT_PATCH) &#123;<br>#这里放要做的处理<br>&#125;<br><br>#下面的含义是如果版本 &gt;= <span class="hljs-number">5.5</span><br>greaterThan(QT_MAJOR_VERSION, <span class="hljs-number">4</span>) &#123;<br>greaterThan(QT_MINOR_VERSION, <span class="hljs-number">4</span>) &#123;<br>#这里放要做的处理<br>&#125;&#125;<br><br><span class="hljs-comment">//代码中判断版本不要太简单</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span><br><span class="hljs-comment">//这里放要做的处理</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//下面表示 &gt;= 5.0.0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> QT_VERSION &gt;= 0x050000</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//下面表示 &lt; 5.12.10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> QT_VERSION &lt; 0x050C0A</span><br>...<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="47-多种预定义变量-if-defined-webkit-defined-webengine-，去掉生成空的debug和release目录-CONFIG-debug-and-release"><a href="#47-多种预定义变量-if-defined-webkit-defined-webengine-，去掉生成空的debug和release目录-CONFIG-debug-and-release" class="headerlink" title="47. 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug和release目录 CONFIG -= debug_and_release"></a>47. 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug和release目录 CONFIG -= debug_and_release</h3><h3 id="52-Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启-CONFIG-resources-big"><a href="#52-Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启-CONFIG-resources-big" class="headerlink" title="52. Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启 CONFIG += resources_big"></a>52. Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启 <code>CONFIG += resources_big</code></h3><h3 id="80-从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES-QT-DISABLE-DEPRECATED-BEFORE-0"><a href="#80-从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES-QT-DISABLE-DEPRECATED-BEFORE-0" class="headerlink" title="80. 从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0"></a>80. 从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0</h3><h3 id="104-在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则"><a href="#104-在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则" class="headerlink" title="104. 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则"></a>104. 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译或者设置好依赖规则</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TEMPLATE = subdirs<br>#设置ordered参数以后会依次编译 projA projB projC<br>CONFIG  += ordered<br>SUBDIRS += projA<br>SUBDIRS += projB<br>SUBDIRS += projC<br>#还可以通过设置depends指定某个项目依赖 比如下面指定projB依赖projA<br>projB.depends = projA<br>projC.depends = projA<br>projD.depends = projC<br></code></pre></td></tr></table></figure>

<h3 id="115-有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有-QT-的方式添加的模块，可以用-contains来判断"><a href="#115-有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有-QT-的方式添加的模块，可以用-contains来判断" class="headerlink" title="115. 有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT += 的方式添加的模块，可以用 contains来判断"></a>115. 有时候我们需要判断当前Qt版本有没有某个模块可以使用qtHaveModule（Qt5新引入的判断）来判断，如果要判断自己的项目中有没有 QT += 的方式添加的模块，可以用 contains来判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">qtHaveModule(webenginewidgets) &#123;<br>message(<span class="hljs-string">&quot;当前Qt库有找到 webenginewidgets 模块&quot;</span>)<br>&#125;<br><br>!qtHaveModule(webkit) &#123;<br>message(<span class="hljs-string">&quot;当前Qt库没有找到 webkit 模块&quot;</span>)<br>&#125;<br><br>contains(QT, network) &#123;<br>message(<span class="hljs-string">&quot;当前项目已经引入 network 模块&quot;</span>)<br>&#125;<br><br>!contains(QT, widgets) &#123;<br>message(<span class="hljs-string">&quot;当前项目没有引入 widgets 模块&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="126-Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出"><a href="#126-Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出" class="headerlink" title="126. Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出"></a>126. Qt提供了qDebug机制直接输出打印信息，这个弥补了QtCreator调试很鸡肋的缺点，而且无缝对接日志钩子，使得现场运行期间按照预定的打印信息输出到日志文件，有时候在开发阶段，又不想要看到一堆堆的打印信息，最笨的做法是一行行注释掉qdebug的地方，其实还可以直接pro中加上一行来禁用整个项目的qdebug输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#禁用qdebug打印输出<br>DEFINES += QT_NO_DEBUG_OUTPUT<br></code></pre></td></tr></table></figure>

<h3 id="127-在使用-QT-NO-DEBUG-OUTPUT-关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实-QT-NO-DEBUG-OUTPUT-禁用的-qdebug-的输出，Qt还有其他几种打印信息比如-qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用-qInfo-来输出信息就好。特别注意：qFatal-打印完信息程序会自动结束"><a href="#127-在使用-QT-NO-DEBUG-OUTPUT-关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实-QT-NO-DEBUG-OUTPUT-禁用的-qdebug-的输出，Qt还有其他几种打印信息比如-qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用-qInfo-来输出信息就好。特别注意：qFatal-打印完信息程序会自动结束" class="headerlink" title="127. 在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束"></a>127. 在使用 QT_NO_DEBUG_OUTPUT 关键字禁用了所有打印信息以后，可以节约不少的开销，有时候又想在禁用打印信息后，极少地方还需要看到打印信息，怎么办呢？其实 QT_NO_DEBUG_OUTPUT 禁用的 qdebug 的输出，Qt还有其他几种打印信息比如 qInfo、qWarning、qCritical，这些是不受影响的，也就是说在极少部分需要打印的地方用 qInfo 来输出信息就好。特别注意：qFatal 打印完信息程序会自动结束</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">qDebug() &lt;&lt; <span class="hljs-string">&quot;qDebug&quot;</span>;<br>qInfo() &lt;&lt; <span class="hljs-string">&quot;qInfo&quot;</span>;<br>qWarning() &lt;&lt; <span class="hljs-string">&quot;qWarning&quot;</span>;<br>qCritical() &lt;&lt; <span class="hljs-string">&quot;qCritical&quot;</span>;<br><br>qDebug(<span class="hljs-string">&quot;qDebug&quot;</span>);<br>qWarning(<span class="hljs-string">&quot;qWarning&quot;</span>);<br>qCritical(<span class="hljs-string">&quot;qCritical&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="128-Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去"><a href="#128-Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去" class="headerlink" title="128. Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去"></a>128. Qt的pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">#禁用qdebug打印输出<br>DEFINES     += QT_NO_DEBUG_OUTPUT<br><br>#自定义define变量 可以在整个项目中使用<br><span class="hljs-meta">#pro文件可以这样判断 contains(DEFINES, videovlc) &#123;&#125;</span><br>#代码文件可以这样判断 <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> videovlc</span><br>DEFINES     += videovlc1 videoffmpeg<br><br>#关闭编译警告提示 眼不见为净<br>CONFIG      += warn_off<br><br>#指定编译生成的文件到temp目录 分门别类存储<br>MOC_DIR     = temp/moc<br>RCC_DIR     = temp/rcc<br>UI_DIR      = temp/ui<br>OBJECTS_DIR = temp/obj<br><br>#指定编译生成的可执行文件到bin目录<br>DESTDIR     = bin<br></code></pre></td></tr></table></figure>

<h3 id="130-Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过-QMAKE-POST-LINK和QMAKE-PRE-LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索-qmake-Function-Reference-查看详情说明"><a href="#130-Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过-QMAKE-POST-LINK和QMAKE-PRE-LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索-qmake-Function-Reference-查看详情说明" class="headerlink" title="130. Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过 QMAKE_POST_LINK和QMAKE_PRE_LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索 qmake Function Reference 查看详情说明"></a>130. Qt的pro项目管理配置文件中也可添加各种编译前后的操作及配置，主要通过 QMAKE_POST_LINK和QMAKE_PRE_LINK，他们支持的函数以及写法，可以在QtCreator的帮助中搜索 qmake Function Reference 查看详情说明</h3><ul>
<li>QMAKE_PRE_LINK    表示编译前执行内容</li>
<li>QMAKE_POST_LINK   表示编译后执行内容</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">srcFile1 = $$PWD/<span class="hljs-number">1.</span>txt<br>srcFile2 = $$PWD/<span class="hljs-number">2.</span>txt<br>dstDir = $$PWD/../bin<br><span class="hljs-meta">#windows上需要转换路径斜杠 其他系统不需要</span><br>srcFile1 = $$replace(srcFile1, /, \\);<br>srcFile2 = $$replace(srcFile2, /, \\);<br>dstDir = $$replace(dstDir, /, \\);<br><br>#编译前执行拷贝 多个拷贝可以通过 &amp;&amp; 符号隔开<br>QMAKE_PRE_LINK += copy /Y $$srcFile1 $$dstDir &amp;&amp; copy /Y $$srcFile2 $$dstDir<br>#编译后执行拷贝 多个拷贝可以通过 &amp;&amp; 符号隔开<br>QMAKE_POST_LINK += copy /Y $$srcFile1 $$dstDir &amp;&amp; copy /Y $$srcFile2 $$dstDir<br></code></pre></td></tr></table></figure>

<h3 id="132-Qt6-0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件-QT-core5compat-才能用，-具体说明在https-doc-qt-io-qt-6-qtcore5-index-html"><a href="#132-Qt6-0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件-QT-core5compat-才能用，-具体说明在https-doc-qt-io-qt-6-qtcore5-index-html" class="headerlink" title="132. Qt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT += core5compat 才能用， 具体说明在https://doc.qt.io/qt-6/qtcore5-index.html"></a>132. Qt6.0发布了，是个比较大的改动版本，很多基础的类或者组件都放到单独的源码包中，需要自行官网下载并编译，默认不提供集成在开发目录下，需要手动编译并集成，比如QRegExp，QTextCodec类，需要编译集成后pro文件 QT += core5compat 才能用， 具体说明在<a target="_blank" rel="noopener" href="https://doc.qt.io/qt-6/qtcore5-index.html">https://doc.qt.io/qt-6/qtcore5-index.html</a></h3><h3 id="157-项目中启用c-11语法支持"><a href="#157-项目中启用c-11语法支持" class="headerlink" title="157. 项目中启用c++11语法支持"></a>157. 项目中启用c++11语法支持</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">greaterThan(QT_MAJOR_VERSION, <span class="hljs-number">4</span>): CONFIG += c++<span class="hljs-number">11</span><br>lessThan(QT_MAJOR_VERSION, <span class="hljs-number">5</span>): QMAKE_CXXFLAGS += -<span class="hljs-built_in">std</span>=c++<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>

<h3 id="165-Qt对区分不同的编译器也做了非常细致的处理"><a href="#165-Qt对区分不同的编译器也做了非常细致的处理" class="headerlink" title="165. Qt对区分不同的编译器也做了非常细致的处理"></a>165. Qt对区分不同的编译器也做了非常细致的处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#pro文件可以这样判断</span><br>msvc &#123;<br><span class="hljs-comment">//要做的处理</span><br>&#125;<br><br>mingw &#123;<br><span class="hljs-comment">//要做的处理</span><br>&#125;<br><br><span class="hljs-comment">//代码中可以这样判断</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_CC_MINGW</span><br><span class="hljs-comment">//mingw编译器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> Q_CC_MSVC</span><br><span class="hljs-comment">//msvc编译器</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//判断编译器和编译器版本</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined Q_CC_MSVC &amp;&amp; _MSC_VER &lt; 1300</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(Q_CC_GNU) &amp;&amp; (__GNUC__ &lt; 4)</span><br><br><span class="hljs-comment">//代码中判断ARM平台</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> QT_ARCH_ARM</span><br><span class="hljs-comment">//多个条件判断</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE)</span><br></code></pre></td></tr></table></figure>

<h3 id="167-项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2"><a href="#167-项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2" class="headerlink" title="167. 项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2"></a>167. 项目代码文件数量如果很多的话，全部包含在pro项目文件中会显得非常凌乱，甚至滚动条都要拉好久，有两个方法可以处理的更好，推荐方法2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//方法1：pro文件直接全部引入，而不是每个都添加一次，省心省力。</span><br>HEADERS += *.h<br>SOURCES += *.cpp<br><br><span class="hljs-comment">//方法2：分模块文件夹存放，不同模块用pri包含代码文件，比如界面可以放在ui文件夹，下面搞个ui.pri，然后pro项目文件只需要引入这个pri文件即可。</span><br>include($$PWD/ui/ui.pri)<br><span class="hljs-comment">//还可以加上一句包含路径这样可以省去在使用代码的时候不用写文件夹</span><br>INCLUDEPATH += $$PWD/ui<br><span class="hljs-comment">//加上上面这行，在使用头文件的时候可以直接 include &quot;form.h&quot;，没有加则需要 include &quot;ui/form.h&quot;。</span><br></code></pre></td></tr></table></figure>





<h2 id="元对象"><a href="#元对象" class="headerlink" title="元对象"></a>元对象</h2><h3 id="2-定时器是个好东西-QMetaObject-invokeMethod的使用"><a href="#2-定时器是个好东西-QMetaObject-invokeMethod的使用" class="headerlink" title="2. 定时器是个好东西(QMetaObject::invokeMethod的使用)"></a>2. 定时器是个好东西(<code>QMetaObject::invokeMethod的使用</code>)</h3><p>定时器是个好东西，学会好使用它，有时候用QTimer::singleShot单次定时器和<strong>QMetaObject::invokeMethod</strong>可以解决意想不到的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//异步执行load函数</span><br>QMetaObject::invokeMethod(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;load&quot;</span>, Qt::QueuedConnection);<br></code></pre></td></tr></table></figure>

<h3 id="11-获取类的属性"><a href="#11-获取类的属性" class="headerlink" title="11. 获取类的属性"></a>11. 获取类的属性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">const</span> QMetaObject *metaobject = object-&gt;metaObject();<br><br><span class="hljs-keyword">int</span> count = metaobject-&gt;propertyCount();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i) &#123;<br><br>​    QMetaProperty metaproperty = metaobject-&gt;property(i);<br><br>​    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name = metaproperty.name();<br><br>​    QVariant value = object-&gt;property(name);<br><br>​    qDebug() &lt;&lt; name &lt;&lt; value;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="18-巧妙的使用inherits判断是否属于某种类"><a href="#18-巧妙的使用inherits判断是否属于某种类" class="headerlink" title="18. 巧妙的使用inherits判断是否属于某种类"></a>18. 巧妙的使用inherits判断是否属于某种类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QTimer *timer = <span class="hljs-keyword">new</span> QTimer;         <span class="hljs-comment">// QTimer inherits QObject</span><br>timer-&gt;inherits(<span class="hljs-string">&quot;QTimer&quot;</span>);          <span class="hljs-comment">// returns true</span><br>timer-&gt;inherits(<span class="hljs-string">&quot;QObject&quot;</span>);         <span class="hljs-comment">// returns true</span><br>timer-&gt;inherits(<span class="hljs-string">&quot;QAbstractButton&quot;</span>); <span class="hljs-comment">// returns false</span><br></code></pre></td></tr></table></figure>

<h3 id="112-巧用QMetaObject-invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用-QMetaObject-invokeMethod-obj-“fun”-Qt-QueuedConnection-这种方式来就可以"><a href="#112-巧用QMetaObject-invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用-QMetaObject-invokeMethod-obj-“fun”-Qt-QueuedConnection-这种方式来就可以" class="headerlink" title="112. 巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, “fun”, Qt::QueuedConnection); 这种方式来就可以"></a>112. 巧用QMetaObject::invokeMethod方法可以实现很多效果，包括同步和异步执行，很大程度上解决了跨线程处理信号槽的问题。比如有个应用场景是在回调中，需要异步调用一个public函数，如果直接调用的话会发现不成功，此时需要使用 QMetaObject::invokeMethod(obj, “fun”, Qt::QueuedConnection); 这种方式来就可以</h3><ul>
<li>invokeMethod函数有很多重载参数，可以传入返回值和执行方法的参数等。</li>
<li>invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！</li>
<li>测试下来发现只能执行signals或者slots标识的方法。</li>
<li>默认可以执行private(protected/public) slots下的函数，但是不能执行private(protected/public)下的函数。</li>
<li>毛总补充：前提必须是slots或者signals标注的函数，不是标注的函数不在元信息导致无法查找，执行之后会提示No such method。</li>
<li>2021-11-06补充：如果要执行private(protected/public)下的函数，需要函数前面加上 Q_INVOKABLE 关键字，今天又学到了，必须加鸡腿。</li>
<li>其实这样看下来，就是任何方法函数都能执行了，这就超越了private(protected/public)的权限限定了，相当于一个类的私有函数用了 Q_INVOKABLE 关键字修饰也可以被 invokeMethod 执行，哇咔咔。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件声明信号和槽函数</span><br>signals:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sig_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type,<span class="hljs-keyword">double</span> value)</span></span>;<br><span class="hljs-keyword">private</span> slots:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slot_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> value)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">Q_INVOKABLE <span class="hljs-keyword">void</span> <span class="hljs-title">fun_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> value)</span></span>;<br><br><span class="hljs-comment">//构造函数关联信号槽</span><br>connect(<span class="hljs-keyword">this</span>, SIGNAL(sig_test(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)), <span class="hljs-keyword">this</span>, SLOT(slot_test(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>)));<br><br><span class="hljs-comment">//单击按钮触发信号和槽,这里是同时举例信号槽都可以</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::on_pushButton_clicked</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QMetaObject::invokeMethod(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;sig_test&quot;</span>, Q_ARG(<span class="hljs-keyword">int</span>, <span class="hljs-number">66</span>), Q_ARG(<span class="hljs-keyword">double</span>, <span class="hljs-number">66.66</span>));<br>    QMetaObject::invokeMethod(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;slot_test&quot;</span>, Q_ARG(<span class="hljs-keyword">int</span>, <span class="hljs-number">88</span>), Q_ARG(<span class="hljs-keyword">double</span>, <span class="hljs-number">88.88</span>));<br>    QMetaObject::invokeMethod(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;fun_test&quot;</span>, Q_ARG(<span class="hljs-keyword">int</span>, <span class="hljs-number">99</span>), Q_ARG(<span class="hljs-keyword">double</span>, <span class="hljs-number">99.99</span>));<br>&#125;<br><br><span class="hljs-comment">//会打印 66 66.66、88 88.88</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::slot_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    qDebug() &lt;&lt; type &lt;&lt; value;<br>&#125;<br><br><span class="hljs-comment">//会打印 99.99</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::fun_test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    qDebug() &lt;&lt; type &lt;&lt; value;<br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="webengine"><a href="#webengine" class="headerlink" title="webengine"></a>webengine</h2><h3 id="23-如果用了webengine模块，发布程序的时候带上QtWebEngineProcess-exe-translations文件夹-resources文件夹"><a href="#23-如果用了webengine模块，发布程序的时候带上QtWebEngineProcess-exe-translations文件夹-resources文件夹" class="headerlink" title="23. 如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe+translations文件夹+resources文件夹"></a>23. 如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe+translations文件夹+resources文件夹</h3><h3 id="94-QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染"><a href="#94-QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染" class="headerlink" title="94. QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染"></a>94. QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0))</span><br>    <span class="hljs-comment">//下面两种方法都可以,Qt默认采用的是AA_UseDesktopOpenGL</span><br>    QCoreApplication::setAttribute(Qt::AA_UseOpenGLES);<br>    <span class="hljs-comment">//QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br></code></pre></td></tr></table></figure>

<p>另外一个方法解决 全屏+QWebEngineView控件一起会产生右键菜单无法弹出的bug,需要上移一个像素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QRect rect = qApp-&gt;desktop()-&gt;geometry();<br>rect.setY(<span class="hljs-number">-1</span>);<br>rect.setHeight(rect.height());<br><span class="hljs-keyword">this</span>-&gt;setGeometry(rect);<br></code></pre></td></tr></table></figure>


<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="19-使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-gt-dynamicPropertyNames-列出所有弱属性名称，然后通过widget-gt-property-“name”-取出对应的弱属性的值"><a href="#19-使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-gt-dynamicPropertyNames-列出所有弱属性名称，然后通过widget-gt-property-“name”-取出对应的弱属性的值" class="headerlink" title="19. 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-&gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-&gt;property(“name”)取出对应的弱属性的值"></a>19. 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-&gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-&gt;property(“name”)取出对应的弱属性的值</h3><h3 id="22-善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来"><a href="#22-善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来" class="headerlink" title="22. 善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来"></a>22. 善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来</h3><h3 id="162-Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5-9以前需要拿到原有的窗体属性做运算，后面可以用新的方法"><a href="#162-Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5-9以前需要拿到原有的窗体属性做运算，后面可以用新的方法" class="headerlink" title="162. Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法"></a>162. Qt提供了N种窗体属性比如无边框属性FramelessWindowHint、不在任务栏显示属性Tool等，有时候我们需要对窗口的属性进行动态设置，比如增加一个属性或者移除一个属性，Qt5.9以前需要拿到原有的窗体属性做运算，后面可以用新的方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//增加一个无边框属性</span><br>setWindowFlags(windowFlags() | Qt::FramelessWindowHint);<br><span class="hljs-comment">//移除无边框属性</span><br>setWindowFlags(windowFlags() &amp; ~Qt::FramelessWindowHint);<br><br><span class="hljs-comment">//下面是5.9以后新增的方法</span><br><span class="hljs-comment">//增加一个无边框属性到窗体属性链表</span><br>setWindowFlag(Qt::FramelessWindowHint, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">//从窗体属性链表中移除无边框属性</span><br>setWindowFlag(Qt::FramelessWindowHint, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>




<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><h3 id="29-Qtcreator软件的配置文件存放在：C-Users-Administrator-AppData-Roaming-QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可"><a href="#29-Qtcreator软件的配置文件存放在：C-Users-Administrator-AppData-Roaming-QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可" class="headerlink" title="29. Qtcreator软件的配置文件存放在：C:\Users\Administrator\AppData\Roaming\QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可"></a>29. Qtcreator软件的配置文件存放在：C:\Users\Administrator\AppData\Roaming\QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可</h3><h3 id="48-新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About-Plugins。也可以设置代码检查级别，Tools》Options-》C-》Code-Model"><a href="#48-新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About-Plugins。也可以设置代码检查级别，Tools》Options-》C-》Code-Model" class="headerlink" title="48. 新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model"></a>48. 新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help》About Plugins。也可以设置代码检查级别，Tools》Options 》C++ 》Code Model</h3><h3 id="148-QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息"><a href="#148-QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息" class="headerlink" title="148. QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息"></a>148. QtCreator集成开发环境，也内置了对快速添加注释的支持，比如最常用的在头文件开头添加一大段通用模板的注释，标注文件创建者、时间等信息</h3><ul>
<li>菜单-&gt;工具-&gt;选项-&gt;文本编辑器-&gt;右侧tab页面片段(snippets)；</li>
<li>组选择C++, 可以看到这里面已经内置了不少定义比如foreach，可以依葫芦画瓢；</li>
<li>添加一个片段, 比如名字是fun, 触发种类是这个片段的简单描述；</li>
<li>当我们在代码文件中键入fun时, 会自动弹出智能提醒, 选择我们的代码片段回车, 自动填充代码；</li>
<li>按tab可以在变量间切换, 输入完成后回车, 完成编辑；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief $name$</span><br><span class="hljs-comment">  * @param $param$</span><br><span class="hljs-comment">  * @author feiyangqingyun</span><br><span class="hljs-comment">  * @date $date$</span><br><span class="hljs-comment">  */</span><br>$ret$ $name$($param$)<br>&#123;<br>    $$<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="51-在某些http-post数据的时候，如果采用的是-amp-字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码"><a href="#51-在某些http-post数据的时候，如果采用的是-amp-字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码" class="headerlink" title="51. 在某些http post数据的时候，如果采用的是&amp;字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码"></a>51. 在某些http post数据的时候，如果采用的是&amp;字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString content = <span class="hljs-string">&quot;测试中文&quot;</span>;<br>QString note = content.toUtf8().toPercentEncoding();<br></code></pre></td></tr></table></figure>

<h3 id="56-在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接"><a href="#56-在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接" class="headerlink" title="56. 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接"></a>56. 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> fd = tcpSocket-&gt;socketDescriptor();<br><span class="hljs-keyword">int</span> keepAlive = <span class="hljs-number">1</span>;      <span class="hljs-comment">//开启keepalive属性,缺省值:0(关闭)</span><br><span class="hljs-keyword">int</span> keepIdle = <span class="hljs-number">5</span>;       <span class="hljs-comment">//如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s)</span><br><span class="hljs-keyword">int</span> keepInterval = <span class="hljs-number">2</span>;   <span class="hljs-comment">//探测时发探测包的时间间隔为2秒,缺省值:75(s)</span><br><span class="hljs-keyword">int</span> keepCount = <span class="hljs-number">2</span>;      <span class="hljs-comment">//探测重试的次数,全部超时则认定连接失效,缺省值:9(次)</span><br>setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (<span class="hljs-keyword">void</span> *)&amp;keepAlive, <span class="hljs-keyword">sizeof</span>(keepAlive));<br>setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (<span class="hljs-keyword">void</span> *)&amp;keepIdle, <span class="hljs-keyword">sizeof</span>(keepIdle));<br>setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (<span class="hljs-keyword">void</span> *)&amp;keepInterval, <span class="hljs-keyword">sizeof</span>(keepInterval));<br>setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (<span class="hljs-keyword">void</span> *)&amp;keepCount, <span class="hljs-keyword">sizeof</span>(keepCount));<br></code></pre></td></tr></table></figure>

<h3 id="89-理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理"><a href="#89-理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理" class="headerlink" title="89. 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理"></a>89. 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理</h3><h3 id="92-新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写"><a href="#92-新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写" class="headerlink" title="92. 新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写"></a>92. 新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incomingConnection</span><span class="hljs-params">(qintptr handle)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">incomingConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> handle)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="107-很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源"><a href="#107-很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源" class="headerlink" title="107. 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源"></a>107. 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源</h3><ul>
<li>如果你没有使用wait***函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的；</li>
<li>还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给UI造成很大的压力的，最好的办法是解决如何不要频繁绘制UI比如合并数据一起绘制等；</li>
<li>如果是因为绘制UI造成的卡，那多线程也是没啥用的，因为UI只能在主线程；</li>
<li>串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中；</li>
<li>如果没有严格的数据同步需求，根本不需要调用wait***之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了；</li>
<li>有严格数据同步需求的场景还是放到多线程会好一些，不然你wait***就卡在那边了；</li>
<li>多线程是需要占用系统资源的，理论上来说，如果线程数量超过了CPU的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊；</li>
<li>再次强调，不要指望Qt的网络通信支持高并发，最多到1000个能正常工作就万事大吉，一般建议500以内的连接数。有大量高并发的需求请用第三方库比如swoole等。</li>
</ul>
<h3 id="168-在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的"><a href="#168-在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的" class="headerlink" title="168. 在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的"></a>168. 在网络通信中，无论是tcp客户端还是udp客户端，其实都是可以绑定网卡IP和端口的，很多人只知道服务端可以指定网卡监听端口。客户端如果没有绑定通信端口则由客户端所在的操作系统随机递增分配的，这里为啥这么强调，因为无数人，甚至不乏一些多年经验的新时代农名工，以为客户端的端口是服务端分配的，因为他们看到在服务端建立连接后可以打印出不同的端口号。网络通信的双方自己决定自己要用什么端口，服务器端只能决定自己监听的是哪个端口，不能决定客户端的端口，同理客户端也只能决定自己的端口。端口随机分配一般是按照顺序递增的，比如先是45110端口，连接重新建立就用45111端口，只要端口没被占用就这样递增下去，所以很多人会问是否可以复用一些端口，不然端口一直这样频繁的分配下去不妥，甚至有些特定的场景和需求也是会要求客户端绑定网卡和端口来和服务器通信的</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//tcp客户端</span><br>QTcpSocket *socket = <span class="hljs-keyword">new</span> QTcpSocket(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//断开所有连接和操作</span><br>socket-&gt;<span class="hljs-built_in">abort</span>();<br><span class="hljs-comment">//绑定网卡和端口</span><br>socket-&gt;bind(QHostAddress(<span class="hljs-string">&quot;192.168.1.2&quot;</span>), <span class="hljs-number">6005</span>);<br><span class="hljs-comment">//连接服务器</span><br>socket-&gt;connectToHost(<span class="hljs-string">&quot;192.168.1.3&quot;</span>, <span class="hljs-number">6000</span>);<br><br><span class="hljs-comment">//打印通信用的本地绑定地址和端口</span><br>qDebug() &lt;&lt; socket-&gt;localAddress() &lt;&lt; socket-&gt;localPort();<br><span class="hljs-comment">//打印通信服务器对方的地址和端口</span><br>qDebug() &lt;&lt; socket-&gt;peerAddress() &lt;&lt; socket-&gt;peerPort() &lt;&lt; socket-&gt;peerName();<br><br><span class="hljs-comment">//udp客户端</span><br>QUdpSocket *socket = <span class="hljs-keyword">new</span> QUdpSocket(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//绑定网卡和端口,没有绑定过才需要绑定</span><br><span class="hljs-comment">//采用端口是否一样来判断是为了方便可以直接动态绑定切换端口</span><br><span class="hljs-keyword">if</span> (socket-&gt;localPort() != <span class="hljs-number">6005</span>) &#123;<br>    socket-&gt;<span class="hljs-built_in">abort</span>();<br>    socket-&gt;bind(QHostAddress(<span class="hljs-string">&quot;192.168.1.2&quot;</span>), <span class="hljs-number">6005</span>);<br>&#125;<br><span class="hljs-comment">//指定地址和端口发送数据</span><br>socket-&gt;writeDatagram(buffer, QHostAddress(<span class="hljs-string">&quot;192.168.1.3&quot;</span>), <span class="hljs-number">6000</span>);<br><br><span class="hljs-comment">//上面是Qt5可以使用bind，Qt4中的QTcpSocket的对应接口是protected的没法直接使用，需要继承类重新实现把接口放出来。</span><br><span class="hljs-comment">//Qt4中的QUdpSocket有bind函数是开放的，奇怪了，为何Qt4中独独QTcpSocket不开放。</span><br>TcpSocket *socket = <span class="hljs-keyword">new</span> TcpSocket(<span class="hljs-keyword">this</span>);<br>socket-&gt;setLocalAddress(QHostAddress(<span class="hljs-string">&quot;192.168.1.2&quot;</span>));<br>socket-&gt;setLocalPort(<span class="hljs-number">6005</span>);<br></code></pre></td></tr></table></figure>

<h3 id="169-关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯"><a href="#169-关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯" class="headerlink" title="169. 关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯"></a>169. 关于网络通信，tcp和udp是两种不同的底层的网络通信协议，两者监听和通信的端口互不相干的，不同的协议或者不同的网卡IP地址可以用相同的端口。之前有个人说他的电脑居然可以监听一样的端口进行通信，颠覆了他以前的认知，书上说的明明是不可以相同端口的，后面远程一看原来选择的不同的网卡IP地址，当然可以的咯</h3><ul>
<li>tcp对网卡1监听了端口6000，还可以对网卡2监听端口6000。</li>
<li>tcp对网卡1监听了端口6000，udp对网卡1还可以继续监听端口6000。</li>
<li>tcp对网卡1监听了端口6000，在网卡1上其他tcp只能监听6000以外的端口。</li>
<li>udp协议也是上面的逻辑。</li>
</ul>
<h3 id="174-在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5-15开始内置了setTransferTimeout来设置超时时间，非常好用"><a href="#174-在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5-15开始内置了setTransferTimeout来设置超时时间，非常好用" class="headerlink" title="174. 在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用"></a>174. 在网络请求中经常涉及到超时时间的问题，因为默认是30秒钟，一旦遇到网络故障的时候要等好久才能反应过来，所以需要主动设置下超时时间，超过了就直接中断结束请求。从Qt5.15开始内置了setTransferTimeout来设置超时时间，非常好用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//局部的事件循环,不卡主界面</span><br>QEventLoop eventLoop;<br><br><span class="hljs-comment">//设置超时 5.15开始自带了超时时间函数 默认30秒</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,15,0))</span><br>manager-&gt;setTransferTimeout(timeout);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>QTimer timer;<br>connect(&amp;timer, SIGNAL(timeout()), &amp;eventLoop, SLOT(quit()));<br>timer.setSingleShot(<span class="hljs-literal">true</span>);<br>timer.start(timeout);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>QNetworkReply *reply = manager-&gt;get(QNetworkRequest(QUrl(url)));<br>connect(reply, SIGNAL(finished()), &amp;eventLoop, SLOT(quit()));<br>eventLoop.exec();<br><br><span class="hljs-keyword">if</span> (reply-&gt;bytesAvailable() &gt; <span class="hljs-number">0</span> &amp;&amp; reply-&gt;error() == QNetworkReply::NoError) &#123;<br>    <span class="hljs-comment">//读取所有数据保存成文件</span><br>    QByteArray data = reply-&gt;readAll();<br>    <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(dirName + fileName)</span></span>;<br>    <span class="hljs-keyword">if</span> (file.open(QFile::WriteOnly | QFile::Truncate)) &#123;<br>        file.write(data);<br>        file.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>






<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="30-QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV-Filters安装即可（k-lite或者LAV-Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）"><a href="#30-QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV-Filters安装即可（k-lite或者LAV-Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）" class="headerlink" title="30. QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）"></a>30. QMediaPlayer是个壳（也可以叫框架），依赖本地解码器，视频这块默认基本上就播放个MP4甚至连MP4都不能播放，如果要支持其他格式需要下载k-lite或者LAV Filters安装即可（k-lite或者LAV Filters是指windows上的，其他系统上自行搜索，貌似嵌入式linux上依赖GStreamer，并未完整验证）。如果需要做功能强劲的播放器，初学者建议用vlc、mpv，终极万能大法用ffmpeg（解码出来的视频可以用QOpenGLWidget走GPU绘制或者转成QImage绘制，音频数据可以用QAudioOutput播放）</h3><h3 id="41-如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库"><a href="#41-如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库" class="headerlink" title="41. 如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库"></a>41. 如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QSqlDatabase db = QSqlDatabase::addDatabase(<span class="hljs-string">&quot;QSQLITE&quot;</span>);<br>db.setDatabaseName(<span class="hljs-string">&quot;:memory:&quot;</span>);<br></code></pre></td></tr></table></figure>


<h3 id="49-QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据"><a href="#49-QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据" class="headerlink" title="49. QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据"></a>49. QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据</h3><p>如果数据量很小，也可以采用如下方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//主动加载所有数据,不然获取到的行数&lt;=256</span><br><span class="hljs-keyword">while</span>(model-&gt;canFetchMore()) &#123;<br>    model-&gt;fetchMore();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="62-对于大段的注释代码，建议用-if-0-endif-将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是-if-0则只要把0改成1即可，开发效率提升很多"><a href="#62-对于大段的注释代码，建议用-if-0-endif-将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是-if-0则只要把0改成1即可，开发效率提升很多" class="headerlink" title="62. 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多"></a>62. 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部双斜杠注释，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，开发效率提升很多</h3><h3 id="88-Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private-widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT-gui-private才能使用"><a href="#88-Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private-widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT-gui-private才能使用" class="headerlink" title="88. Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用"></a>88. Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;QtGui/private/qzipreader_p.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;QtGui/private/qzipwriter_p.h&quot;</span></span><br><br><span class="hljs-function">QZipReader <span class="hljs-title">reader</span><span class="hljs-params">(dirPath)</span></span>;<br><span class="hljs-function">QString <span class="hljs-title">path</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span>)</span></span>;<br><span class="hljs-comment">//解压文件夹到当前目录</span><br>reader.extractAll(path);<br><span class="hljs-comment">//文件夹名称</span><br>QZipReader::FileInfo fileInfo = reader.entryInfoAt(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//解压文件</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(filePath)</span></span>;<br>file.open(QIODevice::WriteOnly);<br>file.write(reader.fileData(QString::fromLocal8Bit(<span class="hljs-string">&quot;%1&quot;</span>).arg(filePath)));<br>file.close();<br>reader.close();<br><br>QZipWriter *writer = <span class="hljs-keyword">new</span> QZipWriter(dirPath);<br><span class="hljs-comment">//添加文件夹</span><br>writer-&gt;addDirectory(unCompress);<br><span class="hljs-comment">//添加文件</span><br><span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(filePath)</span></span>;<br>file.open(QIODevice::ReadOnly);<br>writer-&gt;addFile(data, file.readAll());<br>file.close();<br>writer-&gt;close();<br></code></pre></td></tr></table></figure>

<h3 id="91-数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题"><a href="#91-数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题" class="headerlink" title="91. 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题"></a>91. 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题</h3><h3 id="105-MSVC编译器的选择说明"><a href="#105-MSVC编译器的选择说明" class="headerlink" title="105. MSVC编译器的选择说明"></a>105. MSVC编译器的选择说明</h3><ul>
<li>如果是32位的Qt则编译器选择x86开头的</li>
<li>如果是64位的Qt则编译器选择amd64开头的</li>
<li>具体是看安装的Qt构建套件版本以及目标运行平台的系统位数和架构</li>
<li>一般现在的电脑默认以64位的居多，选择amd64即可</li>
<li>如果用户需要兼容32位的系统则建议选择32位的Qt，这样即可在32位也可以在64位系统运行</li>
<li>诸葛大佬补充：x86/x64都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>x86</td>
<td>32/64位系统上编译在32/64位系统上运行</td>
</tr>
<tr>
<td>x86_amd64</td>
<td>32/64位系统上编译在64位系统上运行</td>
</tr>
<tr>
<td>x86_arm</td>
<td>32/64位系统上编译在arm系统上运行</td>
</tr>
<tr>
<td>amd64</td>
<td>64位系统上编译在64位系统上运行</td>
</tr>
<tr>
<td>amd64_x86</td>
<td>64位系统上编译在32/64位系统上运行</td>
</tr>
<tr>
<td>amd64_arm</td>
<td>64位系统上编译在arm系统上运行</td>
</tr>
</tbody></table>
<h3 id="116-c-11新引入了原始字符串格式，用户避免在字符串中加入转义字符-，可以用于表示json字符串等场景"><a href="#116-c-11新引入了原始字符串格式，用户避免在字符串中加入转义字符-，可以用于表示json字符串等场景" class="headerlink" title="116. c++11新引入了原始字符串格式，用户避免在字符串中加入转义字符\，可以用于表示json字符串等场景"></a>116. c++11新引入了原始字符串格式，用户避免在字符串中加入转义字符\，可以用于表示json字符串等场景</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString s1 = <span class="hljs-string">R&quot;(test\001.jpg)&quot;</span>;<br>s1.replace(<span class="hljs-string">&quot;\\&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>);<br>qDebug()&lt;&lt; s1;<br><span class="hljs-comment">//结果 test#001.jpg</span><br></code></pre></td></tr></table></figure>

<h3 id="120-用QSettings设置注册表，如果不是管理员身份运行会打印-QSettings-failed-to-set-subkey-“xxx”-拒绝访问。-，你需要手动鼠标右键管理员身份运行就可以"><a href="#120-用QSettings设置注册表，如果不是管理员身份运行会打印-QSettings-failed-to-set-subkey-“xxx”-拒绝访问。-，你需要手动鼠标右键管理员身份运行就可以" class="headerlink" title="120. 用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey “xxx” (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以"></a>120. 用QSettings设置注册表，如果不是管理员身份运行会打印 QSettings: failed to set subkey “xxx” (拒绝访问。)，你需要手动鼠标右键管理员身份运行就可以</h3><h3 id="129-Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理"><a href="#129-Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理" class="headerlink" title="129. Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理"></a>129. Qt对操作系统层的消息也做了很多的封装，可以直接拿到进行处理（如果需要拦截处理要用对应操作系统的API才行比如鼠标键盘钩子），比如系统休眠和唤醒做一些处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//主窗体头文件</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">nativeEvent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QByteArray &amp;eventType, <span class="hljs-keyword">void</span> *message, <span class="hljs-keyword">long</span> *result)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">winEvent</span><span class="hljs-params">(MSG *message, <span class="hljs-keyword">long</span> *result)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-comment">//主窗体实现函数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">frmMain::nativeEvent</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QByteArray &amp;eventType, <span class="hljs-keyword">void</span> *message, <span class="hljs-keyword">long</span> *result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (eventType == <span class="hljs-string">&quot;windows_generic_MSG&quot;</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br>        MSG *msg = <span class="hljs-keyword">static_cast</span>&lt;MSG *&gt;(message);<br>        <span class="hljs-comment">//qDebug() &lt;&lt; TIMEMS &lt;&lt; msg-&gt;message;</span><br>        <span class="hljs-keyword">if</span> (msg-&gt;wParam == PBT_APMSUSPEND &amp;&amp; msg-&gt;message == WM_POWERBROADCAST) &#123;<br>            <span class="hljs-comment">//系统休眠的时候自动最小化可以规避程序可能出现的问题</span><br>            <span class="hljs-keyword">this</span>-&gt;showMinimized();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg-&gt;wParam == PBT_APMRESUMEAUTOMATIC) &#123;<br>            <span class="hljs-comment">//休眠唤醒后自动打开</span><br>            <span class="hljs-keyword">this</span>-&gt;showNormal();<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eventType == <span class="hljs-string">&quot;NSEvent&quot;</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_MACOS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> Q_OS_WIN</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">frmMain::winEvent</span><span class="hljs-params">(MSG *message, <span class="hljs-keyword">long</span> *result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> nativeEvent(<span class="hljs-string">&quot;windows_generic_MSG&quot;</span>, message, result);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h3 id="135-Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件"><a href="#135-Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件" class="headerlink" title="135. Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件"></a>135. Qt的ini配置文件默认不支持直接读写中文，需要手动设置下编码格式才行，强烈建议统一用utf-8编码，包括代码文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//设置了编码以后配置文件内容为 Company=上海物联网技术研究中心</span><br><span class="hljs-comment">//没有设置编码则配置文件内容为 Company=\xe4\xb8\x8a\xe6\xb5\xb7\xe7\x89\xa9\xe8\x81\x94\xe7\xbd\x91\xe6\x8a\x80\xe6\x9c\xaf\xe7\xa0\x94\xe7\xa9\xb6\xe4\xb8\xad\xe5\xbf\x83</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">App::readConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QSettings <span class="hljs-title">set</span><span class="hljs-params">(App::ConfigFile, QSettings::IniFormat)</span></span>;<br>    <span class="hljs-built_in">set</span>.setIniCodec(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>    <span class="hljs-built_in">set</span>.beginGroup(<span class="hljs-string">&quot;AppConfig1&quot;</span>);<br>    App::Company = <span class="hljs-built_in">set</span>.value(<span class="hljs-string">&quot;Company&quot;</span>, App::Company).toString();<br>    <span class="hljs-built_in">set</span>.endGroup();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">App::writeConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QSettings <span class="hljs-title">set</span><span class="hljs-params">(App::ConfigFile, QSettings::IniFormat)</span></span>;<br>    <span class="hljs-built_in">set</span>.setIniCodec(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>    <span class="hljs-built_in">set</span>.beginGroup(<span class="hljs-string">&quot;AppConfig1&quot;</span>);<br>    <span class="hljs-built_in">set</span>.setValue(<span class="hljs-string">&quot;Company&quot;</span>, App::Company);<br>    <span class="hljs-built_in">set</span>.endGroup();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="137-Qt重载qDebug输出自定义的信息"><a href="#137-Qt重载qDebug输出自定义的信息" class="headerlink" title="137. Qt重载qDebug输出自定义的信息"></a>137. Qt重载qDebug输出自定义的信息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FunctionInfo</span> &#123;</span><br>    QString function;<br>    QString name;<br>    QString groupEnabled;<br>    QString action;<br>    QString group;<br><br>    <span class="hljs-keyword">friend</span> QDebug <span class="hljs-keyword">operator</span> &lt;&lt; (QDebug debug, <span class="hljs-keyword">const</span> FunctionInfo &amp;functionInfo) &#123;<br>        QString info = QString(<span class="hljs-string">&quot;功能: %1  名称: %2  启用: %3  方法: %4  分组: %5&quot;</span>)<br>                       .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled)<br>                       .arg(functionInfo.action).arg(functionInfo.group);<br>        debug &lt;&lt; info;<br>        <span class="hljs-keyword">return</span> debug;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="144-关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论"><a href="#144-关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论" class="headerlink" title="144. 关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论"></a>144. 关于Qt众多版本（至少几百个）都不兼容的问题，在经过和Qt中国的林斌大神和其他大神（Qt非官方技术交流群）头脑风暴以后，最终得出以下的结论</h3><ul>
<li>Qt在二进制兼容这块，已经做了最大的努力，通过将各种代码细节隐藏，Q指针+D指针技巧，尽量保持了接口的统一；</li>
<li>是否兼容最主要考虑编译器的因素，毕竟任何Qt版本都是需要通过编译器编译成对应的二进制文件，由他说了算。如果两个Qt版本采用的编译器版本一样，极大概率可执行文件是兼容的，比如 Qt5.10+msvc2015 32 位 和 Qt5.11+msvc2015 32位 编译出来的可执行文件，都用Qt5.11的库是可行的；</li>
<li>mingw编译器的Qt版本也是如此，就是因为Qt官方安装包集成的mingw编译器一直在更新（极少附近版本没有更新mingw编译器版本除外），比如5.7用的mingw53，5.12用的mingw73，5.15用的mingw81，因为带的Qt库也是这个编译器编译出来的，所以导致看起来全部不兼容；</li>
<li>如果想要完全兼容，还有一个注意要素，那就是对应代码使用的类的头文件接口是否变了，按道理原有的接口极少会变，一般都是新增加，或者大版本才会改变，比如Qt4-Qt5-Qt6这种肯定没法兼容的，接口和模块都变了；</li>
<li>大胆的猜测：如果Qt5.6到Qt5.15你全部用一种编译器比如mingw73或者msvc2015重新编译生成对应的Qt运行库，然后在此基础上开发程序，最后生成的可执行文件用Qt5.15的库是都可以的，这样就轻松跨越了多个版本兼容；</li>
<li>大胆的建议：在附近的几个版本统一编译器，比如5.6-5.12之间就统一用mingw53或者msvc2015,5.12-5.15统一用msvc2017，要尝鲜其他编译器的可以自行源码编译其他版本，这样最起码附近的一大段版本（大概2-3年的版本周期）默认就兼容了。</li>
<li>本人测试的是widget部分，qml未做测试，不清楚是否机制一样；</li>
</ul>
<h3 id="154-在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论"><a href="#154-在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论" class="headerlink" title="154. 在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论"></a>154. 在数据库相关的应用中，如果仅仅是单机版本，没有特别的需要（比如领导指定，或者需要远程存放数据），强烈建议使用sqlite数据库，这是本人经过无数次的对比测试和N个商业项目应用得出的结论</h3><ul>
<li>Qt天生内置了sqlite数据库，只需要发布的时候带上插件就行（可以看到插件动态库文件比其他几种都要大，那是因为直接将数据库的源码都编译进去了，而其他只编译了中间通信交互的插件源码），其他数据库要么还要带上动态库，要么还需要创建数据源；</li>
<li>速度上，绝对无与伦比的出类拔萃，同样的数据库结构（表结构、索引等完全一致），查询速度和批量更新速度、数据库事务等，速度都是其他几种的至少3倍以上，而且随着数据量的增大对比越发明显；</li>
<li>几千万的数据量完全没问题，而且速度和性能都还可以，不要以讹传讹网上部分菜鸡说的不支持百万以上的数据量，本人亲测亿级别，数据量建议千万级别以下，着重注意数据库表和索引的设计；</li>
<li>其他数据库还要注意版本的区别，ODBC数据源形式还容易出错和执行失败；</li>
<li>sqlite数据库也有几个重大缺点：不支持加密，不支持网络访问，不支持部分数据库高级特性，不支持海量数据（亿级别以上），但是对于绝大部分Qt项目还是足够；</li>
<li>数据库支持友好度大致是 sqlite &gt; postgresql &gt; mysql &gt; odbc ;</li>
<li>以上都是在Qt环境中个人测试得出的结论，结果未必正确，作为参考即可，其他编程环境比如C#、JAVA请忽略，也许差别可能在中间通信的效率造成的；</li>
</ul>
<h3 id="170-开源的图表控件QCustomPlot很经典，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点"><a href="#170-开源的图表控件QCustomPlot很经典，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点" class="headerlink" title="170. 开源的图表控件QCustomPlot很经典，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点"></a>170. 开源的图表控件QCustomPlot很经典，在曲线数据展示这块性能彪悍，总结了一些容易忽略的经验要点</h3><ul>
<li>可以将XY轴对调，然后形成横向的效果，无论是曲线图还是柱状图，分组图、堆积图等，都支持这个特性。</li>
<li>不需要的提示图例可以调用 legend-&gt;removeItem 进行移除。</li>
<li>两条曲线可以调用 setChannelFillGraph 设置合并为一个面积区域。</li>
<li>可以关闭抗锯齿 setAntialiased 加快绘制速度。</li>
<li>可以设置不同的线条样式（setLineStyle）、数据样式（setScatterStyle）。</li>
<li>坐标轴的箭头样式可更换 setUpperEnding。</li>
<li>可以用 QCPBarsGroup 实现柱状分组图，这个类在官方demo中没有，所以非常容易忽略。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对调XY轴，在最前面设置</span><br>QCPAxis *yAxis = customPlot-&gt;yAxis;<br>QCPAxis *xAxis = customPlot-&gt;xAxis;<br>customPlot-&gt;xAxis = yAxis;<br>customPlot-&gt;yAxis = xAxis;<br><br><span class="hljs-comment">//移除图例</span><br>customPlot-&gt;legend-&gt;removeItem(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//合并两个曲线画布形成封闭区域</span><br>customPlot-&gt;graph(<span class="hljs-number">0</span>)-&gt;setChannelFillGraph(customPlot-&gt;graph(<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//关闭抗锯齿以及设置拖动的时候不启用抗锯齿</span><br>customPlot-&gt;graph()-&gt;setAntialiased(<span class="hljs-literal">false</span>);<br>customPlot-&gt;setNoAntialiasingOnDrag(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//多种设置数据的方法</span><br>customPlot-&gt;graph(<span class="hljs-number">0</span>)-&gt;setData();<br>customPlot-&gt;graph(<span class="hljs-number">0</span>)-&gt;data()-&gt;<span class="hljs-built_in">set</span>();<br><br><span class="hljs-comment">//设置不同的线条样式、数据样式</span><br>customPlot-&gt;graph()-&gt;setLineStyle(QCPGraph::lsLine);<br>customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle::ssDot);<br>customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(shapes.at(i), <span class="hljs-number">10</span>));<br><br><span class="hljs-comment">//还可以设置为图片或者自定义形状</span><br>customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(QPixmap(<span class="hljs-string">&quot;./sun.png&quot;</span>)));<br>QPainterPath customScatterPath;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    customScatterPath.cubicTo(qCos(<span class="hljs-number">2</span> * M_PI * i / <span class="hljs-number">3.0</span>) * <span class="hljs-number">9</span>, qSin(<span class="hljs-number">2</span> * M_PI * i / <span class="hljs-number">3.0</span>) * <span class="hljs-number">9</span>, qCos(<span class="hljs-number">2</span> * M_PI * (i + <span class="hljs-number">0.9</span>) / <span class="hljs-number">3.0</span>) * <span class="hljs-number">9</span>, qSin(<span class="hljs-number">2</span> * M_PI * (i + <span class="hljs-number">0.9</span>) / <span class="hljs-number">3.0</span>) * <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br>customPlot-&gt;graph()-&gt;setScatterStyle(QCPScatterStyle(customScatterPath, QPen(Qt::black, <span class="hljs-number">0</span>), QColor(<span class="hljs-number">40</span>, <span class="hljs-number">70</span>, <span class="hljs-number">255</span>, <span class="hljs-number">50</span>), <span class="hljs-number">10</span>));<br><br><span class="hljs-comment">//更换坐标轴的箭头样式</span><br>customPlot-&gt;xAxis-&gt;setUpperEnding(QCPLineEnding::esSpikeArrow);<br>customPlot-&gt;yAxis-&gt;setUpperEnding(QCPLineEnding::esSpikeArrow);<br><br><span class="hljs-comment">//设置背景图片</span><br>customPlot-&gt;axisRect()-&gt;setBackground(QPixmap(<span class="hljs-string">&quot;./solarpanels.jpg&quot;</span>));<br><span class="hljs-comment">//画布也可以设置背景图片</span><br>customPlot-&gt;graph(<span class="hljs-number">0</span>)-&gt;setBrush(QBrush(QPixmap(<span class="hljs-string">&quot;./balboa.jpg&quot;</span>)));<br><span class="hljs-comment">//整体可以设置填充颜色或者图片</span><br>customPlot-&gt;setBackground(QBrush(gradient));<br><span class="hljs-comment">//设置零点线条颜色</span><br>customPlot-&gt;xAxis-&gt;grid()-&gt;setZeroLinePen(Qt::NoPen);<br><span class="hljs-comment">//控制是否鼠标滚轮缩放拖动等交互形式</span><br>customPlot-&gt;setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);<br><br><span class="hljs-comment">//柱状分组图</span><br>QCPBarsGroup *group = <span class="hljs-keyword">new</span> QCPBarsGroup(customPlot);<br>QList&lt;QCPBars*&gt; bars;<br>bars &lt;&lt; fossil &lt;&lt; nuclear &lt;&lt; regen;<br>foreach (QCPBars *bar, bars) &#123;<br>    <span class="hljs-comment">//设置柱状图的宽度大小</span><br>    bar-&gt;setWidth(bar-&gt;width() / bars.size());<br>    group-&gt;append(bar);<br>&#125;<br><span class="hljs-comment">//设置分组之间的间隔</span><br>group-&gt;setSpacing(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<h3 id="180-QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯"><a href="#180-QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯" class="headerlink" title="180. QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯"></a>180. QSqlTableModel大大简化了对数据库表的显示、添加、删除、修改等，唯独对数据库分页操作有点绕弯</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//实例化数据库表模型</span><br>QSqlTableModel *model = <span class="hljs-keyword">new</span> QSqlTableModel(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//指定表名</span><br>model-&gt;setTable(<span class="hljs-string">&quot;table&quot;</span>);<br><span class="hljs-comment">//设置列排序</span><br>model-&gt;setSort(<span class="hljs-number">0</span>, Qt::AscendingOrder);<br><span class="hljs-comment">//设置提交模式</span><br>model-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit);<br><span class="hljs-comment">//立即查询一次</span><br>model-&gt;select();<br><span class="hljs-comment">//将数据库表模型设置到表格上</span><br>ui-&gt;tableView-&gt;setModel(model);<br><br><span class="hljs-comment">//测试发现过滤条件中除了可以带where语句还可以带排序及limit等</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 order by id desc limit 100&quot;</span>);<br><br><span class="hljs-comment">//如果在过滤条件中设置了排序语句则不可以再使用setSort方法</span><br><span class="hljs-comment">//下面的代码结果是执行出错，可能因为setSort又重新增加了order by语句导致多个order by语句冲突了。</span><br>model-&gt;setSort(<span class="hljs-number">0</span>, Qt::AscendingOrder);<br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 order by id desc limit 100&quot;</span>);<br><br><span class="hljs-comment">//通过setFilter设置单纯的where语句可以不用加1=1</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;name=&#x27;张三&#x27;&quot;</span>);<br><span class="hljs-comment">//如果还有其他语句比如排序或者limit等则需要最前面加上1=1</span><br><span class="hljs-comment">//下面表示按照id升序排序，查询结果显示第5-15条记录。</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 order by id asc limit 5,10&quot;</span>);<br><br><span class="hljs-comment">//多个条件用and连接</span><br><span class="hljs-comment">//建议任何时候用了setFilter则最前面写1=1最末尾加上 ; 防止有些地方无法正确执行。</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 and name=&#x27;张三&#x27; and result&gt;=70;&quot;</span>);<br><br><span class="hljs-comment">//下面表示查询姓名是张三的记录，按照id字段降序排序，结果从第10条开始100条，相当于从第10条到110条记录。</span><br>model-&gt;setFilter(<span class="hljs-string">&quot;1=1 and name=&#x27;张三&#x27; order by id desc limit 10,100;&quot;</span>);<br><br><span class="hljs-comment">//在第3行开始添加一条记录</span><br>model-&gt;insertRow(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//立即填充刚刚新增加的行，默认为空需要用户手动在表格中输入。</span><br>model-&gt;setData(model-&gt;index(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>), <span class="hljs-number">100</span>);<br>model-&gt;setData(model-&gt;index(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), <span class="hljs-string">&quot;张三&quot;</span>);<br><span class="hljs-comment">//提交更新</span><br>model-&gt;submitAll();<br><br><span class="hljs-comment">//删除第4行</span><br>model-&gt;removeRow(<span class="hljs-number">3</span>);<br>model-&gt;submitAll();<br><br><span class="hljs-comment">//总之有增删改操作后都需要调用model-&gt;submitAll();来真正执行，否则仅仅是数据模型更新了数据，并不会更新到数据库中。</span><br><br><span class="hljs-comment">//撤销更改</span><br>model-&gt;revertAll();<br></code></pre></td></tr></table></figure>

<h3 id="183-自从c-11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记"><a href="#183-自从c-11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记" class="headerlink" title="183. 自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记"></a>183. 自从c++11标准以后，各种语法糖层出不穷，其中lambda表达式用的最广，基本上从Qt5以后就支持lambda表达式。对于习惯了c99的老一辈的程序员来说，这玩意是个新鲜事物，这里特意做个小理解笔记</h3><ul>
<li>代码格式：<a href="parameters">capture</a> mutable -&gt;return-type {statement}</li>
<li>[capture]：捕捉列表，捕捉列表总是出现在Lambda函数的开始处，实际上，[]是Lambda引出符，编译器根据该引出符判断接下来的代码是否是Lambda函数，捕捉列表能够捕捉上下文中的变量以供Lambda函数使用。</li>
<li>(parameters)：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同括号 () 一起省略。</li>
<li>mutable：mutable修饰符，默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</li>
<li>-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型，我们可以在不需要返回值的时候也可以连同符号 -&gt; 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li>
<li>{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li>
</ul>
<p>捕捉列表有以下几种形式：</p>
<ul>
<li>[var]表示值传递方式捕捉变量var。</li>
<li>[=]表示值传递方式捕捉所有父作用域的变量（包括this）。</li>
<li>[&amp;var]表示引用传递捕捉变量var。</li>
<li>[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）。</li>
<li>[this]表示值传递方式捕捉当前的this指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MainWindow::MainWindow(QWidget *parent)<br>    : QMainWindow(parent)<br>    , ui(<span class="hljs-keyword">new</span> Ui::MainWindow)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">//按钮单击不带参数</span><br>    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [] &#123;<br>        qDebug() &lt;&lt; <span class="hljs-string">&quot;hello lambda&quot;</span>;<br>    &#125;);<br><br>    <span class="hljs-comment">//按钮单击带参数</span><br>    connect(ui-&gt;pushButton, &amp;QPushButton::clicked, [] (<span class="hljs-keyword">bool</span> isCheck) &#123;<br>        qDebug() &lt;&lt; <span class="hljs-string">&quot;hello lambda&quot;</span> &lt;&lt; isCheck;<br>    &#125;);<br><br>    <span class="hljs-comment">//自定义信号带参数</span><br>    connect(<span class="hljs-keyword">this</span>, &amp;MainWindow::sig_test, [] (<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) &#123;<br>        qDebug() &lt;&lt; <span class="hljs-string">&quot;hello lambda&quot;</span> &lt;&lt; i &lt;&lt; j;<br>    &#125;);<br><br>    <span class="hljs-function">emit <span class="hljs-title">sig_test</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Qt/">Qt</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Qt/">Qt</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/23/connect%E7%9C%81%E7%95%A5receiver%E4%BC%9A%E6%80%8E%E6%A0%B7/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">connect省略receiver会怎样</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/09/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F%E4%B8%8EQt%E4%BF%A1%E5%8F%B7%E6%A7%BD/">
                        <span class="hidden-mobile">观察者模式模式与Qt信号槽</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?82365797a7f92a0aa6495822ee0829a4";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
